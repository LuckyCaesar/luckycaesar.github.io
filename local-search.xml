<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>一致性Hash算法-Hash环</title>
    <link href="/article/%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95-Hash%E7%8E%AF/"/>
    <url>/article/%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95-Hash%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<p>一致性哈希算法（Consistent HashingAlgorithm）是一种哈希算法，它在分布式系统中用于存储和检索数据。</p><p>可以看看这篇文章简单理解学习一下：<ahref="https://segmentfault.com/a/1190000040422632">一致性哈希算法-散列及Hash环相关的一些理解</a></p><p>以下是一个简单的Java实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsistencyHash</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span>[] CHAR_ARR = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<br>            <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;j&#x27;</span>, <span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>,<br>            <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;q&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>,<br>            <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-string">&#x27;J&#x27;</span>, <span class="hljs-string">&#x27;K&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>,<br>            <span class="hljs-string">&#x27;N&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;P&#x27;</span>, <span class="hljs-string">&#x27;Q&#x27;</span>, <span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-string">&#x27;T&#x27;</span>, <span class="hljs-string">&#x27;U&#x27;</span>, <span class="hljs-string">&#x27;V&#x27;</span>, <span class="hljs-string">&#x27;W&#x27;</span>, <span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-string">&#x27;Y&#x27;</span>, <span class="hljs-string">&#x27;Z&#x27;</span>,<br>            <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Ring</span> <span class="hljs-variable">ring</span> <span class="hljs-operator">=</span> buildRing();<br>        ArrayList&lt;Node&gt; virtualNodeList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        ArrayList&lt;Node&gt; actualNodeList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Node node : ring.table) &#123;<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (node.isVirtual) &#123;<br>                    virtualNodeList.add(node);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    actualNodeList.add(node);<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;virtualNodeList: &quot;</span>);<br>        <span class="hljs-keyword">for</span> (Node node : virtualNodeList) &#123;<br>            System.out.println(node.name + <span class="hljs-string">&quot;, index=&quot;</span> + node.index);<br>        &#125;<br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;actualNodeList: &quot;</span>);<br>        <span class="hljs-keyword">for</span> (Node node : actualNodeList) &#123;<br>            System.out.println(node.name + <span class="hljs-string">&quot;, index=&quot;</span> + node.index + <span class="hljs-string">&quot;, size=&quot;</span> + node.dataList.size());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Ring <span class="hljs-title function_">buildRing</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 数据倾斜：环的容量尽量不要比节点（包括虚拟节点）的数量大太多，或者尽可能的增加节点（或虚拟节点）</span><br>        <span class="hljs-comment">// 此处节点+虚拟节点的数量刚好占满整个环，所以数据一定是很均匀的</span><br>        <span class="hljs-type">Ring</span> <span class="hljs-variable">ring</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ring</span>(<span class="hljs-number">8</span>, <span class="hljs-literal">true</span>);<br>        ring.addNode(<span class="hljs-string">&quot;node1&quot;</span>);<br>        ring.addNode(<span class="hljs-string">&quot;node2&quot;</span>);<br>        ring.addNode(<span class="hljs-string">&quot;node3&quot;</span>);<br>        ring.addNode(<span class="hljs-string">&quot;node4&quot;</span>);<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">18_0000</span>; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> CHAR_ARR[random.nextInt(<span class="hljs-number">62</span>)];<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> CHAR_ARR[random.nextInt(<span class="hljs-number">62</span>)];<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> CHAR_ARR[random.nextInt(<span class="hljs-number">62</span>)];<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> CHAR_ARR[random.nextInt(<span class="hljs-number">62</span>)];<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c5</span> <span class="hljs-operator">=</span> CHAR_ARR[random.nextInt(<span class="hljs-number">62</span>)];<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c6</span> <span class="hljs-operator">=</span> CHAR_ARR[random.nextInt(<span class="hljs-number">62</span>)];<br>            ring.addData(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;c1, c2, c3, c4, c5, c6&#125;));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ring;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ring</span> &#123;<br>        Node[] table;<br>        <span class="hljs-type">int</span> capacity;<br>        <span class="hljs-type">boolean</span> needVirtual;<span class="hljs-comment">// 是否需要自动映射虚拟节点</span><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Ring</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity, <span class="hljs-type">boolean</span> needVirtual)</span> &#123;<br>            <span class="hljs-built_in">this</span>.capacity = capacity;<br>            <span class="hljs-built_in">this</span>.needVirtual = needVirtual;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNode</span><span class="hljs-params">(String nodeName)</span> &#123;<br>            <span class="hljs-keyword">if</span> (table == <span class="hljs-literal">null</span>) &#123;<br>                table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[capacity];<br>            &#125;<br>            <span class="hljs-comment">// 使用节点名称定位</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> calcIndex(nodeName);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> index;<br>            <span class="hljs-comment">// 冲突，已存在节点，这里通过简单的顺移（开放寻址法）来找到合适的节点位置</span><br>            <span class="hljs-keyword">while</span> (table[j] != <span class="hljs-literal">null</span>) &#123;<br>                j++;<br>                <span class="hljs-keyword">if</span> (j &gt;= capacity) &#123;<br>                    j = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (j == index) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;当前环已满，无法再继续添加节点！&quot;</span>);<br>                &#125;<br>            &#125;<br>            table[j] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(j, <span class="hljs-literal">false</span>, nodeName);<br>            <span class="hljs-keyword">if</span> (needVirtual) &#123;<br>                <span class="hljs-comment">// 增加虚拟节点，减少数据倾斜。此处默认只映射一个虚拟节点，可以扩展</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">virtualIndex</span> <span class="hljs-operator">=</span> calcIndex(nodeName + <span class="hljs-string">&quot;-virtual&quot;</span>);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> virtualIndex;<br>                <span class="hljs-keyword">while</span> (table[k] != <span class="hljs-literal">null</span>) &#123;<br>                    k++;<br>                    <span class="hljs-keyword">if</span> (k &gt;= capacity) &#123;<br>                        k = <span class="hljs-number">0</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (k == virtualIndex) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;当前环已满，无法再继续添加虚拟节点！&quot;</span>);<br>                    &#125;<br>                &#125;<br>                table[k] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(k, <span class="hljs-literal">true</span>, nodeName + <span class="hljs-string">&quot;-virtual&quot;</span>);<br>                <span class="hljs-comment">// 指向实际可存储数据的节点</span><br>                table[k].actualNode = table[j];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addData</span><span class="hljs-params">(String data)</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> calcIndex(data);<br>            Node node;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-comment">// 找到一个可用节点。如果当前index上没有节点，则需要向后移动直至遇到一个可用节点，将数据添加到该节点</span><br>            <span class="hljs-keyword">while</span> ((node = table[j]) == <span class="hljs-literal">null</span> || node.status == <span class="hljs-number">0</span>) &#123;<br>                j++;<br>                <span class="hljs-keyword">if</span> (j &gt;= capacity) &#123;<br>                    j = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (j == i) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;找不到可用节点&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node.isVirtual) &#123;<br>                node.actualNode.dataList.add(data);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                node.dataList.add(data);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calcIndex1</span><span class="hljs-params">(String data)</span> &#123;<br>            <span class="hljs-comment">// 借用hashmap的hash算法</span><br>            <span class="hljs-type">int</span> h;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> (data == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = data.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>            <span class="hljs-keyword">return</span> (capacity - <span class="hljs-number">1</span>) &amp; hash;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> index;<br>        <span class="hljs-type">int</span> status; <span class="hljs-comment">// 节点状态，0表示节点不可用，1表示节点可用</span><br>        <span class="hljs-type">boolean</span> isVirtual;<br>        Node actualNode;<br>        String name;<br>        List&lt;String&gt; dataList;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">boolean</span> isVirtual, String name)</span> &#123;<br>            <span class="hljs-built_in">this</span>.index = index;<br>            <span class="hljs-built_in">this</span>.isVirtual = isVirtual;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-built_in">this</span>.status = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (!isVirtual) &#123;<br>                <span class="hljs-built_in">this</span>.dataList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上面示例代码执行一次的输出结果如下，可以看出数据很均匀，因为节点刚好占满整个环：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tex">virtualNodeList: <br>node2-virtual, index=0<br>node3-virtual, index=4<br>node4-virtual, index=6<br>node1-virtual, index=7<br><br>actualNodeList: <br>node4, index=1, size=45222<br>node2, index=2, size=45153<br>node3, index=3, size=44864<br>node1, index=5, size=44761<br></code></pre></td></tr></table></figure><p>如果把上面代码中<strong>环的容量扩展为16，节点数量不变</strong>，运行一次输出结果如下，可以看到出现了比较明显的数据倾斜：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tex">virtualNodeList: <br>node2-virtual, index=0<br>node1-virtual, index=7<br>node4-virtual, index=8<br>node3-virtual, index=12<br><br>actualNodeList: <br>node4, index=1, size=22463<br>node2, index=2, size=45055<br>node3, index=3, size=56216<br>node1, index=13, size=56266<br></code></pre></td></tr></table></figure><p>上述示例代码中的Hash算法采用的是HashMap中的实现，此算法有几个点值得深究：</p><ul><li>为何数组长度必须是 <strong>2^n</strong>？</li><li>为何要右移 <strong>16</strong> 位？</li><li>为何要与自己做 <strong>按位异或</strong> 计算？</li><li>为何使用 <strong>&amp;</strong> 取模而不是 <strong>%</strong>取余？如 a % b = x，当除数b=2^n时，可以使用 &amp; 代替 % 取余，因为 %运算符在计算机中，是使用除法运算实现的，而除法运算的效率比位运算低很多。</li></ul><p>可以参考这两篇文章的一些解答：</p><ul><li><p><ahref="https://blog.csdn.net/a314774167/article/details/100110216">HashMap中的hash算法总结</a></p></li><li><p><ahref="https://javabetter.cn/collection/hashmap.html#_01%E3%80%81hash-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86">hash-方法的原理</a></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>算法，一致性Hash，Hash环</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算术表达式求值-Dijkstra双栈</title>
    <link href="/article/%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC-Dijkstra%E5%8F%8C%E6%A0%88/"/>
    <url>/article/%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC-Dijkstra%E5%8F%8C%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p>双栈结构用于解决一些特定类型的问题，如括号匹配、逆波兰表达式求值等。在数学公式计算中，我们可以使用两个栈来存储操作数和运算符。</p><p>以下是一个简单的Java实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FormulaCalculate</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, Integer&gt; optToPri = Map.of(<br>            <span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-number">1</span>,<br>            <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-number">1</span>,<br>            <span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-number">2</span>,<br>            <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-number">2</span>,<br>            <span class="hljs-string">&quot;^&quot;</span>, <span class="hljs-number">3</span><br>    );<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">formula</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(101 * 88 + (155 / 23 + 12^2)) / 999&quot;</span>;<br>        List&lt;String&gt; formulaList = parseFormula(formula);<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> calcFormulaWithoutBrackets(formulaList);<br>        System.out.println(result.toPlainString()); <span class="hljs-comment">// = 9.04</span><br>        <span class="hljs-comment">// 其他示例：</span><br>        <span class="hljs-comment">// (11 - 2 + (15 / 3 + 12 / 2)) * 99 = -198.00</span><br>        <span class="hljs-comment">// (101 * 88 + (15 / 3 + 12 / 2)) / 1888 = 4.71</span><br>        <span class="hljs-comment">// 11 * 2 - (15 / 3 + 12 * 2) * 99 = -2849.00</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">parseFormula</span><span class="hljs-params">(String formula)</span> &#123;<br>        List&lt;String&gt; formulaList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(formula.length());<br>        LinkedList&lt;String&gt; tmpQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">char</span>[] formulaCharArray = formula.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : formulaCharArray) &#123;<br>            <span class="hljs-comment">// 忽略空格</span><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">32</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (Character.isDigit(c)) &#123;<br>                tmpQueue.add(String.valueOf(c));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>                String chr;<br>                <span class="hljs-keyword">while</span> ((chr = tmpQueue.pollFirst()) != <span class="hljs-literal">null</span>) &#123;<br>                    e += chr;<br>                &#125;<br>                formulaList.add(e);<br>                formulaList.add(String.valueOf(c));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!tmpQueue.isEmpty()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>            String chr;<br>            <span class="hljs-keyword">while</span> ((chr = tmpQueue.pollFirst()) != <span class="hljs-literal">null</span>) &#123;<br>                e += chr;<br>            &#125;<br>            formulaList.add(e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> formulaList;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BigDecimal <span class="hljs-title function_">calcFormulaWithoutBrackets</span><span class="hljs-params">(List&lt;String&gt; formulaList)</span> &#123;<br>        Stack&lt;BigDecimal&gt; stack1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        Stack&lt;String&gt; stack2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String e : formulaList) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 数字直接入栈</span><br>                stack1.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(e)); <span class="hljs-comment">// 或者使用 isNumeric() 方法来判断数字</span><br>            &#125; <span class="hljs-keyword">catch</span> (NumberFormatException ex) &#123;<br>                <span class="hljs-comment">// 非数字，则判断符号</span><br>                <span class="hljs-keyword">if</span> (optToPri.containsKey(e)) &#123;<br>                    <span class="hljs-keyword">if</span> (stack2.isEmpty()) &#123;<br>                        stack2.push(e);<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">opt</span> <span class="hljs-operator">=</span> stack2.peek();<br>                    <span class="hljs-keyword">if</span> (Objects.equals(opt, <span class="hljs-string">&quot;(&quot;</span>)) &#123;<br>                        stack2.push(e);<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    <span class="hljs-comment">// 如果前一个的操作符优先级比当前操作符优先级高，则计算stack1中的最后两个数，并将结果压入stack1，并将当前操作符压入stack2</span><br>                    <span class="hljs-keyword">if</span> (optToPri.get(opt) &gt; optToPri.get(e)) &#123;<br>                        stack1.push(doActualCalc(stack1, opt));<br>                        stack2.pop();<br>                    &#125;<br>                    stack2.push(e);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (Objects.equals(e, <span class="hljs-string">&quot;(&quot;</span>)) &#123;<br>                    stack2.push(e);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (Objects.equals(e, <span class="hljs-string">&quot;)&quot;</span>)) &#123;<br>                    <span class="hljs-keyword">while</span> (!stack2.empty()) &#123;<br>                        <span class="hljs-type">String</span> <span class="hljs-variable">opt</span> <span class="hljs-operator">=</span> stack2.pop();<br>                        <span class="hljs-keyword">if</span> (opt.equals(<span class="hljs-string">&quot;(&quot;</span>)) &#123;<br>                            <span class="hljs-comment">// 左括号出栈，结束</span><br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                        stack1.push(doActualCalc(stack1, opt));<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 结束之后，再处理栈中还剩下的元素</span><br>        <span class="hljs-keyword">while</span> (!stack2.isEmpty()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">opt</span> <span class="hljs-operator">=</span> stack2.pop();<br>            stack1.push(doActualCalc(stack1, opt));<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack1.pop();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNumeric</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> str.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sz; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!Character.isDigit(str.charAt(i))) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BigDecimal <span class="hljs-title function_">doActualCalc</span><span class="hljs-params">(Stack&lt;BigDecimal&gt; stack, String opt)</span> &#123;<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> stack.pop();<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> stack.pop();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (opt) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span> -&gt; num2.add(num1);<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span> -&gt; num2.subtract(num1);<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span> -&gt; num2.multiply(num1);<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span> -&gt; num2.divide(num1, <span class="hljs-number">2</span>, RoundingMode.DOWN);<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;^&quot;</span> -&gt; num2.pow(num1.intValue());<br>            <span class="hljs-keyword">default</span> -&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Undeclared opt: &quot;</span> + opt);<br>        &#125;;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法，算术表达式，Dijkstra双栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Loom - Java虚拟机中的纤程和续体</title>
    <link href="/article/Loom%20-%20Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84%E7%BA%A4%E7%A8%8B%E5%92%8C%E7%BB%AD%E4%BD%93/"/>
    <url>/article/Loom%20-%20Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84%E7%BA%A4%E7%A8%8B%E5%92%8C%E7%BB%AD%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<ahref="https://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html">ProjectLoom: Fibers and continuations for the Java Virtual Machine</a></p></blockquote><h1 id="概要">概要</h1><p>Loom项目（以下简称Loom）的使命是构建一个易于书写、调试、描述和维护的更能满足当下需求的并发应用。线程，自Java诞生的第一天就随之出现，是一种天然且实用的并发结构（关于线程的讨论先搁置一旁，可作为一个单独的议题），但也因其不够灵便的抽象正在被取代。它当前基于操作系统内核线程的实现方式无法充分地满足现代化的需求，而且也会对云上尤其珍贵的计算资源产生浪费。</p><p>Loom将引入纤程 -由Java虚拟机所管理的一种轻量、高效的线程，让开发者可以使用同样简单的抽象却具备更高的性能和更低的占用。我们要做的就是让并发再次变得（更）简单！一个纤程由两部分组成-续体和调度器。由于Java已经有了<code>ForkJoinPool</code>这种设计得很优秀的调度器，那么只要把续体引入到JVM中来即可实现纤程。</p><h1 id="初衷">初衷</h1><p>许多为Java虚拟机编写的应用都是并发的 -这就意味着，类似服务器和数据库这样的程序，必须能应对大量的请求、突现的并发以及对计算资源的竞争。Loom要做的就是大幅降低编写高效的并发应用的难度，或者更准确的说，消除编写并发程序时在简单和高效之间所做的权衡取舍。</p><p>自二十多年前Java首次发布以来，它最重要的一个贡献就是使得线程和同步原语变得易用。Java线程（不管是直接使用，或是间接接触过，譬如处理HTTP请求的Javaservlets）为并发应用的编写提供了一个相对简单的抽象。然而，截至目前，要编写能满足当下需求的并发应用的一个最主要难点在于，由运行时所提供的软件并发单元（线程）无法同域并发单元的规模相匹配，无论是用户、事务还是单个操作。尽管应用层面的并发单元比较粗糙-比如用一个socket连接表示的session，一台服务器仍能够处理高达百万量级的活跃的socket，然而利用操作系统线程实现了Java线程的Java运行时，却无法高效地处理区区几千个连接。这种多个数量级的悬殊会产生很大的影响。</p><p>编程人员不得不做出抉择，是直接把域并发单元建模成一个线程，大大降低单个服务所能支撑的并发规模。还是使用其它的结构实现比线程（任务）更细粒度的并发单元，再通过编写不会阻塞线程运行的<em>异步</em>代码来支持并发。</p><p>近些年来Java生态已经引入了很多异步API，从JDK中的异步NIO、异步Servlets，到许多第三方异步库。这些API被设计出来不是因为它们易于编写和理解- 实际很难上手，也不是因为它们易于调试和描述 -这更困难（它们连真正意义上的堆栈追踪都无法提供），也不是因为它们构建得比同步API更加优雅- 相反并不那么优雅，更不是因为它们能更好地适配其他语言或者整合已有代码 -其实它们适配得很糟糕。只是因为Java中软件并发单元的实现 -线程，在占用和性能方面做的不够好。很不幸，这个良好且自然的抽象正在被抛弃，取而代之的则是那些从许多方面来看都更糟糕的不够自然的抽象，仅仅是想要它运行时的性能特征。</p><p>当然基于内核线程实现的Java线程也有一些优点，主要是内核能支持所有的本地（native）代码，所以运行在线程里的Java代码也能调用本地API。但上文提到的缺点仍大到无法忽视，造成的结果就是要么编码困难、维护成本高，要么会浪费相当多的计算资源，当代码运行在云环境时也将尤其昂贵。实际上，一些语言及它们的运行时已经成功实现了轻量级的线程，最知名的就是Erlang和Go，其展示出来的特性非常实用也广受欢迎。</p><p>Loom最主要的目标就是新增这样一个轻量级线程结构，我们叫它纤程，由Java运行时所管理。当然也允许有选择地使用已有的由操作系统提供的重量级线程。纤程在内存占用上比内核线程要低得多，而且任务切换的开销接近于0。单个JVM实例能派生百万量级的纤程，编程人员可以毫不犹豫的发起同步阻塞的调用，因为这些阻塞实际上是没有成本的。除了能让并发应用变得更简单且/或更具弹性外，这也能让框架库的作者们过得更轻松一些，因为不用再为权衡简单和性能而提供同步和异步两套API。简单将至而无需权衡。</p><p>正如我们所看到的，线程不再是一个原子结构，而是由两个关键部分组成 -调度器和<em>续体</em>。我们目前打算拆分这两部分，然后基于这两个构建块，在其顶层实现Java的纤程。纤程虽然是Loom成立最主要的动机，但引入续体作为一个可面向用户的抽象也占据了一部分原因，因为续体还有其他用途（如：<ahref="https://wiki.python.org/moin/Generators">Python'sgenerators</a>）。</p><h1 id="目标和范围">目标和范围</h1><p>纤程能提供一个低级别的原语，可以基于它实现一些有趣的编程范式，比如管道、actor<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[https://en.wikipedia.org/wiki/Actor_model](https://en.wikipedia.org/wiki/Actor_model)">[1]</span></a></sup>和数据流<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[https://en.wikipedia.org/wiki/Dataflow_programming](https://en.wikipedia.org/wiki/Dataflow_programming)">[2]</span></a></sup>。虽然这些用途也会被考虑在内，但Loom的目标<em>不是</em>设计这些更高级别的结构，也并不建议新的编程风格或者推荐一些在纤程之间进行数据交换的模式（如：共享内存vs消息传递）。由于限制线程访问内存的问题是其他OpenJDK项目的主题，也由于此问题（指当前这种线程抽象模型存在的缺点）存在于所有基于线程抽象的实现，不管是轻量的还是重量的，所以Loom可能会和其他项目有所交叉。</p><p>Loom的目标是添加一个轻量的线程结构 - 纤程 -到Java平台上。它会以何种形式呈现在用户面前将在后面进行讨论。首要目的就是让<em>大部分</em>Java代码（意思是Java类文件中的代码，不一定是使用Java语言编写的）无需修改或者以最小的修改就能运行在纤程之中。让Java代码调用的本地代码能运行在纤程之中<em>不是必需</em>的，虽然在某些环境下<em>可能</em>会出现这种情况。让运行在纤程中的<em>每一段</em>代码都能享有性能优势也不是最终目的。实际上，一些不适合轻量级线程的代码在性能上反而会有所损失。</p><p>Loom的另一个目标是添加一个公共的<em>限定续体</em><sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[https://en.wikipedia.org/wiki/Delimited_continuation](https://en.wikipedia.org/wiki/Delimited_continuation)">[3]</span></a></sup>（或<em>协程</em><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[https://en.wikipedia.org/wiki/Coroutine](https://en.wikipedia.org/wiki/Coroutine)">[4]</span></a></sup>）到Java平台上。当然，相对于纤程（它需要续体，但这些续体无需暴露为公共的API，接下来会有说明）而言它是较次要的。</p><p>Loom还有一个目标是尝试为纤程提供各式的<em>调度器</em>，但<em>并不会</em>深入研究调度器的设计，因为我们相信<code>ForkJoinPool</code>会是一个非常棒的纤程调度器。</p><p>正如同把操纵调用栈<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[https://en.wikipedia.org/wiki/Call_stack](https://en.wikipedia.org/wiki/Call_stack)">[5]</span></a></sup>的能力添加到JVM中是必须的一样，引入一个能把栈展开<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[https://en.wikipedia.org/wiki/Call_stack#Unwinding](https://en.wikipedia.org/wiki/Call_stack#Unwinding)">[6]</span></a></sup>到某个点并使用给定参数执行某个方法的更轻量的结构体也同样是Loom的目标之一（总的来说就是高效尾调用<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[https://en.wikipedia.org/wiki/Tail_call](https://en.wikipedia.org/wiki/Tail_call)">[7]</span></a></sup>的泛化）。我们把这个特性叫做<em>unwind-and-invoke</em>，或者叫UAI。当然，这并不是说要新增一个尾调用的自动优化到JVM当中。</p><p>Loom可能会涉及到Java平台上一些不同的组件，会依照各自的特性来进行划分：</p><ul><li>续体和UAI会在JVM中得到实现并对外提供非常简单的Java API。</li><li>纤程主要在JDK中使用Java来实现，但也需要一些JVM的支持。</li><li>JDK中使用到的会使得线程阻塞的本地代码可能需要做一些适配以便于能在纤程中也正常运行。特别注意，这意味着要修改<code>java.io</code> 类。</li><li>JDK中使用到的一些低级别的线程同步器（尤其是<code>LockSupport</code>类），比如<code>java.util.concurrent</code>，需要做一些适配来支持纤程，但是工作量取决于纤程API的设计。当然无论如何，预期改动还是比较小的（因为纤程会提供一个跟线程很相似的API）。</li><li>调试器、分析器及其他一些服务性质的功能也需要感知到纤程的存在以便于提供更好的用户体验。这意味着JFR和JVMTI需要考虑到纤程，而且相关平台的MBeans也需要添加进来。</li><li>目前为止，我们不认为需要对Java语言本身做改动。</li></ul><p>目前还处于项目的早期阶段，所以一切 - 包括其范围，都有可能调整。</p><h1 id="术语">术语</h1><p>由于内核线程和轻量级线程只是同一种抽象的不同实现，那么很多术语上的混淆就会接踵而至。此文档会约定以下协议，且每一处通信均会遵循：</p><ul><li>词语<em>线程</em>只代表抽象本身（不久将进行探讨），不会再指代任何特定的实现。所以<em>线程</em>可能指代抽象的任何实现，不管是基于操作系统还是运行时。</li><li>当想要指代某个特定的实现时，可以用<em>重量级线程</em>、<em>内核线程</em>或者<em>操作系统线程</em>这样的措辞来表示基于操作系统内核实现的线程。用<em>轻量级线程</em>、<em>用户态线程</em>以及<em>纤程</em>这样的字眼来表示由语言运行时-在Java平台上即JVM和JDK，实现的线程。且这些词语都不会用来描述特定的Java类（至少在目前API设计尚不明了的早期阶段不会）。</li><li>首字母大写的单词<code>Thread</code>和<code>Fiber</code>会特指具体的Java类，主要被用于API设计的讨论，而非实现。</li></ul><h1 id="何为线程">何为线程</h1><p><em>线程</em>是一系列有序执行的计算机指令的集合。当我们在处理一些除计算外，还有IO、时停和同步的操作-即那些会导致计算流去等待某些额外事件的指令时，线程需具备这样的能力，能<em>挂起</em>它自己，并且当这些等待的事件出现时也能<em>自动恢复</em>运行。在线程等待期间，它应该让出CPU的使用权，使得其它线程能够正常运行。</p><p>这些能力主要涉及到两个不同方面的内容。<em>续体</em>是一系列有序执行的指令集，而且可以自我挂起（有关续体的更深入的讨论会在接下来的<ahref="#续体">续体</a>这一章节进行）。<em>调度器</em>会把续体分配到CPU核心上，用准备好的替换那些暂停的，并且要保证那些即将恢复执行的续体能最终被分配到CPU上继续运行。故而一个线程需要包含两个结构：续体和调度器，不过它们应该没有必要拆分出来暴露为APIs。</p><p>另一方面，线程表示一个最基础的抽象 -至少在当前上下文中，且并未实现任何的编程范式。尤其要说明的一点是，他们仅指代那些编程人员编写的可运行和暂停的顺序性代码的抽象，而不会涉及到任何在线程之间进行信息共享的机制，比如共享内存或者消息传递。</p><p>由于涉及到两个独立的部分，我们可以选择不一样的实现。目前，Java平台提供的线程结构是<code>Thread</code>类，是基于内核线程实现的。且续体和调度器的实现都依赖于操作系统。</p><p>由Java平台暴露出来的续体结构可以和现有的Java调度器进行结合 -如<code>ForkJoinPool</code>、<code>ThreadPoolExecutor</code>或者第三方的实现，也可以和为了实现纤程而特殊优化的调度器进行结合。</p><p>当然也可以在运行时和操作系统之间把这两个线程的构建块实现进行拆分。比如，在Google（<ahref="https://www.youtube.com/watch?v=KXuZi9aeGTw">视频</a>，<ahref="http://www.linuxplumbersconf.org/2013/ocw/system/presentations/1653/original/LPC%20-%20User%20Threading.pdf">幻灯片</a>）对Linux内核的修改中，允许用户态代码来接管调度内核线程，因此从本质上来说续体的实现仅依赖于操作系统，同时让一些库来操纵调度。由用户态调度的同时仍允许本地代码运行在这种线程实现上确实带来了一些好处，但也存在占用相对而言较高以及栈无法调整大小的弊端，而且截至目前尚不可用。拆分实现的另外一种方式- 由操作系统进行调度而运行时来实现续体 -看起来似乎没有任何好处，因为此方案综合了二者的缺点。</p><p>但是，为何用户态线程在各个方面都比内核线程更好，为何它们能称得上<em>轻量</em>？同样，（用户态线程）让续体和调度器这两个组件分开考虑时也变得很方便。</p><p>要暂停一次计算，续体必须能够存储完整的调用栈上下文，或者简单地说，能存储栈。为了支持本地语言，存储栈的内存空间必须是连续的且要始终保持处于同一片内存地址。虽然虚拟内存能提供一些灵活性，但是这种内核续体（即栈）在轻量性和灵活度方面仍旧存在着一些限制。理想情况下，我们期望栈是可以根据使用情况来扩展或收缩的。由于语言运行时实现的线程是无需支持任何本地代码的，所以我们可以在如何存储续体方面获得更大的灵活度，还能够减少空间的占用。</p><p>基于操作系统实现的线程在调度器上存在着很多问题。比如，操作系统调度器会运行在内核模式下，因此每当一个线程阻塞且控制权回到调度器时，必然会产生不小的内核态/用户态切换的开销。再比如，操作系统调度器的设计是偏通用的且能调度各种各样的程序线程。但是，一个视频编码线程的行为必然同一个处理网络IO请求的线程的行为有很大差别，同一个调度算法肯定无法同时成为二者的最佳选择。在服务端上处理事务的线程倾向于表现出某些特定的行为模式，这也会考验通用操作系统调度器的调度能力。举个例子，对于一个处理事务的线程<code>A</code>来说，在一次请求上执行一些动作然后再把数据传递给另一个线程<code>B</code>再做一些更多的处理，是一种很常见的行为模式。那么此时需要在两个线程之间进行切换时引入一些同步机制，像锁或者消息队列，但是仍保持同样的行为：<code>A</code>操作一些数据<code>x</code>，唤醒<code>B</code>并把数据传递给它，然后<code>A</code>进入阻塞直到被来自网络或者另一个线程的新请求唤醒。这种模式极其普遍，所以我们可以假定<code>A</code>在唤醒<code>B</code>之后很快进入阻塞，那么此时将<code>B</code>调度到和<code>A</code>一样的核心上会有很多好处，因为<code>x</code>已经存在于该核心的缓存之中。此外，把<code>B</code>添加到核心的本地队列中也无需任何额外的同步争用开销。实际上，正是有了<code>ForkJoinPool</code>这样的工作窃取调度器才使得这种假设能如此精确，因为它会将运行中的任务所调度的任务添加到本地队列当中。然而，对于操作系统内核来说，却无法作出此种假设。在内核看来，线程<code>A</code>在唤醒<code>B</code>之后可能仍需持续运行一段时间，那么它就会把刚刚非阻塞状态的线程<code>B</code>调度到不同的核心上，因此两个线程都需要做一些同步保证，而且一旦<code>B</code>访问<code>x</code>就会引发缓存故障。</p><h1 id="纤程">纤程</h1><p>所以，纤程就是我们所说的Java中计划的用户态线程。本章节会列出纤程的需求并探讨一些设计上的问题和各种选项。当然，这并不是说要写得详尽无遗，相反只会呈现一些设计空间的轮廓并营造一种参与挑战的氛围。</p><p>从基础能力方面来看，纤程必须能够运行在任意的Java代码片段之中，能和其他线程（轻量级或重量级）并发，且允许用户等待它们终止运行，即所谓的join。很明显，必须有某种机制来保证纤程的挂起和恢复，类似于<code>LockSupports</code>的<code>park/unpark</code>方法。当然，我们也要能拿到纤程的堆栈追踪信息，用于监控/调试的同时也能跟踪它们的状态（挂起/运行中）等等。简而言之，由于纤程仍是一种线程，那么它就跟<code>Thread</code>类所代表的重量级线程有着非常相似的API。再考虑到Java的内存模型，那么纤程会表现得跟目前的<code>Thread</code>一模一样。由于纤程将会使用JVM管理的续体来实现，所以我们也得考虑让它们也跟操作系统的续体保持兼容，类似Google的用户调度内核线程的实现。</p><p>另一个相对重要的设计决策聚焦在线程本地变量。目前，线程本地变量数据是由（<code>Inheritable</code>）<code>ThreadLocal</code>类来标识。那么我们在纤程中如何处理线程本地变量呢？关键在于，<code>ThreadLocal</code>中有两个非常不一样的用法。一个是使用线程上下文来关联数据，纤程可能也需要有这样的能力。另一个是利用条带化<sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[https://en.wikipedia.org/wiki/Data_striping](https://en.wikipedia.org/wiki/Data_striping)">[8]</span></a></sup>来减少并发数据结构中的争用。其实这种用法把<code>ThreadLocal</code>作为处理器本地（更准确的说是，CPU核心的本地）近似结构（anapproximation of aprocessor-local<sup id="fnref:9" class="footnote-ref"><a href="#fn:9" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="GPT的回答：一个approximation of a processor-local是指一种在计算机系统中轻松分配计算资源给各个处理器的方式。通常，处理器是计算机系统中执行计算的单个组件。一个approximation的processor-local是一种近似方法，它使得计算任务在多个处理器之间分配，从而实现更高效的计算能力和扩展性。通常，processor-local approximations可以通过以下方式实现：1. 数据划分：根据数据的特点将数据分为多个部分，并将这些部分分配给不同的处理器。2. 通信协议：通过多种协议，允许处理器之间共享数据，以实现分布式计算。3. 并行计算库：使用已有的并行计算库，可以帮助程序员更轻松地实现并行化。总之，一个processor-local approximation允许您根据计算任务和计算资源来分配任务和资源。这种近似方法有助于提高计算效率和扩展性。">[9]</span></a></sup>construct）而滥用了。在纤程里，这两种不同的用法可能需要明确地拆分开来，因为如今可能跨越百万量级线程（指纤程）的线程本地变量已经不再是一个良好的处理器本地数据近似了。将线程作为上下文与将线程作为处理器近似从而进行更精确处理的要求不仅限于实际的<code>ThreadLocal</code>类，还包括将线程实例映射到数据以实现条带化的任何类。如果纤程由<code>Thread</code>s来表示，那么针对这种条带化数据结构得做一些调整。不管怎样，预计都会随着纤程的新增而添加一个显式API来访问处理器标识，不管是精确的还是近似的。</p><p>内核线程很重要的一个特性是基于时间分片的抢占（这里也可以简单地称之为，强力地或强制地抢占）。一个计算了一段时间且没有阻塞IO或者同步的内核线程会在一定时间后被强制抢占。虽然这乍一看对纤程来说也是一个很重要的设计和实现难点- 当然，我们也确实决定要支持它，利用JVM safepoints可以简单地实现，但是其实这个能力并不重要，即便加上之后也没有多少变化（所以最好抛开它）。原因如下：不同于内核线程，纤程的数量会很多（几十上百万量级）。如果<em>大量</em>纤程都需要很多的CPU时间，会导致它们<em>频繁</em>地被强制抢占，那么当线程数量超过核心数量几个量级时，应用就会由于这种数量级的差距而供不应求，任何调度策略都无济于事。如果需要<em>大量</em>纤程<em>低频</em>运行长耗时的计算任务，那么一个好的调度器会把纤程合理地分配到可用核心（即工作内核线程）上。如果需要<em>少量</em>纤程<em>高频</em>运行长耗时的计算任务，那么最好使用重量级线程。因此不同的线程实现虽然提供了同样的抽象，但有时仍会出现某种实现好于另一种的情况。对纤程来说也不必做到在任何情况下都得比内核线程更优。</p><p>然而，真正实现上的挑战可能在于如何协调好纤程与能阻塞内核线程的内置JVM代码的关系。示例包括了隐形代码，譬如把类从硬盘加载到面向用户的功能模块当中，又或者像<code>synchronized</code>和<code>Object.wait</code>。由于纤程调度器会以多路复用的方式将大量纤程调度到少量工作内核线程之上，那么阻塞内核线程可能会占用调度器的很大一部分可用资源，当然是需要避免的。</p><p>考虑一个极端，上述每种情况都需要对纤程友好，即：如果是由纤程触发的阻塞，那么只会阻塞纤程而不是底层的内核线程。而另一个极端，所有情况下都忽略纤程继续去阻塞底层的内核线程。在这二者之间，我们可以使得一部分构造成为纤程阻塞而另一部分仍然保持内核线程阻塞。有诸多例子能给出合理的理由来维持原状，即保持内核线程阻塞。比如，类加载只会在启动期间频繁触发，而在启动后很少触发。因此，正如上述所说，纤程调度器围绕着这种阻塞可以简单地调度处理。而许多对<code>synchronized</code>的使用是为了内存访问的保护并且只会阻塞非常短的时间-完全可以忽略它。所以我们甚至可能决定不去改动<code>synchronized</code>，然后鼓励那些使用了<code>synchronized</code>来做IO访问同步及需要频繁阻塞的代码改为使用<code>j.u.c</code>里面的同步结构（它们会是纤程友好的），如果这些代码想要运行在纤程中的话。类似的，对于<code>Object.wait</code>的使用，虽然在现代代码中并不常见，但是仍然建议（至少目前为止我们建议）改为使用<code>j.u.c</code>。</p><p>不管怎样，一个纤程阻塞了其所在的底层内核线程就会触发一些能被JFR/Mbeans监控到的系统事件。</p><p>虽然纤程鼓励使用寻常、简单且自然的同步阻塞代码，但其实适配现有的异步APIs也很简单，会把它们转换成纤程阻塞的模式。假定有这么一个库提供了下面这样一个为了某些长耗时操作而设计的异步API- <code>foo</code>，然后返回了一个<code>String</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">AsyncFoo</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">asyncFoo</span><span class="hljs-params">(FooCompletion callback)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的回调或者完结处理器<code>FooCompletion</code>有如下定义：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">FooCompletion</span> &#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">success</span><span class="hljs-params">(String result)</span>;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">failure</span><span class="hljs-params">(FooException exception)</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 我们会提供一个异步转纤程阻塞的结构，如下所示：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"> <br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">_AsyncToBlocking</span>&lt;T, E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt; &#123;<br>    <span class="hljs-keyword">private</span> _Fiber f;<br>    <span class="hljs-keyword">private</span> T result;<br>    <span class="hljs-keyword">private</span> E exception;<br>  <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">_complete</span><span class="hljs-params">(T result)</span> &#123;<br>        <span class="hljs-built_in">this</span>.result = result;<br>        unpark f<br>    &#125;<br>  <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">_fail</span><span class="hljs-params">(E exception)</span> &#123; <br>        <span class="hljs-built_in">this</span>.exception = exception;<br>        unpark f<br>    &#125;<br>  <br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> E &#123; <br>        <span class="hljs-built_in">this</span>.f = current fiber<br>        <span class="hljs-title function_">register</span><span class="hljs-params">()</span>;<br>        park<br>        <span class="hljs-title function_">if</span> <span class="hljs-params">(exception != <span class="hljs-literal">null</span>)</span><br>           <span class="hljs-keyword">throw</span> exception;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>  <br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">run</span><span class="hljs-params">(_timeout)</span> <span class="hljs-keyword">throws</span> E, TimeoutException &#123; ... &#125;<br>  <br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 然后我们可以通过定义以下的类来创建一个阻塞版本的API：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncFooToBlocking</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">_AsyncToBlocking</span>&lt;String, FooException&gt; <br>     <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FooCompletion</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">success</span><span class="hljs-params">(String result)</span> &#123;<br>    _complete(result);<br>  &#125;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">failure</span><span class="hljs-params">(FooException exception)</span> &#123;<br>    _fail(exception);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 再然后我们就可以把异步API封装成同步版本： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SyncFoo</span> &#123;<br>    <span class="hljs-type">AsyncFoo</span> <span class="hljs-variable">foo</span> <span class="hljs-operator">=</span> get instance;<br>  <br>    String <span class="hljs-title function_">syncFoo</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> FooException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncFooToBlocking</span>() &#123;<br>          <span class="hljs-meta">@Override</span> <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">()</span> &#123; foo.asyncFoo(<span class="hljs-built_in">this</span>); &#125;<br>        &#125;.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>可以用这种方式把一些通用的异步类都涵盖进来，比如<code>CompletableFuture</code>。</p><h1 id="续体">续体</h1><p>向Java平台中添加续体的初始动机是实现纤程，但续体也有一些其他有趣的用途，这也是把续体作为公共API暴露出来的次要目的。当然，这些其他用途带来的好处预期肯定是远不如纤程的。实际上，续体不会在纤程之上增加表达力<sup id="fnref:10" class="footnote-ref"><a href="#fn:10" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[https://en.wikipedia.org/wiki/Expressive_power_(computer_science)](https://en.wikipedia.org/wiki/Expressive_power_(computer_science))">[10]</span></a></sup>（即，续体可以在纤程之上去实现）。</p><p>在本文及Loom项目的任何地方，<em>续体</em>这个词都指代<em>定界续体</em>（有时候也称之为<em>协程</em><sup id="fnref:11" class="footnote-ref"><a href="#fn:11" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="是否将其称为续体或协程仍待定 — 它们的含义有所不同，但命名目前没有完全标准化，续体可能是更通用的术语">[11]</span></a></sup>）。这里我们把定界续体想成是一段可以挂起（它自己）和（由它的调用者）恢复执行的串行代码。一些人可能对另一种说法更熟悉一点，把续体认为是一组对象（通常是子程序），它们代表了一次计算的“余下”或者“未来”部分。这二者描述的其实是一件事情：一个挂起的续体是一个对象，当它被恢复或者“被调用”时，会执行一些剩下的计算。一个定界续体是一段带有入口点（entrypoint）的串行子程序（就像线程一样），这里我们简单地称其为<em>入口点</em>（在Scheme中，这个叫做<em>重置点</em>（resetpoint）），它可以在某些时候挂起或者让出执行，所以我们也可以叫做<em>挂起点</em>（suspensionpoint）或者<em>让出点</em>（yieldpoint）。当一个定界续体挂起时，控制权会转移到续体之外。而当它恢复时，控制权会回到上次的让出点，那么执行上下文会完好无损地到达入口点。有多种方式可以表达定界续体，但对于Java编程人员来说，以下粗略的伪代码能最好地诠释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">foo() &#123; <span class="hljs-comment">// (2)</span><br>  ... <br>  bar()<br>  ...<br>&#125;<br><br>bar() &#123;<br>  ...<br>  suspend <span class="hljs-comment">// (3)</span><br>  ... <span class="hljs-comment">// (5)</span><br>&#125;<br><br>main() &#123;<br>  c = continuation(foo) <span class="hljs-comment">// (0)</span><br>  c.<span class="hljs-keyword">continue</span>() <span class="hljs-comment">// (1)</span><br>  c.<span class="hljs-keyword">continue</span>() <span class="hljs-comment">// (4)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在(0)处创建了一个续体，入口点是<code>foo</code>。然后执行(1)把控制权传递给续体的入口点(2)处。再然后继续执行直至遇到子程序<code>bar</code>内部的挂起点(3)，此时会返回并重新指向(1)处的调用。当在(4)这个地方再次调用续体时，控制权会返回到后续的让出点(5)这一行。</p><p>此处讨论的续体是“堆叠的”，因为续体可能会阻塞在调用栈的任意嵌套深度之内（在上面的例子中，是阻塞在被<code>foo</code>-即入口点，调用的函数<code>bar</code>内部）。作为对比，非堆叠的续体可能只会在与入口点相同的子程序中挂起。当然，此处的续体是不可重入的，这就意味着对续体的任何调用都可能会改变“当前”的挂起点。换句话说，续体对象是有状态的。</p><p>实现续体最主要的技术任务 -实际上，也是整个项目最主要的任务，是向HotSpot中添加捕获、存储和恢复调用栈的能力，而不是作为内核线程的一部分。且JNI栈帧很大可能也<em>不再支持</em>。</p><p>续体是纤程的基础，如果续体要作为一个公共API暴露出来，那么就需要我们支持嵌套续体。这就意味着在续体内部运行的代码不仅需要能够挂起续体本身，还要能挂起封装它的代码（比如，挂起封装了它的纤程）。举例，续体常见的用途是generators的实现。一个generator会提供一个迭代器，每当generator让出执行时，运行在generator中的代码会给这个迭代器生成另一个值。因此可以用以下代码来表示：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">_Fiber</span>(() -&gt; &#123;<br>  <span class="hljs-keyword">for</span> (Object x : <span class="hljs-keyword">new</span> <span class="hljs-title class_">_Generator</span>(() -&gt; &#123;<br>      produce <span class="hljs-number">1</span><br>      fiber sleep 100ms<br>      produce <span class="hljs-number">2</span><br>      fiber sleep 100ms<br>      produce <span class="hljs-number">3</span><br>  &#125;)) &#123;<br>      System.out.println(<span class="hljs-string">&quot;Next: &quot;</span> + x);<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>在一些参考资料中，表现出此种行为的嵌套续体有时也被叫做“带多具名提示信息的定界续体”（delimitedcontinuations with multiple namedprompts），但是我们还是把它称作<em>作用域续体</em>（scopedcontinuations）。可以看看<ahref="https://blog.paralleluniverse.co/2015/08/07/scoped-continuations">这篇博客</a>对于作用域续体的理论表达力地讨论（对于那些感兴趣的人来说，续体是一种“一般效应”（generaleffect），可以用来达成任意效应 -如赋值，即使在没有任何副作用的纯语言中。这就是为何续体从某种意义上来说是命令式编程中最基础的抽象）。</p><p>运行在续体中的代码不会持有对续体的引用，并且其作用域通常都有一些固定的名称（因此挂起作用域<code>A</code>也会挂起其最内层的续体）。当然，让出点也提供了一种机制，可以在代码和续体实例之间来回传递信息。当一个续体挂起时，无法触发封装了让出点的<code>try/finally</code>块（即，运行在续体中的代码无法检测到正处于挂起过程中）。</p><p>把续体作为纤程中的一个独立结构（无论他们是否会暴露为公共API）来实现的原因之一是明确的关注点分离。因此，续体不是线程安全的且他们的任何操作都不会产生跨线程的happens-before关系。纤程实现时需要负责建立当续体从一个内核线程迁移到另一个内核线程时必要的内存可见性保证。</p><p>可能会新增的API大致如下所示。续体是非常低级别的原语，可能只会被一些库的作者用来构建更高级别的组件（就像<code>java.util.Stream</code>的实现利用了<code>Spliterator</code>一样）。我们期望用到了续体的类会持有一个续体类的私有实例，或者更有可能就是续体的子类，这样续体的实例就不会直接暴露给这些组件的消费者。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">_Continuation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">_Continuation</span><span class="hljs-params">(_Scope scope, Runnable target)</span> <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> _Continuation <span class="hljs-title function_">suspend</span><span class="hljs-params">(_Scope scope, Consumer&lt;_Continuation&gt; ccc)</span><br>    <br>    <span class="hljs-keyword">public</span> ? getStackTrace()<br>&#125;<br></code></pre></td></tr></table></figure>当续体终止时，<code>run</code>方法会返回<code>true</code>。挂起时，会返回<code>false</code>。<code>suspend</code>方法允许在让出点传递数据给续体（使用<code>ccc</code>回调可以向给定的续体实例中注入数据），然后续体也可以返回数据到挂起点（使用返回值，即续体实例本身，可以从中查询一些信息）。</p><p>为了演示通过续体来实现纤程的简易性，这里提供如下示例，部分地、简单地实现了一个代表纤程的<code>_Fiber</code>类。我们可以注意到，大部分的代码都是在维护纤程的状态，以保证它不会被多个并发所调度：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">_Fiber</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> _Continuation cont;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Executor scheduler;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> State state;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable task;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123; NEW, LEASED, RUNNABLE, PAUSED, DONE; &#125;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">_Fiber</span><span class="hljs-params">(Runnable target, Executor scheduler)</span> &#123;<br>        <span class="hljs-built_in">this</span>.scheduler = scheduler;<br>        <span class="hljs-built_in">this</span>.cont = <span class="hljs-keyword">new</span> <span class="hljs-title class_">_Continuation</span>(_FIBER_SCOPE, target);<br>      <br>        <span class="hljs-built_in">this</span>.state = State.NEW;<br>        <span class="hljs-built_in">this</span>.task = () -&gt; &#123;<br>              <span class="hljs-keyword">while</span> (!cont.run()) &#123;<br>                  <span class="hljs-keyword">if</span> (park0())<br>                     <span class="hljs-keyword">return</span>; <span class="hljs-comment">// parking; otherwise, had lease -- continue</span><br>              &#125;<br>              state = State.DONE;<br>        &#125;;<br>    &#125;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!casState(State.NEW, State.RUNNABLE))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>        scheduler.execute(task);<br>    &#125;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">()</span> &#123;<br>        _Continuation.suspend(_FIBER_SCOPE, <span class="hljs-literal">null</span>);<br>    &#125;<br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">park0</span><span class="hljs-params">()</span> &#123;<br>        State st, nst;<br>        <span class="hljs-keyword">do</span> &#123;<br>            st = state;<br>            <span class="hljs-keyword">switch</span> (st) &#123;<br>              <span class="hljs-keyword">case</span> LEASED:   nst = State.RUNNABLE; <span class="hljs-keyword">break</span>;<br>              <span class="hljs-keyword">case</span> RUNNABLE: nst = State.PAUSED;   <span class="hljs-keyword">break</span>;<br>              <span class="hljs-keyword">default</span>:       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>            &#125;<br>        &#125; <span class="hljs-keyword">while</span> (!casState(st, nst));<br>        <span class="hljs-keyword">return</span> nst == State.PAUSED;<br>    &#125;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unpark</span><span class="hljs-params">()</span> &#123;<br>        State st, nst;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-type">State</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> state;<br>            <span class="hljs-keyword">switch</span> (st) &#123;<br>              <span class="hljs-keyword">case</span> LEASED: <br>              <span class="hljs-keyword">case</span> RUNNABLE: nst = State.LEASED;   <span class="hljs-keyword">break</span>;<br>              <span class="hljs-keyword">case</span> PAUSED:   nst = State.RUNNABLE; <span class="hljs-keyword">break</span>;<br>              <span class="hljs-keyword">default</span>:       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>            &#125;<br>        &#125; <span class="hljs-keyword">while</span> (!casState(st, nst));<br>        <span class="hljs-keyword">if</span> (nst == State.RUNNABLE)<br>            scheduler.execute(task);<br>    &#125;<br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">casState</span><span class="hljs-params">(State oldState, State newState)</span> &#123; ... &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="调度器">调度器</h1><p>如上所述，类似<code>ForkJoinPools</code>的工作窃取调度器特别适合用来调度那些经常阻塞或者频繁地与IO及其他线程交互的线程。当然，纤程也会有一些插件化的调度器，或者用户可以自定义实现（调度器的SPI同<code>Executor</code>接口一样简单方便）。从过往经验来看，预计异步模式下的<code>ForkJoinPool</code>可以在绝大部分场景下很好的支撑起纤程的调度，但是我们可能还会去调研一两种其他更简单的设计，如pinned-shceduler，一种总是会把给定的纤程固定调度到指定内核线程上的调度器（假设是固定到处理器）。</p><h1 id="展开调用">展开调用</h1><p>与续体不同，展开的栈帧的内容不会被保留，且无需在任何对象中具象化此结构。</p><p>待续。</p><h1 id="附加挑战">附加挑战</h1><p>虽然实现此目标的主要动机是让并发更容易/更具可扩展性，但由Java运行时实现的线程以及那些运行时可以对其进行更多控制的线程，也有其他优势。比如，这种线程可以在一台机器上暂停并且序列化，然后在另一台机器上被反序列化后再恢复执行。这个特性在分布式系统中很有用，代码可以重新定位到更靠近其访问数据的位置，从而受益。或者在一个<ahref="https://en.wikipedia.org/wiki/Function_as_a_Service">函数即服务</a>的云平台上，一台运行用户代码的机器实例可以在其等待一些额外事件时终止线程，随后在另外一台实例上恢复执行，可能已经是不同的物理机器了。这样的话，可以更好的进行资源利用，且对于服务端和客户端来说也减少了耗时。当然，纤程也会有类似的方法，<code>parkAndSerialize</code>和<code>deserializeAndUnpark</code>。</p><p>由于纤程预期是可被序列化的，那么续体当然也应该可以。一旦它们是可序列化的，那么它们也应该是可被克隆的，因为克隆续体的能力实际上是增加表达力（它允许返回到一个之前的挂起点）。然而，要使得续体的克隆有足够的能力应用于这些场景面临着很大的挑战，因为Java代码在栈外还存储了大量的信息，克隆在某些定制化场景下就会很“深”。</p><h1 id="其他实现">其他实现</h1><p>其他的可以替代纤程来解决并发简易性和性能之间的冲突的方案中，最有名的是aysnc/await。它已经在C#和Node.js中实现，而且大概率也会被标准的JavaScript所采纳。续体和纤程在aysnc/await中占据主导地位，因为它们很容易通过续体来实现（实际上，它可以被一种叫做非堆叠续体的弱形式的限定续体所实现，这种续体不会捕获整个调用栈，只会捕获单个子程序的本地上下文），但反之则不然。</p><p>虽然实现aysnc/await要比完整形态的续体和纤程更简单，但是此方案还远远不能解决问题。虽然async/await使得代码更加简单，并使其看起来像正常的顺序性代码。但与异步代码一样，它仍然需要对现有代码进行大量的改造，且需要在库中提供明确的支持，还不能很好地与同步代码互通。换句话说，它并未真正解决著名的<ahref="http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">"coloredfunction" problem</a>。</p><section class="footnotes"><hr><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><ahref="https://en.wikipedia.org/wiki/Actor_model">https://en.wikipedia.org/wiki/Actor_model</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><ahref="https://en.wikipedia.org/wiki/Dataflow_programming">https://en.wikipedia.org/wiki/Dataflow_programming</a><a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><ahref="https://en.wikipedia.org/wiki/Delimited_continuation">https://en.wikipedia.org/wiki/Delimited_continuation</a><a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><ahref="https://en.wikipedia.org/wiki/Coroutine">https://en.wikipedia.org/wiki/Coroutine</a><a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><ahref="https://en.wikipedia.org/wiki/Call_stack">https://en.wikipedia.org/wiki/Call_stack</a><a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><ahref="https://en.wikipedia.org/wiki/Call_stack#Unwinding">https://en.wikipedia.org/wiki/Call_stack#Unwinding</a><a href="#fnref:6" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:7" class="footnote-text"><span><ahref="https://en.wikipedia.org/wiki/Tail_call">https://en.wikipedia.org/wiki/Tail_call</a><a href="#fnref:7" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:8" class="footnote-text"><span><ahref="https://en.wikipedia.org/wiki/Data_striping">https://en.wikipedia.org/wiki/Data_striping</a><a href="#fnref:8" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:9" class="footnote-text"><span>GPT的回答：一个approximationof aprocessor-local是指一种在计算机系统中轻松分配计算资源给各个处理器的方式。通常，处理器是计算机系统中执行计算的单个组件。一个approximation的processor-local是一种近似方法，它使得计算任务在多个处理器之间分配，从而实现更高效的计算能力和扩展性。通常，processor-localapproximations可以通过以下方式实现：1.数据划分：根据数据的特点将数据分为多个部分，并将这些部分分配给不同的处理器。2.通信协议：通过多种协议，允许处理器之间共享数据，以实现分布式计算。3.并行计算库：使用已有的并行计算库，可以帮助程序员更轻松地实现并行化。总之，一个processor-localapproximation允许您根据计算任务和计算资源来分配任务和资源。这种近似方法有助于提高计算效率和扩展性。<a href="#fnref:9" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:10" class="footnote-text"><span><ahref="https://en.wikipedia.org/wiki/Expressive_power_(computer_science)">https://en.wikipedia.org/wiki/Expressive_power_(computer_science)</a><a href="#fnref:10" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:11"class="footnote-text"><span>是否将其称为续体或协程仍待定 —它们的含义有所不同，但命名目前没有完全标准化，续体可能是更通用的术语<a href="#fnref:11" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>Loom</tag>
      
      <tag>纤程</tag>
      
      <tag>协程</tag>
      
      <tag>续体</tag>
      
      <tag>虚拟线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事务那些事儿</title>
    <link href="/article/%E4%BA%8B%E5%8A%A1%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <url>/article/%E4%BA%8B%E5%8A%A1%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
    
    <content type="html"><![CDATA[<p>事务，保证数据一致性，非常重要，开发人员必备知识点。看看它的定义<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[数据库事务](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1)">[1]</span></a></sup>：</p><blockquote><p><strong>数据库事务</strong>（简称：<strong>事务</strong>）是<ahref="https://zh.wikipedia.org/wiki/数据库管理系统">数据库管理系统</a>执行过程中的一个逻辑单位，由一个有限的<ahref="https://zh.wikipedia.org/wiki/数据库">数据库</a>操作序列构成。</p></blockquote><p>再复习一下它的特性：</p><blockquote><p>并非任意的对数据库的操作序列都是数据库事务。数据库事务拥有以下四个特性，习惯上被称之为<strong><ahref="https://zh.wikipedia.org/wiki/ACID">ACID特性</a></strong>。</p><ul><li><strong>原子性（Atomicity）</strong>：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li><li><strong>一致性（Consistency）</strong>：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。<em>一致状态</em>的含义是数据库中的数据应满足完整性约束。</li><li><strong>隔离性（Isolation）</strong>：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li><li><strong>持久性（Durability）</strong>：已被提交的事务对数据库的修改应该永久保存在数据库中。</li></ul></blockquote><p>话不多说，简单整理总结一下这些年来遇到的一些事务（数据库事务或者框架层的事务）问题及一些重要知识点。</p><h1 id="问题">问题</h1><h2 id="分布式锁和事务的顺序问题">分布式锁和事务的顺序问题</h2><p>一个经典问题，<em>事务须在分布式锁内部</em>。</p><p>如果事务在分布式锁的外部，那么考虑这样一种场景：线程A和线程B出现竞争，均先开启了事务。然后A先获取到锁，B则阻塞等待。A执行完业务逻辑，<em>释放了锁之后才会进行事务提交</em>。那么，在A的事务未提交完成时，B可能已经获取了锁，进入了业务逻辑查到了A提交前的数据或者重复写入了数据（如果表没有唯一键之类的控制）。</p><p>因此，把事务放在分布式锁的内部，在事务提交完成之后再释放锁，能规避此类问题。</p><h2 id="spring注解式事务不生效">Spring注解式事务不生效</h2><p>主要是两种情况：自调用（self-invocation）或者注解放在private方法上。</p><p>放在private方法上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doTransaction</span><span class="hljs-params">()</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>自调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.doTransaction();<br>&#125;<br><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doTransaction</span><span class="hljs-params">()</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这两种情况事务都不会生效（默认SpringAOP的动态代理机制下）。直接看官方说明<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[Using `@Transactional`](https://docs.spring.io/spring-framework/reference/data-access/transaction/declarative/annotations.html#page-title)">[2]</span></a></sup>：</p><blockquote><p>Method visibility and <code>@Transactional</code> in proxy mode</p><p>The <code>@Transactional</code> annotation is typically used onmethods with <code>public</code> visibility. As of 6.0,<code>protected</code> or package-visible methods can also be madetransactional for class-based proxies by default. Note thattransactional methods in interface-based proxies must always be<code>public</code> and defined in the proxied interface. For both kindsof proxies, only external method calls coming in through the proxy areintercepted.</p><p>...</p><p>In proxy mode (which is the default), only external method callscoming in through the proxy are intercepted. This means thatself-invocation (in effect, a method within the target object callinganother method of the target object) does not lead to an actualtransaction at runtime even if the invoked method is marked with<code>@Transactional</code>. Also, the proxy must be fully initializedto provide the expected behavior, so you should not rely on this featurein your initialization code — e.g. in a <code>@PostConstruct</code>method.</p></blockquote><p>即注解必须放在public方法上且必须是外部对象触发的方法调用，代理才会被触发，进而事务才会生效。</p><h2 id="spring的transactiontemplate">Spring的TransactionTemplate</h2><p>在某些场景下，可能不想使用<code>@Transactional</code>注解来控制事务，那么可以使用<code>TransactionTemplate</code>手动开启更小粒度的事务，而不用拆分太多方法和类。</p><p>查看<code>TransactionTemplate</code>的源码可以知道，它也是遵循Spring的事务传播机制的，但是得通过构造器手动指定。Spring初始化的默认bean的传播机制就会执行默认的<em>REQUIRED-如果当前没有事务，则自己新建一个事务，如果当前存在事务，则加入这个事务</em>。</p><p>因此，推荐这两种方式不要混用，很容易产生事务控制不当的问题，因为可能正常情况下都不会单独实例化<code>TransactionTemplate</code>且改变其传播属性。譬如之前就遇到过这样的代码，外层<code>@Transactional</code>默认机制，内层<code>TransactionTemplate</code>手动控制也是默认机制，那就起不到内外隔离的作用。</p><p>TransactionTemplate构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">TransactionTemplate</span><span class="hljs-params">(PlatformTransactionManager transactionManager, TransactionDefinition transactionDefinition)</span> &#123;<br>    <span class="hljs-comment">// 使用transactionDefinition可以指定此模板bean的事务传播机制和隔离级别</span><br>    <span class="hljs-built_in">super</span>(transactionDefinition);<br>    <span class="hljs-built_in">this</span>.transactionManager = transactionManager;<br>&#125;<br></code></pre></td></tr></table></figure><p>TransactionTemplate#execute方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">execute</span><span class="hljs-params">(TransactionCallback&lt;T&gt; action)</span> <span class="hljs-keyword">throws</span> TransactionException &#123;<br>    Assert.state(<span class="hljs-built_in">this</span>.transactionManager != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;No PlatformTransactionManager set&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.transactionManager <span class="hljs-keyword">instanceof</span> CallbackPreferringPlatformTransactionManager cpptm) &#123;<br>        <span class="hljs-keyword">return</span> cpptm.execute(<span class="hljs-built_in">this</span>, action);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 这里会去查找上下文的事务或者创建一个新事务</span><br>        <span class="hljs-type">TransactionStatus</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.transactionManager.getTransaction(<span class="hljs-built_in">this</span>);<br>        T result;<br>        <span class="hljs-keyword">try</span> &#123;<br>            result = action.doInTransaction(status);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (RuntimeException | Error ex) &#123;<br>            <span class="hljs-comment">// Transactional code threw application exception -&gt; rollback</span><br>            rollbackOnException(status, ex);<br>            <span class="hljs-keyword">throw</span> ex;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>            <span class="hljs-comment">// Transactional code threw unexpected exception -&gt; rollback</span><br>            rollbackOnException(status, ex);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UndeclaredThrowableException</span>(ex, <span class="hljs-string">&quot;TransactionCallback threw undeclared checked exception&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.transactionManager.commit(status);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AbstractPlatformTransactionManager#getTransaction方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> TransactionStatus <span class="hljs-title function_">getTransaction</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> TransactionDefinition definition)</span><br>    <span class="hljs-keyword">throws</span> TransactionException &#123;<br><br>    <span class="hljs-comment">// Use defaults if no transaction definition given.</span><br>    <span class="hljs-type">TransactionDefinition</span> <span class="hljs-variable">def</span> <span class="hljs-operator">=</span> (definition != <span class="hljs-literal">null</span> ? definition : TransactionDefinition.withDefaults());<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> doGetTransaction();<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">debugEnabled</span> <span class="hljs-operator">=</span> logger.isDebugEnabled();<br><br>    <span class="hljs-keyword">if</span> (isExistingTransaction(transaction)) &#123;<br>        <span class="hljs-comment">// Existing transaction found -&gt; check propagation behavior to find out how to behave.</span><br>        <span class="hljs-comment">// 此方法check事务传播机制的配置，如无指定，则默认 PROPAGATION_REQUIRED</span><br>        <span class="hljs-keyword">return</span> handleExistingTransaction(def, transaction, debugEnabled);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="mybatis流式查询和spring事务">MyBatis流式查询和Spring事务</h2><p>此处指MyBatis指定ResultHandler的所谓<ahref="https://www.huangchaoyu.com/2022/01/11/mybatis%E5%AE%9E%E7%8E%B0%E7%9C%9F%E6%B5%81%E5%BC%8F%E6%9F%A5%E8%AF%A2mysql/">流式查询</a>。由于其特性，SqlSession开启后，直到查询完毕才会关闭。</p><p>以下是我遇到的一个问题：<em>PostgreSQL数据库</em>，利用这种流式查询在ResultHandler中对数据进行批处理，要求每批数据的事务处理相互独立。使用了Spring的事务注解，但使用了默认的传播机制REQUIRED。当某一批次出现问题时，会抛异常回滚事务，然后继续处理下一批。然而这批数据正常处理完毕，提交事务时会抛错：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">current transaction is aborted, commands ignored until end of transaction block.<br></code></pre></td></tr></table></figure><p>显然，上一批数据虽然抛出异常但实际并未回滚成功，导致事务处于了<em>aborted</em>的状态而无法提交。解决方案很简单，指定事务的传播级别为<em>REQUIRES_NEW</em>，或者直接使用SqlSession手动控制每次的commit和rollback。猜测是因为在流式查询中SqlSession一直未关闭？</p><p>当然，问题目前只出现在PostgreSQL数据库中，其他数据库是否也会有类似的问题，有待进一步验证。</p><p>模拟代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(<span class="hljs-literal">false</span>)) &#123;<br>            sqlSession.select(statement, (resultContext) -&gt; &#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> resultContext.getResultObject();<br>                <span class="hljs-comment">// 这里假定一次只处理一条，实际上是每批次多条</span><br>                service.doSomething(obj);<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Service</span> &#123;<br>    <span class="hljs-comment">// open a new transaction use spring annotation</span><br>    <span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">(Object obj)</span> &#123;<br>        <span class="hljs-comment">// do something</span><br>        ...<br>    &#125;<br><br>    <span class="hljs-comment">// or use sqlSession</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">(SqlSession sqlSession, Object obj)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// do something</span><br>            ...<br>            sqlSession.commit();<br>        &#125; <span class="hljs-keyword">catch</span>(Throwable ex) &#123;<br>            sqlSession.rollback();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="postgresql数据库事务aborted">PostgreSQL数据库事务aborted</h2><p>正如上一节提到的报错：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">current transaction is aborted, commands ignored until end of transaction block.<br></code></pre></td></tr></table></figure><p>PostgreSQL数据库事务有一个特性，如果一个SQL出错后，事务就会变成<em>aborted</em>的状态，此时必须调用<code>rollback</code>或者<code>abort</code><sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[sql-abort](https://www.postgresql.org/docs/current/sql-abort.html)">[3]</span></a></sup>命令来回滚事务。所以，如果想实现类似下面这种功能，那必须得提前设置一个savepoint便于回滚或者<ahref="https://www.modb.pro/db/82136">修改数据库连接参数</a>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">(SqlSession sqlSession)</span> &#123;<br>    <span class="hljs-comment">// 第一个更新操作</span><br>    mapper1.update(...);<br>    <span class="hljs-comment">// 第一个更新之后设置一个savePoint</span><br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> sqlSession.getConnection();<br>    <span class="hljs-type">Savepoint</span> <span class="hljs-variable">savepoint</span> <span class="hljs-operator">=</span> connection.getSavepoint();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 尝试插入，如果抛出DuplicateKey的异常，则更新</span><br>        mapper2.insert(...);<br>    &#125; <span class="hljs-keyword">catch</span>(DuplicateKeyException ex) &#123;<br>        <span class="hljs-comment">// 先rollback至savepoint，再更新。否则会抛错</span><br>        connection.rollback(savepoint);<br>        mapper2.update(...);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2id="mybatis事务管理器和shardingjdbc">MyBatis事务管理器和ShardingJdbc</h2><p>MyBatis提供了几种事务管理器，常用的可能就是<code>JdbcTransaction</code>和<code>SpringManagedTransaction</code>，后者在引入了mybatis-spring的整合包之后才会有。</p><p>一般情况下Spring和MyBatis集成，默认都是使用的<code>SpringManagedTransaction</code>。实例化<code>org.mybatis.spring.SqlSessionFactoryBean</code>的时候可以看出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// SqlSessionFactoryBean#buildSqlSessionFactory</span><br><br><span class="hljs-keyword">protected</span> SqlSessionFactory <span class="hljs-title function_">buildSqlSessionFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    ...<br>    <span class="hljs-comment">// 默认情况下指定SpringManagedTransactionFactory</span><br>    targetConfiguration.setEnvironment(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Environment</span>(<span class="hljs-built_in">this</span>.environment,<br>            <span class="hljs-built_in">this</span>.transactionFactory == <span class="hljs-literal">null</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringManagedTransactionFactory</span>() : <span class="hljs-built_in">this</span>.transactionFactory,<br>            <span class="hljs-built_in">this</span>.dataSource));<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>所以，如果集成了mybatis-spring，但又想要手动控制SqlSession（<code>autoCommit</code>置为false，在需要的时候手动提交和回滚），<strong>那么一定记得使用<code>JdbcTransaction</code></strong>。因为<code>SpringManagedTransaction</code>每次开启connection时，总是会从connection中取<code>autoCommit</code>值，<em>可能导致手动控制事务失效（目前此处的问题是和ShardingJdbc的集成有关）</em>。下面来追踪一下。</p><p>先来看看<code>JdbcTransaction</code>的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcTransaction</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Transaction</span> &#123;<br>  <br>  <span class="hljs-comment">// 持有autoCommit属性，未指定默认值</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> autoCommit<br><br>  <span class="hljs-comment">// 构造器提供了autoCommit参数</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">JdbcTransaction</span><span class="hljs-params">(DataSource ds, TransactionIsolationLevel desiredLevel, <span class="hljs-type">boolean</span> desiredAutoCommit)</span> &#123;<br>    <span class="hljs-built_in">this</span>(ds, desiredLevel, desiredAutoCommit, <span class="hljs-literal">false</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">JdbcTransaction</span><span class="hljs-params">(DataSource ds, TransactionIsolationLevel desiredLevel, <span class="hljs-type">boolean</span> desiredAutoCommit, <span class="hljs-type">boolean</span> skipSetAutoCommitOnClose)</span> &#123;<br>    dataSource = ds;<br>    level = desiredLevel;<br>    autoCommit = desiredAutoCommit;<br>    <span class="hljs-built_in">this</span>.skipSetAutoCommitOnClose = skipSetAutoCommitOnClose;<br>  &#125;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">openConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-keyword">if</span> (log.isDebugEnabled()) &#123;<br>      log.debug(<span class="hljs-string">&quot;Opening JDBC Connection&quot;</span>);<br>    &#125;<br>    connection = dataSource.getConnection();<br>    <span class="hljs-keyword">if</span> (level != <span class="hljs-literal">null</span>) &#123;<br>      connection.setTransactionIsolation(level.getLevel());<br>    &#125;<br>    setDesiredAutoCommit(autoCommit);<br>  &#125;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDesiredAutoCommit</span><span class="hljs-params">(<span class="hljs-type">boolean</span> desiredAutoCommit)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">if</span> (connection.getAutoCommit() != desiredAutoCommit) &#123;<br>        <span class="hljs-keyword">if</span> (log.isDebugEnabled()) &#123;<br>          log.debug(<span class="hljs-string">&quot;Setting autocommit to &quot;</span> + desiredAutoCommit + <span class="hljs-string">&quot; on JDBC Connection [&quot;</span> + connection + <span class="hljs-string">&quot;]&quot;</span>);<br>        &#125; <br>        <span class="hljs-comment">// 此处会重置autoCommit的值为transaction实例化时指定的值。如果手动开启事务时指定了false，那么这里就一定会被置为false</span><br>        connection.setAutoCommit(desiredAutoCommit);<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>      <span class="hljs-comment">// Only a very poorly implemented driver would fail here,</span><br>      <span class="hljs-comment">// and there&#x27;s not much we can do about that.</span><br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionException</span>(<span class="hljs-string">&quot;Error configuring AutoCommit.  &quot;</span><br>          + <span class="hljs-string">&quot;Your driver may not support getAutoCommit() or setAutoCommit(). &quot;</span><br>          + <span class="hljs-string">&quot;Requested setting: &quot;</span> + desiredAutoCommit + <span class="hljs-string">&quot;.  Cause: &quot;</span> + e, e);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再来<code>SpringManagedTransaction</code>的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringManagedTransaction</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Transaction</span> &#123;<br><br>  <span class="hljs-comment">// 持有autoCommit属性，未指定默认值</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> autoCommit;<br><br>  <span class="hljs-comment">// 构造器未提供autoCommit参数</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">SpringManagedTransaction</span><span class="hljs-params">(DataSource dataSource)</span> &#123;<br>    notNull(dataSource, <span class="hljs-string">&quot;No DataSource specified&quot;</span>);<br>    <span class="hljs-built_in">this</span>.dataSource = dataSource;<br>  &#125;<br> <br>  <span class="hljs-comment">// 这里有关于autoCommit的解释，为什么每次开启都需要从connection中取值</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Gets a connection from Spring transaction manager and discovers if this &#123;<span class="hljs-doctag">@code</span> Transaction&#125; should manage</span><br><span class="hljs-comment">   * connection or let it to Spring.</span><br><span class="hljs-comment">   * &lt;p&gt;</span><br><span class="hljs-comment">   * It also reads autocommit setting because when using Spring Transaction MyBatis thinks that autocommit is always</span><br><span class="hljs-comment">   * false and will always call commit/rollback so we need to no-op that calls.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">openConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-built_in">this</span>.connection = DataSourceUtils.getConnection(<span class="hljs-built_in">this</span>.dataSource);<br>    <span class="hljs-comment">// 这里会从connection中取值，那么手动开启事务时指定的autoCommit=false，可能就会失效</span><br>    <span class="hljs-built_in">this</span>.autoCommit = <span class="hljs-built_in">this</span>.connection.getAutoCommit();<br>    <span class="hljs-built_in">this</span>.isConnectionTransactional = DataSourceUtils.isConnectionTransactional(<span class="hljs-built_in">this</span>.connection, <span class="hljs-built_in">this</span>.dataSource);<br><br>    LOGGER.debug(() -&gt; <span class="hljs-string">&quot;JDBC Connection [&quot;</span> + <span class="hljs-built_in">this</span>.connection + <span class="hljs-string">&quot;] will&quot;</span><br>        + (<span class="hljs-built_in">this</span>.isConnectionTransactional ? <span class="hljs-string">&quot; &quot;</span> : <span class="hljs-string">&quot; not &quot;</span>) + <span class="hljs-string">&quot;be managed by Spring&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.connection != <span class="hljs-literal">null</span> &amp;&amp; !<span class="hljs-built_in">this</span>.isConnectionTransactional &amp;&amp; !<span class="hljs-built_in">this</span>.autoCommit) &#123;<br>      LOGGER.debug(() -&gt; <span class="hljs-string">&quot;Committing JDBC Connection [&quot;</span> + <span class="hljs-built_in">this</span>.connection + <span class="hljs-string">&quot;]&quot;</span>);<br>      <span class="hljs-built_in">this</span>.connection.commit();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollback</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.connection != <span class="hljs-literal">null</span> &amp;&amp; !<span class="hljs-built_in">this</span>.isConnectionTransactional &amp;&amp; !<span class="hljs-built_in">this</span>.autoCommit) &#123;<br>      LOGGER.debug(() -&gt; <span class="hljs-string">&quot;Rolling back JDBC Connection [&quot;</span> + <span class="hljs-built_in">this</span>.connection + <span class="hljs-string">&quot;]&quot;</span>);<br>      <span class="hljs-built_in">this</span>.connection.rollback();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从注释来看，这里会出现两种情况：一种是事务完全交给Spring管理，那这里<code>autoCommit</code>自然不为true且总是会调用<code>commit</code>或者<code>rollback</code>方法提交或回滚。另一种情况则由connection本身来决定，Spring无需干涉。</p><p>所以，当引入了ShardingSphere并完全使用<code>ShardingSphereDataSource</code>来进行数据源的管理时，问题就出现了。因为<code>Connection</code>的实现类会被替换成<code>ShardingSphereConnection</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShardingSphereConnection</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractConnectionAdapter</span> &#123;<br><span class="hljs-comment">// 这里，autoCommit默认为true</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">autoCommit</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么这里默认为true，再结合上面对<code>SpringManagedTransaction</code>的分析，不难看出会忽略手动开启事务时设置的<code>autoCommit</code>值，事务也随之失效。</p><p>在<ahref="https://github.com/apache/shardingsphere/issues/7374">issue</a>上找到一些官方的回复，可以知道此处的默认值跟其底层设计理念有关：</p><p><img src="/img/image-20240113111229890.png" /></p><p><img src="/img/image-20240113111242267.png" /></p><p>最后再梳理下，可以看出其实MyBatis配置错误才是根因：</p><ul><li><p>MyBatis指定事务控制实现时，<strong>未正确配置对应的实现类，想手动控制事务却指定了<code>SpringManagedTransaction</code>的实现</strong></p></li><li><p>在配置错误的情况下，引入ShardingJdbc，再由于<code>ShardingSphereConnection</code>的实现对于<code>autoCommit</code>值的处理有其特殊性，最终导致事务失效</p></li></ul><p>当然，除了替换<code>Transaction</code>的实现，也可以通过下面这种方式，直接使用connection来手动控制（并不推荐）：</p><p><img src="/img/image-20240113111515177.png" /></p><p><img src="/img/image-20240113130222094.png" /></p><h1 id="要点">要点</h1><h2 id="spring事务传播">Spring事务传播</h2><p>老生常谈，复习下Spring的几种事务传播机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Propagation</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Support a current transaction, create a new one if none exists.</span><br><span class="hljs-comment"> * Analogous to EJB transaction attribute of the same name.</span><br><span class="hljs-comment"> * &lt;p&gt;This is the default setting of a transaction annotation.</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 如果上下文存在事务，则加入当前事务。如果不存在，则创建一个新事务并执行</span><br>REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Support a current transaction, execute non-transactionally if none exists.</span><br><span class="hljs-comment"> * Analogous to EJB transaction attribute of the same name.</span><br><span class="hljs-comment"> * &lt;p&gt;Note: For transaction managers with transaction synchronization,</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> SUPPORTS&#125; is slightly different from no transaction at all,</span><br><span class="hljs-comment"> * as it defines a transaction scope that synchronization will apply for.</span><br><span class="hljs-comment"> * As a consequence, the same resources (JDBC Connection, Hibernate Session, etc)</span><br><span class="hljs-comment"> * will be shared for the entire specified scope. Note that this depends on</span><br><span class="hljs-comment"> * the actual synchronization configuration of the transaction manager.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.support.AbstractPlatformTransactionManager#setTransactionSynchronization</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 如果上下文存在事务，则加入当前事务。如果不存在，则以非事务的方式执行</span><br>SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Support a current transaction, throw an exception if none exists.</span><br><span class="hljs-comment"> * Analogous to EJB transaction attribute of the same name.</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 如果上下文存在事务，则加入当前事务。如果不存在，则抛出异常</span><br>MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Create a new transaction, and suspend the current transaction if one exists.</span><br><span class="hljs-comment"> * Analogous to the EJB transaction attribute of the same name.</span><br><span class="hljs-comment"> * &lt;p&gt;&lt;b&gt;<span class="hljs-doctag">NOTE:</span>&lt;/b&gt; Actual transaction suspension will not work out-of-the-box</span><br><span class="hljs-comment"> * on all transaction managers. This in particular applies to</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> org.springframework.transaction.jta.JtaTransactionManager&#125;,</span><br><span class="hljs-comment"> * which requires the &#123;<span class="hljs-doctag">@code</span> jakarta.transaction.TransactionManager&#125; to be</span><br><span class="hljs-comment"> * made available to it (which is server-specific in standard Jakarta EE).</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 总是创建一个新事务（完全与上下文隔离的事务），不管上下文是否已存在事务。如果上下文已存在事务，则挂起它，等待新事务执行完毕再恢复执行</span><br>REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Execute non-transactionally, suspend the current transaction if one exists.</span><br><span class="hljs-comment"> * Analogous to EJB transaction attribute of the same name.</span><br><span class="hljs-comment"> * &lt;p&gt;&lt;b&gt;<span class="hljs-doctag">NOTE:</span>&lt;/b&gt; Actual transaction suspension will not work out-of-the-box</span><br><span class="hljs-comment"> * on all transaction managers. This in particular applies to</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> org.springframework.transaction.jta.JtaTransactionManager&#125;,</span><br><span class="hljs-comment"> * which requires the &#123;<span class="hljs-doctag">@code</span> jakarta.transaction.TransactionManager&#125; to be</span><br><span class="hljs-comment"> * made available to it (which is server-specific in standard Jakarta EE).</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 总是以非事务方式执行。如果上下文已存在事务，则挂起它</span><br>NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Execute non-transactionally, throw an exception if a transaction exists.</span><br><span class="hljs-comment"> * Analogous to EJB transaction attribute of the same name.</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">//总是以非事务方式执行。如果上下文已存在事务，则抛出异常</span><br>NEVER(TransactionDefinition.PROPAGATION_NEVER),<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Execute within a nested transaction if a current transaction exists,</span><br><span class="hljs-comment"> * behave like &#123;<span class="hljs-doctag">@code</span> REQUIRED&#125; otherwise. There is no analogous feature in EJB.</span><br><span class="hljs-comment"> * &lt;p&gt;Note: Actual creation of a nested transaction will only work on specific</span><br><span class="hljs-comment"> * transaction managers. Out of the box, this only applies to the JDBC</span><br><span class="hljs-comment"> * DataSourceTransactionManager. Some JTA providers might support nested</span><br><span class="hljs-comment"> * transactions as well.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.jdbc.datasource.DataSourceTransactionManager</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 如果上下文存在事务，则以嵌套子事务的方式执行。否则就同PROPAGATION_REQUIRED</span><br>NESTED(TransactionDefinition.PROPAGATION_NESTED);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>关于最后一个<code>NESTED</code>的解释，可以看看官方文档<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[tx-propagation-nested](https://docs.spring.io/spring-framework/reference/data-access/transaction/declarative/tx-propagation.html#tx-propagation-nested)">[4]</span></a></sup>的说明：</p><blockquote><p><code>PROPAGATION_NESTED</code> uses a single physical transactionwith multiple savepoints that it can roll back to. Such partialrollbacks let an inner transaction scope trigger a rollback for itsscope, with the outer transaction being able to continue the physicaltransaction despite some operations having been rolled back. Thissetting is typically mapped onto JDBC savepoints, so it works only withJDBC resource transactions. See Spring’s <ahref="https://docs.spring.io/spring-framework/docs/6.1.2/javadoc-api/org/springframework/jdbc/datasource/DataSourceTransactionManager.html"><code>DataSourceTransactionManager</code></a>.</p></blockquote><p>区别于<code>PROPAGATION_REQUIRES_NEW</code> -创建和上下文事务完全隔离的新事务，<code>NESTED</code>是创建一个所谓的”嵌套“事务，它是上下文事务的一部分，只有上下文事务提交后才会提交。回滚依赖设置的savepoints，回滚后不会影响到上下文事务的继续执行。只能作用于JDBC资源事务。</p><h2id="数据库事务隔离5">数据库事务隔离<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[事务隔离](https://zh.wikipedia.org/wiki/%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2)">[5]</span></a></sup></h2><blockquote><p><strong>事务隔离</strong>（英语：Transaction Isolation）定义了<ahref="https://zh.wikipedia.org/wiki/数据库">数据库</a>系统中一个事务中操作的结果在何时以何种方式对其他<ahref="https://zh.wikipedia.org/wiki/并发">并发</a>事务操作可见。隔离是事务<ahref="https://zh.wikipedia.org/wiki/ACID">ACID</a>（原子性、一致性、隔离性、持久性）四大属性之一。</p></blockquote><p><code>java.sql.Connection</code>类中有对应的常量定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Connection</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Wrapper</span>, AutoCloseable &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * A constant indicating that transactions are not supported.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 不支持事务</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">TRANSACTION_NONE</span>             <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * A constant indicating that</span><br><span class="hljs-comment">     * dirty reads, non-repeatable reads and phantom reads can occur.</span><br><span class="hljs-comment">     * This level allows a row changed by one transaction to be read</span><br><span class="hljs-comment">     * by another transaction before any changes in that row have been</span><br><span class="hljs-comment">     * committed (a &quot;dirty read&quot;).  If any of the changes are rolled back,</span><br><span class="hljs-comment">     * the second transaction will have retrieved an invalid row.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 读未提交：脏读，不可重复读和幻读都可能发生</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">TRANSACTION_READ_UNCOMMITTED</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * A constant indicating that</span><br><span class="hljs-comment">     * dirty reads are prevented; non-repeatable reads and phantom</span><br><span class="hljs-comment">     * reads can occur.  This level only prohibits a transaction</span><br><span class="hljs-comment">     * from reading a row with uncommitted changes in it.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 读已提交：可以避免脏读，但是不可重复读和幻读仍可能发生</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">TRANSACTION_READ_COMMITTED</span>   <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * A constant indicating that</span><br><span class="hljs-comment">     * dirty reads and non-repeatable reads are prevented; phantom</span><br><span class="hljs-comment">     * reads can occur.  This level prohibits a transaction from</span><br><span class="hljs-comment">     * reading a row with uncommitted changes in it, and it also</span><br><span class="hljs-comment">     * prohibits the situation where one transaction reads a row,</span><br><span class="hljs-comment">     * a second transaction alters the row, and the first transaction</span><br><span class="hljs-comment">     * rereads the row, getting different values the second time</span><br><span class="hljs-comment">     * (a &quot;non-repeatable read&quot;).</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 可重复读：可以避免脏读和不可重复读，但是幻读可能发生</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">TRANSACTION_REPEATABLE_READ</span>  <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * A constant indicating that</span><br><span class="hljs-comment">     * dirty reads, non-repeatable reads and phantom reads are prevented.</span><br><span class="hljs-comment">     * This level includes the prohibitions in</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> TRANSACTION_REPEATABLE_READ&#125; and further prohibits the</span><br><span class="hljs-comment">     * situation where one transaction reads all rows that satisfy</span><br><span class="hljs-comment">     * a &#123;<span class="hljs-doctag">@code</span> WHERE&#125; condition, a second transaction inserts a row that</span><br><span class="hljs-comment">     * satisfies that &#123;<span class="hljs-doctag">@code</span> WHERE&#125; condition, and the first transaction</span><br><span class="hljs-comment">     * rereads for the same condition, retrieving the additional</span><br><span class="hljs-comment">     * &quot;phantom&quot; row in the second read.</span><br><span class="hljs-comment">     */</span><br>   <span class="hljs-comment">// 串行：脏读、不可重复读和幻读均可避免。但性能较低</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">TRANSACTION_SERIALIZABLE</span>     <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分布式事务">分布式事务</h2><p>理论上的东西不多谈，主要整理下用过的两种分布式事务方案：</p><ul><li>基于可靠消息的最终一致性</li><li>类TCC机制 + 补偿任务</li></ul><h4 id="基于可靠消息的最终一致性">基于可靠消息的最终一致性</h4><p>主要是基于RocketMQ提供的事务消息，可以参见这篇文章：<ahref="https://luckycaesar.github.io/article/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5%E5%B0%8F%E8%AE%B0/">性能优化实践小记</a>。</p><h4 id="类tcc机制-补偿任务">类TCC机制 + 补偿任务</h4><p>配置多数据源的服务，可以类似下面的处理逻辑：</p><ol type="1"><li>A库开启事务1，执行一条插入，但其状态为初始状态（待生效/草稿/处理中）。B库开启事务2执行其逻辑，亦插入一条数据，最终状态（有效/已提交/处理完成）。正常情况下的业务异常，直接抛出并回滚所有的事务。</li><li>提交事务：<ul><li>提交事务1，如果事务1提交失败则同时回滚事务2，AB库均不会新增数据。</li><li>事务1提交成功，再提交事务2。事务2提交成功后，再开启事务3，更新A库数据状态为最终状态。事务3提交成功，则整个事务才算成功。</li><li>事务2提交失败，则抛出异常后回滚（事务1不受影响）。此时需引入补偿任务，扫描A库中初始状态的数据，查B库数据是否已存在。如果不存在，则重试执行事务2。成功后，更新A库的数据为最终状态。如果已存在，则直接更新A库数据即可。重试超过一定失败次数后需引入人工处理。</li></ul></li><li>回滚：目前不存在自动回滚，一直补偿直至成功或者人工介入。</li></ol><p>对非多数据源的服务，需要通过RPC调用而出现的分布式事务问题，类似的处理，但会多一个回滚。</p><ol type="1"><li>A服务开启事务1，写入数据，调RPC接口触发B服务的事务2，写入数据，但状态为初始状态。</li><li>RPC调用成功后，事务1提交。RPC调用失败或者提交失败，回滚事务1。（此时可能出现RPC超时返回失败，但B服务已处理成功的情况，需要补偿任务）</li><li>事务1提交成功后，再次调用RPC接口，更新B服务的数据为最终状态。</li><li>补偿任务，扫描B服务中初始状态的数据，反查A服务，如果存在，则更新为最终状态。如果不存在，则回滚，删除初始状态的数据。</li></ol><p>上述情况均需保证数据的幂等，已处于初始状态或者最终状态则认为已经提交成功，直接返回。</p><section class="footnotes"><hr><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><ahref="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1">数据库事务</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><ahref="https://docs.spring.io/spring-framework/reference/data-access/transaction/declarative/annotations.html#page-title">Using<code><span class="citation"data-cites="Transactional">@Transactional</span></code></a><a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><ahref="https://www.postgresql.org/docs/current/sql-abort.html">sql-abort</a><a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><ahref="https://docs.spring.io/spring-framework/reference/data-access/transaction/declarative/tx-propagation.html#tx-propagation-nested">tx-propagation-nested</a><a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><ahref="https://zh.wikipedia.org/wiki/%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2">事务隔离</a><a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>事务</tag>
      
      <tag>Spring</tag>
      
      <tag>MyBatis</tag>
      
      <tag>ShardingJdbc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>走进Java中的Loom和虚拟线程</title>
    <link href="/article/%E8%B5%B0%E8%BF%9BJava%E4%B8%AD%E7%9A%84Loom%E5%92%8C%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B/"/>
    <url>/article/%E8%B5%B0%E8%BF%9BJava%E4%B8%AD%E7%9A%84Loom%E5%92%8C%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<ahref="https://blogs.oracle.com/javamagazine/post/going-inside-javas-project-loom-and-virtual-threads">Goinginside Java’s Project Loom and virtual threads</a></p></blockquote><h2id="来看虚拟线程如何将java带回到绿色线程1的时代即java线程不再等同于操作系统线程">来看虚拟线程如何将Java带回到绿色线程<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="绿色线程（Green Thread）：[Green vs Native Threads and Deprecated Methods in Java](https://www.geeksforgeeks.org/green-vs-native-threads-and-deprecated-methods-in-java/)">[1]</span></a></sup>的时代，即Java线程不再等同于操作系统线程</h2><p>先来谈谈<ahref="https://wiki.openjdk.java.net/display/loom/Main">Loom项目</a>（以下简称Loom），它目前正在探索Java语言的新特性、新API，以及更轻量的运行时并发- 包含了对虚拟线程的新构思。</p><p>Java是第一个把线程融入到核心语言<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="核心语言是编程语言本身和相关标准库的总称">[2]</span></a></sup>的主流编程平台。在线程出现之前，要在它们之间进行通信，最先进的技术就是使用多进程或者各种不太优雅的机制（UNIX共享内存，或其它某些机制？）。</p><p>在操作系统层面，线程是属于某个进程的独立调度执行单元。每个线程都有它自己的指令执行计数器和调用栈，但是会和同一个进程中的其它线程共享一个堆。</p><p>不仅如此，Java堆也是进程堆中一块单独且连续的子集，至少在HotSpotJVM中如此（其它JVM的实现可能有差别）。所以操作系统层面的线程内存模型自然而然的延续到了Java语言的领域。</p><p>线程的概念会自然地引出一个轻量级上下文切换的概念：在同一个进程的不同线程之间切换的开销要比在不同进程之间切换线程的开销更小。这主要是因为对于同一个进程下的所有线程来说，把虚拟内存地址转换到物理内存地址的映射表大部分都是相同的。</p><p>顺带一提，创建一个线程的开销也比创建一个进程来得小。当然，实际情况是否如此确定仍取决于操作系统的实现细节。</p><p><em>Java语言规范</em><sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="参见Java SE 21的语言规范文档：[https://docs.oracle.com/javase/specs/jls/se21/html/index.html](https://docs.oracle.com/javase/specs/jls/se21/html/index.html)">[3]</span></a></sup>并未在操作系统线程和Java线程之间强制指定任何特殊的映射，这是假定主机操作系统恰好有类似线程的概念- 而实际上并不总是如此。</p><p>实际上，在Java很早期的一些版本当中，JVM线程被<ahref="https://zh.wikipedia.org/wiki/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">多路复用</a>到了操作系统的线程（也被称为<em>平台线程</em>）上，即所谓的<em>绿色线程</em>，因为那些最早的JVM实现实际上仅利用到了一个平台线程。</p><p>然而，这种单平台线程的实践大约在Java1.2和1.3时代便逐渐消失（且在Sun公司的SolarisOS上要消失得更早一点）。而目前运行在主流操作系统上的现代Java版本，则遵循着一个Java线程等同于一个操作系统线程的准则。</p><p>这就意味着使用<code>Thread.start()</code>方法会调起系统的线程创建动作（就像Linux上的<code>clone()</code>方法）并创建一个真正的新的操作系统线程。</p><p>OpenJDK的Loom旨在 -亦是其最主要的目标，重新审视这种由来已久的实现方式，并替换为新的运行时<em>不直接</em>绑定专门的操作系统线程的<code>Thread</code>对象。</p><p>换句话讲，Loom创建了一种执行模型，其代表着<ahref="https://en.wikipedia.org/wiki/Execution_(computing)#Context_of_execution">执行上下文</a>的对象不再必须依赖操作系统的调度。故而从某些角度来看，Loom<em>其实是</em>重回类似于绿色线程的时代。</p><p>但时过境迁，而且计算机技术方面的很多构思往往是超前的。</p><p>举个例子，你可以把EJBs（即Jakarta EnterpriseBeans，以前也称作EnterpriseJavaBeans）当作是一种雄心勃勃试图将环境虚拟化的受限环境形式。那它是否可被视为日后在现代PaaS系统或更小范围的Docker和Kubernetes中广受青睐的环境形式的原型呢？</p><p>所以，如果Loom（部分地）重拾绿色线程的理念，那么实现它的一种方式可能就是解决这样一个问题：环境到底发生了何种变化使得回归以往被证明未见成效的旧思路变得极具吸引力？</p><p>要稍微地探讨下这个问题，我们得先看一个例子。具体一点，我们需要创建大量的线程来使JVM崩溃：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Please do not actually run this code... it may crash your VM or laptop</span><br><span class="hljs-comment">//</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CrashTheVM</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">looper</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">tid</span> <span class="hljs-operator">=</span> Thread.currentThread().getId();<br>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">500</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">10</span>);<br>            <span class="hljs-keyword">if</span> (count % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Thread id: &quot;</span>+ tid +<span class="hljs-string">&quot; : &quot;</span>+ count);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        looper(count + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Thread <span class="hljs-title function_">makeThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">threads</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Thread&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20_000</span>; i = i + <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">var</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> makeThread(() -&gt; looper(<span class="hljs-number">1</span>));<br>            t.start();<br>            threads.add(t);<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">1_000</span> == <span class="hljs-number">0</span>) &#123;<br>                System.out.println(i + <span class="hljs-string">&quot; thread started&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// Join all the threads</span><br>        threads.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码会启动20,000个线程且每个线程尽可能做到最小的处理占用。实际上去运行它的话，应用很可能在远未达到稳定状态时就停止运行或者卡死。当然也有这种可能，由于机器或操作系统受到了限制，无法快速创建线程耗尽资源，使得它能够正常运行完成。</p><p><strong>图1</strong>展示了我使用2019 MacBookPro运行这段代码时，在电脑彻底失去响应之前的情形。这上面的一些计数不是很准确，比如线程数量，因为操作系统此时已处于崩溃边缘。</p><figure><img src="/img/java-loom-virt-figure1.jpg"alt="java-loom-virt-figure1" /><figcaption aria-hidden="true">java-loom-virt-figure1</figcaption></figure><p><strong>图1.</strong> 展示了大量线程的创建：千万不要在家中尝试</p><p>很明显这不能完全代表实际生产环境中的Java应用，它展示了比如在每个连接都对应一个线程的Web服务的环境中可能会出现的一种情况。现代化的高性能Web服务能处理成千上万（或者更多）的并发连接的确已经很优秀了，但这个示例也直白的展现了这种单线程-单连接架构在这种情况下可能出现的失败。</p><p>一句话讲：现代程序需要关注比创建线程多得多的可执行上下文。</p><p>另一个关键点就是线程的开销可能远比大部分人想象的更加昂贵，并且成为了现代JVM应用的扩展瓶颈。多年来，开发者致力于解决这个问题，要么通过控制线程的开销，要么使用非线程式的执行上下文表达。</p><p>曾有过分段式<ahref="https://en.wikipedia.org/wiki/Staged_event-driven_architecture">事件驱动架构（SEDA）</a>的解决方案，最早出现在大概15年前。SEDA可以被描述为这样一个系统，通过多级管道把域对象从A移动到Z，期间伴随着各种各样的转换动作。在分布式系统中，可以通过消息系统或者在每个阶段使用阻塞队列以及线程池来实现SEDA。</p><p>在SEDA的每个步骤中，对域对象的处理可以用包含实现了转换逻辑代码的Java对象来描述。要保障其正常工作，代码必须确保是可终止的，不能出现无限循环。但是框架层面无法强制施加这些约束。</p><p>SEDA的方案也有一些显著的缺点，尤其对开发者的纪律性要求（很高）。接下来我们来看看一个更好的选择，即Loom。</p><h2 id="loom项目介绍">Loom项目介绍</h2><p><a href="https://wiki.openjdk.java.net/display/loom/Main">ProjectLoom</a>是OpenJDK的一个项目，旨在实现”Java平台上易用的，高吞吐量的轻量级并发和新的编程模型“，并为此添加了一些新概念：</p><ul><li>虚拟线程</li><li><ahref="https://en.wikipedia.org/wiki/Delimited_continuation">定界延续</a></li><li><ahref="https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8">尾调用消除</a></li></ul><p>这里面最关键的就是<em>虚拟线程</em>，它设计得跟普通的，编程人员所熟悉的线程类似。但是，虚拟线程由Java运行时所管理，且<em>不再是</em>操作系统线程之上的简单的，一对一的包装器。相反，它是由Java运行时在用户空间内实现的。（本文不会讨论定界延续和尾调用消除，但<ahref="https://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html">这里有相关内容</a>）</p><p>虚拟线程能带来的好处包括：</p><ul><li>创建和阻塞的成本更低</li><li>可以使用Java执行调度器（线程池）</li><li>栈中不再存在操作系统层面的数据结构</li></ul><p>移除虚拟线程生命周期中操作系统的参与就能消除扩展性的瓶颈。大型JVM应用需要处理百万级甚至上十亿级的对象，所以它们为何只能被限制在操作系统中区区数千个可调度对象上呢（这也是思考何为线程的一种方式）？</p><p>打破这种限制并解锁新的并发编程方式就是Loom的主要目标。</p><p>接下来我们将在实践中观察虚拟线程。下载<ahref="https://jdk.java.net/loom/">Project Loom betabuild</a>并启动<code>jshell</code>，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">jshell</span> <br>|  Welcome to JShell -- Version 16-loom<br>|  For an introduction type: /help intro<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">jshell&gt; </span><span class="language-bash">Thread.startVirtualThread(() -&gt; &#123;</span><br>   ...&gt;     System.out.println(&quot;Hello World&quot;);<br>   ...&gt; &#125;);<br>Hello World<br><span class="hljs-meta prompt_">$</span><span class="language-bash">1 ==&gt; VirtualThread[&lt;unnamed&gt;,&lt;no carrier thread&gt;]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">jshell&gt;</span><br></code></pre></td></tr></table></figure><p>从输出可以很直观的看到虚拟线程的构造。这段代码也用到了一个最新的static方法<code>startVirtualThread()</code>，它在新的执行上下文- 即虚拟线程中，执行了一段lambda表达式。简单明了！</p><p>虚拟线程的引入必须遵循这样的原则：已有的代码库必须<em>完全地</em>按照虚拟线程出现之前的方式继续运行。这一原则决不能违背，而且我们必须作出这样一个保守的假设，所有已有的Java代码都确实需要一个常设的“基于操作系统的轻量级包装器”的线程架构，这也是到目前为止的唯一方案。</p><p>那么，虚拟线程有什么优点呢？它通过一些其他的方式打开了新的视野。目前，Java语言主要提供了两种方式来创建新线程：</p><ul><li>实现<code>java.lang.Thread</code>类并调用继承的<code>start()</code>方法</li><li>创建<code>Runnable</code>接口的实例并将它作为参数传递给<code>Thread</code>类的构造器，然后启动生成的对象</li></ul><p>由于线程的概念正在变化，那么重新审视创建线程的方式自然也很有必要。刚刚我们使用了一个新的静态工厂方法来创建即用即弃的虚拟线程，但是对于已存在的线程API也需要通过另一些方式进行改进。</p><h2 id="线程构建器">线程构建器</h2><p>一个新的很重要的概念就是<code>Thread.Builder</code>类，它作为<code>Thread</code>类的一个内部类被添加进来。用以下代码替换上面例子（第一个示例）中的<code>makeThread()</code>方法看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Thread <span class="hljs-title function_">makeThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>    <span class="hljs-keyword">return</span> Thread.builder().virtual().task(r).build();<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码会调用builder中的<code>virtual()</code>方法来显式的创建一个能够执行<code>Runnable</code>的虚拟线程。当然，我们也可以去掉对<code>virtual()</code>的调用，这样会转而创建一个传统的，由操作系统调度的线程对象。但意义何在？</p><p>如果你把<code>makeThread()</code>方法替换成虚拟线程的版本并用支持Loom的Java重新编译一遍（第一个示例的代码），然后执行生成的二进制文件。</p><p>此时，程序会顺利运行，整体的负载情况如<strong>图2</strong>。</p><figure><img src="/img/java-loom-virt-figure2.jpg"alt="java-loom-virt-figure2" /><figcaption aria-hidden="true">java-loom-virt-figure2</figcaption></figure><p><strong>图2.</strong> 创建大量的虚拟线程来替代传统的Java线程</p><p>这仅仅是Loom设计理念的一个实例，唯一需要在你自己的Java应用中改动的就是创建线程处的代码。</p><p>新的线程库鼓励开发者们摆脱旧范式所使用的一种方式就是<code>Thread</code>类的子类不能是虚拟的。所以，这些子类代码仍旧会使用传统的操作系统线程来创建线程。这么做的目的是保护遗留的使用了这些子类的代码并遵循<ahref="https://en.wikipedia.org/wiki/Principle_of_least_astonishment">最小意外原则</a>。</p><p>时至今日，虚拟线程变得越来越寻常，开发者们也不再那么关注操作系统线程和虚拟线程之间的差异，这会反过来阻止这种子类机制的继续使用，因为它总会创建一个由操作系统调度的线程。</p><p>要注意的是线程库的其他部分也需要升级以更好的支撑Loom。例如，<code>ThreadBuilder</code>也支持构建可以作为参数被传递到<code>Executors</code>的<code>ThreadFactory</code>实例，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">jshell&gt; </span><span class="language-bash">var tb = Thread.builder();</span><br>tb ==&gt; java.lang.Thread$BuilderImpl@2e0fa5d3<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">jshell&gt; </span><span class="language-bash">var tf = tb.factory();</span><br>tf ==&gt; java.lang.Thread$KernelThreadFactory@2e5d6d97<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">jshell&gt; </span><span class="language-bash">var vtf = tb.virtual().factory();</span><br>vtf ==&gt; java.lang.Thread$VirtualThreadFactory@377dca04<br></code></pre></td></tr></table></figure><p>当然，在某个阶段，虚拟线程必须依赖一个真正的操作系统线程来执行。这些能让虚拟线程运行在其上的操作系统线程叫做<em>载体线程</em>。纵观整个生命周期，一个虚拟线程可能会运行在多个不同的载体线程之上。这不由得让人想起了普通线程会随着时间的推移运行在不同物理CPU核心上的情况- 二者都是执行调度的示范。</p><p>在之前的一个例子的<code>jshell</code>输出中我们已经见过载体线程了。</p><h2 id="使用虚拟线程编程">使用虚拟线程编程</h2><p>虚拟线程的出现也带来了思维方式上的转变。编写了现如今的并发应用的编程人员已经习惯于（有意识或无意识地）处理伴随着传统线程而来的天生的扩展限制。</p><p>Java开发者习惯使用<code>Runnable</code>或者<code>Callable</code>接口来创建任务对象，并把他们交付给执行器-其背后是用于节约珍贵的线程资源的线程池。但假如所有的这一切都突然变了呢？</p><p>Loom试图通过引入比现有思路更划算的全新设计理念来解决线程的扩展性限制，且不再直接映射操作系统线程。这个新特性会看起来并且表现得同如今编程人员所熟知的线程类似。</p><p>这就意味着不用去学习一种全新的编程风格（比如<ahref="https://en.wikipedia.org/wiki/Continuation-passing_style">延续传递风格</a>或者<ahref="https://en.wikipedia.org/wiki/Futures_and_promises">promise/futureapproach</a>或者回调），而是需要Loom运行时在从线程过渡到虚拟线程时继续使用统一的编程模型。换句话说，虚拟线程即简单的线程，至少对编程人员而言。</p><p>虚拟线程是<em>抢占式的</em>，因为用户端代码无需显式的放弃对CPU的控制。调度点则由虚拟调度器和JDK来控制。开发者亦无需对何时会发生yields作出任何的假设，因为这纯粹是底层的实现细节了。</p><p>当然，为了理解虚拟线程的差异，也理应去了解一下操作系统调度的底层设计原理。</p><p>当操作系统调度平台线程时，会给每个线程分配CPU时间中的<em>时间切片</em>。当时间切片耗尽，会产生硬件中断且内核会重新获得（CPU）的控制权，它会移除正在执行的平台（用户）线程，并替换为另外一个线程。</p><p>这种机制保证了UNIX（或者其他各色操作系统）能够让不同任务共享处理器的时间，哪怕在几十年前计算机只有单核的时代亦如此。</p><p>虚拟线程，当然与平台线程的处理方式有所不同。现有的调度器都不会使用时间切片的方式来抢占虚拟线程。</p><p>用时间切片的方式实现虚拟线程的抢占也是可以的，JVM也有这样的能力来控制执行中的Java线程。比如，利用JVM中的<em>safepoint</em>。</p><p>相反，在阻塞调用（譬如I/O）产生时，虚拟线程会自动放弃（或者<em>让出（yield）</em>）它们的载体线程。这是由库和运行时来处理的，并不会受到编程人员的显式控制。</p><p>因此，Loom允许Java开发者使用传统的线程顺序性风格来编写代码，并不会强制他们去显式的管理yielding，或者依赖复杂的非阻塞式或基于回调的操作。这样做有一些额外的好处，像调试器和分析器就能够照常运行。</p><p>框架开发者和运行时开发工程师可能需要做一些额外的工作以支持虚拟线程，但也比强行给日常的普通开发者们施加额外的认知负担要好得多。</p><p>Loom的设计者期望如此，因为虚拟线程永远不需要被池化，也永远<em>不应该</em>被池化。相反，这种模型不会限制虚拟线程的创建。为了达到这一目的，新增了一个<em>unboundedexecutor</em>。它可以通过新的工厂方法<code>Executors.newVirtualThreadExecutor()</code>来访问。</p><p>虚拟线程默认的调度器是自<code>ForkJoinPool</code>引入的工作窃取调度器。（有意思一点是<ahref="https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html">work-stealingaspect of fork/join</a>是如何变得远比递归分解任务更重要的）</p><p>Loom的设计是以开发者们能理解其应用中不同线程带来的计算开销为基础的。</p><p>简单讲，如果有许多线程都需要持续的占用大量的CPU时间，那么应用就会处于资源紧张状态，即使再巧妙的调度策略也无用。而另一边，如果只有少量线程预计会是CPU密集型，那么就应该把它们放到独立的池且由平台线程来管理。</p><p>虚拟线程能在偶现大量的CPU密集型线程时仍运转良好。这让工作窃取调度器能平滑CPU的利用率，且代码最终会调用一个通过yieldpoint<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="yield point，类似于safe point：[https://zhuanlan.zhihu.com/p/114540016](https://zhuanlan.zhihu.com/p/114540016)">[4]</span></a></sup>的操作（比如阻塞I/O）。</p><h2 id="一则警示寓言">一则警示“寓言”</h2><p>接下来展示一个例子，当自定义调度虚拟线程时，Loom的设计也会出现一些难以预料的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TangledLoom</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">scheduler</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() +<span class="hljs-string">&quot; starting &quot;</span>);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                    total = total + hashing(i, <span class="hljs-string">&#x27;X&#x27;</span>);<br>                &#125;<br>                System.out.println(Thread.currentThread().getName() +<span class="hljs-string">&quot; : &quot;</span>+ total);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">tA</span> <span class="hljs-operator">=</span> Thread.builder().virtual(scheduler).name(<span class="hljs-string">&quot;A&quot;</span>).task(r).build();<br>        <span class="hljs-type">var</span> <span class="hljs-variable">tB</span> <span class="hljs-operator">=</span> Thread.builder().virtual(scheduler).name(<span class="hljs-string">&quot;B&quot;</span>).task(r).build();<br>        <span class="hljs-type">var</span> <span class="hljs-variable">tC</span> <span class="hljs-operator">=</span> Thread.builder().virtual(scheduler).name(<span class="hljs-string">&quot;C&quot;</span>).task(r).build();<br>        tA.start();<br>        tB.start();<br>        tC.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            tA.join();<br>            tB.join();<br>            tC.join();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable tx) &#123;<br>            tx.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashing</span><span class="hljs-params">(<span class="hljs-type">int</span> length, <span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; length * <span class="hljs-number">1_000_000</span>; j++) &#123;<br>            sb.append(c);<br>        &#125;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> sb.toString();<br>        <span class="hljs-keyword">return</span> s.hashCode();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行这段代码，会得到以下输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">$ java TangledLoom<br>B starting <br>A starting <br>B : -<span class="hljs-number">1830232064</span><br>C starting <br>C : -<span class="hljs-number">1830232064</span><br>B : -<span class="hljs-number">1830232064</span><br>C : -<span class="hljs-number">1830232064</span><br>B : -<span class="hljs-number">1830232064</span><br>C : -<span class="hljs-number">1830232064</span><br>B : -<span class="hljs-number">1830232064</span><br>C : -<span class="hljs-number">1830232064</span><br></code></pre></td></tr></table></figure><p>此即所谓的<em>线程饥饿</em>，线程<code>A</code>看上去永远无法执行。</p><p>久而久之，当Loom被越来越多的Java开发者们所熟悉时，肯定会出现一系列通用的最佳实践的范式。但目前为止，大家都还处于探索新技术的早期阶段，须注意上述问题。</p><h2id="loom何时发布5">Loom何时发布？<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="2023年9月19日，[Java21](https://openjdk.org/projects/jdk/21/)正式发布，带来了[Virtual Threads](https://openjdk.org/jeps/444)的特性">[5]</span></a></sup></h2><p>（略）。</p><h2 id="延伸阅读">延伸阅读</h2><ul><li><a href="https://wiki.openjdk.java.net/display/loom/Main">ProjectLoom homepage</a></li><li><ahref="https://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html">ProjectLoom: Fibers and continuations for the Java Virtual Machine</a></li><li><ahref="https://www.oracle.com/java/technologies/javase/early-access-downloads.html">Earlyaccess snapshot</a></li><li><ahref="https://blogs.oracle.com/javamagazine/the-role-of-previews-in-java-14-java-15-java-16-and-beyond">Therole of preview features in Java 14, Java 15, Java 16, andbeyond</a></li><li><a href="https://www.youtube.com/watch?v=fOEPEXTpbJA">Webcast:Project Loom: Modern Scalable Concurrency for the Java Platform</a></li><li><a href="https://github.com/openjdk/loom">Project Loom onGitHub</a></li></ul><section class="footnotes"><hr><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>绿色线程（Green Thread）：<ahref="https://www.geeksforgeeks.org/green-vs-native-threads-and-deprecated-methods-in-java/">Greenvs Native Threads and Deprecated Methods in Java</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>核心语言是编程语言本身和相关标准库的总称<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>参见Java SE21的语言规范文档：<ahref="https://docs.oracle.com/javase/specs/jls/se21/html/index.html">https://docs.oracle.com/javase/specs/jls/se21/html/index.html</a><a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>yield point，类似于safepoint：<ahref="https://zhuanlan.zhihu.com/p/114540016">https://zhuanlan.zhihu.com/p/114540016</a><a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>2023年9月19日，<ahref="https://openjdk.org/projects/jdk/21/">Java21</a>正式发布，带来了<ahref="https://openjdk.org/jeps/444">Virtual Threads</a>的特性<a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>协程</tag>
      
      <tag>虚拟线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从Spring事件的发布顺序说起</title>
    <link href="/article/%E4%BB%8ESpring%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8F%91%E5%B8%83%E9%A1%BA%E5%BA%8F%E8%AF%B4%E8%B5%B7/"/>
    <url>/article/%E4%BB%8ESpring%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8F%91%E5%B8%83%E9%A1%BA%E5%BA%8F%E8%AF%B4%E8%B5%B7/</url>
    
    <content type="html"><![CDATA[<p>最近在解决一个有趣的<ahref="https://github.com/Tencent/spring-cloud-tencent/issues/954">issue</a>时，利用到了Spring中生命周期事件的发布顺序。主要就是根据不同事件的发布顺序不同，在SpringBoot应用启动的某些阶段触发框架的动态优化逻辑，替换一些bean，并且替换后的bean也能正常监听后续阶段发布的事件并执行替换后的逻辑。</p><p>说起这些启动时的生命周期事件，我们都耳熟能详。在研究Spring刷新或者SpringBoot启动流程的源码时都能看到它们的身影，或者也监听过某些事件来实现一些业务逻辑。但是，对于整个的生命周期事件的分类、顺序等的逻辑我其实是一直比较模糊的，需要用到时才会去研究一番。故而，想借此机会来简单梳理一下这些事件，也加深对其背后所代表的应用启动流程原理的了解和理解。</p><h2 id="有哪些事件">有哪些事件</h2><p>先来看看Spring（6.0.11）和SpringBoot（3.1.0）中到底有哪些生命周期相关的事件，这里是参照的较新的版本的文档和源码：</p><figure><img src="/img/SpringEvent.jpg" alt="事件" /><figcaption aria-hidden="true">事件</figcaption></figure><ul><li>EventObject：顶层父类为<code>java.util.EventObject</code>，是基于Java的事件机制。</li><li>ApplicationEvent：Spring的顶层抽象类，所有扩展的应用事件类都必须继承它。</li></ul><p>接下来就是Spring和SpringBoot的不同实现，从事件名称也可以看出它们的侧重点不一样，也反应了二者（Spring和SpringBoot）的区别：Spring的核心是应用上下文（<em>ApplicationContextEvent</em>），而SpringBoot的侧重点则是应用本身（<em>SpringApplicationEvent</em>）。</p><p>先贴一下官方说明文档，再简单做一下说明：</p><ul><li>Spring的事件介绍文档：<ahref="https://docs.spring.io/spring-framework/reference/core/beans/context-introduction.html#context-functionality-events">context-introduction</a></li><li>SpringBoot的事件介绍文档：<ahref="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.spring-application.application-events-and-listeners">application-events-and-listeners</a></li></ul><h3 id="springcontextrefreshedevent">Spring#ContextRefreshedEvent</h3><blockquote><p>Published when the <code>ApplicationContext</code> is initialized orrefreshed.</p></blockquote><p>Spring上下文初始化完毕或者刷新完毕，即Environment、BeanFactory、PostProcessor、MessageSource、Listener、Singletons等等都准备完毕之后，会发布此事件。</p><p><em>它也是绝大部分应用走Spring自动加载刷新流程时所关注的核心事件，后面的几个事件都不同于它。</em></p><h3 id="springcontextstartedevent">Spring#ContextStartedEvent</h3><blockquote><p>Published when the <code>ApplicationContext</code> is started byusing the <code>start()</code> method on the<code>ConfigurableApplicationContext</code> interface. Here, “started”means that all <code>Lifecycle</code> beans receive an explicit startsignal.</p></blockquote><p>文档中明确说明，是在<em>显式</em>的调用<code>ConfigurableApplicationContext#start()</code>方法后上下文启动完成时发布，所以一般我们正常的自动启动流程是监听不到此事件的。</p><h3 id="springcontextclosedevent">Spring#ContextClosedEvent</h3><blockquote><p>Published when the <code>ApplicationContext</code> is being closed byusing the <code>close()</code> method on the<code>ConfigurableApplicationContext</code> interface or via a JVMshutdown hook. Here, "closed" means that all singleton beans will bedestroyed.</p></blockquote><p>同上，对应上下文关闭的事件。</p><h3 id="springcontextstoppedevent">Spring#ContextStoppedEvent</h3><blockquote><p>Published when the <code>ApplicationContext</code> is stopped byusing the <code>stop()</code> method on the<code>ConfigurableApplicationContext</code> interface. Here, “stopped”means that all <code>Lifecycle</code> beans receive an explicit stopsignal.</p></blockquote><p>同上，对应上下文结束的事件。</p><h3id="springbootapplicationstartingevent">SpringBoot#ApplicationStartingEvent</h3><blockquote><p>An <code>ApplicationStartingEvent</code> is sent at the start of arun but before any processing, except for the registration of listenersand initializers.</p></blockquote><p>应用启动但未做任何处理（除了一些listener和initializer的注册）时会发送此事件。</p><h3id="springbootapplicationenvironmentpreparedevent">SpringBoot#ApplicationEnvironmentPreparedEvent</h3><blockquote><p>An <code>ApplicationEnvironmentPreparedEvent</code> is sent when the<code>Environment</code> to be used in the context is known but beforethe context is created.</p></blockquote><p>环境已经准备完成但上下文还未创建时发送此事件。</p><h3id="springbootapplicationcontextinitializedevent">SpringBoot#ApplicationContextInitializedEvent</h3><blockquote><p>An <code>ApplicationContextInitializedEvent</code> is sent when the<code>ApplicationContext</code> is prepared andApplicationContextInitializers have been called but before any beandefinitions are loaded.</p></blockquote><p>在上下文准备完成之后，加载bean definitions之前发送此事件。</p><h3id="springbootapplicationpreparedevent">SpringBoot#ApplicationPreparedEvent</h3><blockquote><p>An <code>ApplicationPreparedEvent</code> is sent just before therefresh is started but after bean definitions have been loaded.</p></blockquote><p>在上下文准备完成且加载beandefinitions完成之后，刷新上下文之前发送此事件。</p><h3id="springbootapplicationstartedevent">SpringBoot#ApplicationStartedEvent</h3><blockquote><p>An <code>ApplicationStartedEvent</code> is sent after the context hasbeen refreshed but before any application and command-line runners havebeen called.</p></blockquote><p>在上下文刷新完成之后，调用<ahref="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.spring-application.command-line-runner">ApplicationRunner和CommandLineRunner</a>之前发送此事件。</p><h3id="springbootavailabilitychangeevent">SpringBoot#AvailabilityChangeEvent</h3><blockquote><p>An <code>AvailabilityChangeEvent</code> is sent right after with<code>LivenessState.CORRECT</code> to indicate that the application isconsidered as live.</p></blockquote><p>在Runner调用完毕后立即发送，表示当前应用已处于活动状态：<code>LivenessState.CORRECT</code>。</p><h3id="springbootapplicationreadyevent">SpringBoot#ApplicationReadyEvent</h3><blockquote><p>An <code>ApplicationReadyEvent</code> is sent after any applicationand command-line runners have been called.</p></blockquote><p>在Runner调用完毕后发送，表示应用已经准备完毕。</p><h3id="springbootavailabilitychangeevent-1">SpringBoot#AvailabilityChangeEvent</h3><blockquote><p>An <code>AvailabilityChangeEvent</code> is sent right after with<code>ReadinessState.ACCEPTING_TRAFFIC</code> to indicate that theapplication is ready to service requests.</p></blockquote><p>应用准备完毕后，还会发送一次此事件，表示当前应用已经可以接收请求了：<code>ReadinessState.ACCEPTING_TRAFFIC</code>。</p><h3id="springbootapplicationfailedevent">SpringBoot#ApplicationFailedEvent</h3><blockquote><p>An <code>ApplicationFailedEvent</code> is sent if there is anexception on startup.</p></blockquote><p>启动过程中出现异常时，会发送此事件。</p><h2 id="从源码来看">从源码来看</h2><p>在梳理完上面的这些事件后，其实基本上对Spring和SpringBoot启动流程中一些重要的节点有了初步的印象。那现在就直接从源码来看，会更加清晰。</p><h3id="abstractapplicationcontextrefresh">AbstractApplicationContext#refresh</h3><p>Spring启动刷新上下文的核心方法，都很熟悉。步骤分明，注释清晰，优雅的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.startupShutdownMonitor) &#123;<br>        <span class="hljs-type">StartupStep</span> <span class="hljs-variable">contextRefresh</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.applicationStartup.start(<span class="hljs-string">&quot;spring.context.refresh&quot;</span>);<br><br>        <span class="hljs-comment">// Prepare this context for refreshing.</span><br>        <span class="hljs-comment">// 记录刷新开始时间、初始化PropertySources、记录刷新之前注册的监听器（如果有）</span><br>        prepareRefresh();<br><br>        <span class="hljs-comment">// Tell the subclass to refresh the internal bean factory.</span><br>        <span class="hljs-comment">// 获取实例化的BeanFactory。默认的实现是 DefaultListableBeanFactory</span><br>        <span class="hljs-type">ConfigurableListableBeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> obtainFreshBeanFactory();<br><br>        <span class="hljs-comment">// Prepare the bean factory for use in this context.</span><br>        <span class="hljs-comment">// 向BeanFactory中填充属性/配置/组件等等</span><br>        <span class="hljs-comment">// 如ClassLoader、某些post-processors、bean的表达式解析器（StandardBeanExpressionResolver）、environment beans</span><br>        prepareBeanFactory(beanFactory);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// Allows post-processing of the bean factory in context subclasses.</span><br>            <span class="hljs-comment">// BeanFactory初始化完成后，执行一些固定的后置处理。</span><br>            <span class="hljs-comment">// 这里用最常见的Web应用来说明：</span><br>            <span class="hljs-comment">// Web应用在此处会向BeanFactory中添加一些Servlet相关类的依赖解析，以便于处理它们的自动注入。</span><br>            <span class="hljs-comment">// 因为像ServletRequest和HttpSession是动态变化的，并不是单例bean，这里Spring是利用ObjectFactory来实现的</span><br>            <span class="hljs-comment">// 也就是说实际上注入的ServletRequest是一个对象工厂，每次取HttpServletRequest时是调用的此ObjectFactory来从请求上下文取值</span><br>            postProcessBeanFactory(beanFactory);<br><br>            <span class="hljs-type">StartupStep</span> <span class="hljs-variable">beanPostProcess</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.applicationStartup.start(<span class="hljs-string">&quot;spring.context.beans.post-process&quot;</span>);<br>            <span class="hljs-comment">// Invoke factory processors registered as beans in the context.</span><br>            <span class="hljs-comment">// 执行为BeanFactory准备的后置处理器</span><br>            invokeBeanFactoryPostProcessors(beanFactory);<br><br>            <span class="hljs-comment">// Register bean processors that intercept bean creation.</span><br>            <span class="hljs-comment">// 注册为bean准备的后置处理器</span><br>            registerBeanPostProcessors(beanFactory);<br>            beanPostProcess.end();<br><br>            <span class="hljs-comment">// Initialize message source for this context.</span><br>            <span class="hljs-comment">// 初始化MessageSource，国际化的标准实现就是利用MessageSource，还有就是像javax Validation的自定义消息也可以用它实现</span><br>            initMessageSource();<br><br>            <span class="hljs-comment">// Initialize event multicaster for this context.</span><br>            <span class="hljs-comment">// 初始化事件多播器，默认SimpleApplicationEventMulticaster</span><br>            initApplicationEventMulticaster();<br><br>            <span class="hljs-comment">// Initialize other special beans in specific context subclasses.</span><br>            <span class="hljs-comment">// 默认空，子类重写，初始化子context独有的类</span><br>            <span class="hljs-comment">// SpringBoot中的ServletWebServerApplicationContext就会重写它，用来初始化内置的Tomcat或其它WebServer</span><br>            onRefresh();<br><br>            <span class="hljs-comment">// Check for listener beans and register them.</span><br>            <span class="hljs-comment">// 把事件监听器注册到EventMulticaster中去，且在此时会发布在EventMulticaster初始化之前的事件</span><br>            registerListeners();<br><br>            <span class="hljs-comment">// Instantiate all remaining (non-lazy-init) singletons.</span><br>            <span class="hljs-comment">// 主要是初始化我们通常所说的单例bean</span><br>            finishBeanFactoryInitialization(beanFactory);<br><br>            <span class="hljs-comment">// Last step: publish corresponding event.</span><br>            <span class="hljs-comment">// 最后结束的时候发布了ContextRefreshedEvent事件</span><br>            finishRefresh();<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>            <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;<br>                logger.warn(<span class="hljs-string">&quot;Exception encountered during context initialization - &quot;</span> +<br>                            <span class="hljs-string">&quot;cancelling refresh attempt: &quot;</span> + ex);<br>            &#125;<br><br>            <span class="hljs-comment">// Destroy already created singletons to avoid dangling resources.</span><br>            <span class="hljs-comment">// 销毁单例bean，移除内存中的单例bean并回调bean的`destroy()`方法</span><br>            destroyBeans();<br><br>            <span class="hljs-comment">// Reset &#x27;active&#x27; flag.</span><br>            cancelRefresh(ex);<br><br>            <span class="hljs-comment">// Propagate exception to caller.</span><br>            <span class="hljs-keyword">throw</span> ex;<br>        &#125;<br>        <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// Reset common introspection caches in Spring&#x27;s core, since we</span><br>            <span class="hljs-comment">// might not ever need metadata for singleton beans anymore...</span><br>            resetCommonCaches();<br>            contextRefresh.end();<br>        &#125;<br>    &#125;<br>&#125;<br>...<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishRefresh</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Clear context-level resource caches (such as ASM metadata from scanning).</span><br>    clearResourceCaches();<br><br>    <span class="hljs-comment">// Initialize lifecycle processor for this context.</span><br>    initLifecycleProcessor();<br><br>    <span class="hljs-comment">// Propagate refresh to lifecycle processor first.</span><br>    <span class="hljs-comment">// 在初始化上面的LifecycleProcessor后，走的逻辑跟显式调用`start`方法的逻辑一样。当然start的bean就不一定一样了，且不会发布任何事件</span><br>    getLifecycleProcessor().onRefresh();<br><br>    <span class="hljs-comment">// Publish the final event.</span><br>    publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ContextRefreshedEvent</span>(<span class="hljs-built_in">this</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3id="abstractapplicationcontextstart">AbstractApplicationContext#start</h3><p>显式调用的<code>start()</code>和<code>stop()</code>方法，可以看到会发布<code>ContextStartedEvent</code>和<code>ContextStoppedEvent</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>    getLifecycleProcessor().start();<br>    publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ContextStartedEvent</span>(<span class="hljs-built_in">this</span>));<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>    getLifecycleProcessor().stop();<br>    publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ContextStoppedEvent</span>(<span class="hljs-built_in">this</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="springapplicationrun">SpringApplication#run</h3><p>SpringBoot的应用启动核心流程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title function_">run</span><span class="hljs-params">(String... args)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.nanoTime();<br>    <span class="hljs-comment">// 创建一个BootstrapContext：引导上下文，在ApplicationContext真正刷新完成前可用</span><br>    <span class="hljs-type">DefaultBootstrapContext</span> <span class="hljs-variable">bootstrapContext</span> <span class="hljs-operator">=</span> createBootstrapContext();<br>    <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 声明当前应用使用headless模式：表示应用处于服务器模式下，无法调用外接设备，如显示器、鼠标等，主要是针对awt的使用场景。</span><br>   <span class="hljs-comment">// SpringBoot当然默认是非交互式、非可视化的服务器应用</span><br>    configureHeadlessProperty();<br>    <span class="hljs-comment">// 注册SpringApplicationRunListener</span><br>    <span class="hljs-comment">// 加载应用本身的监听器（主要是EventPublishingRunListener，生命周期相关的事件由它来发布）</span><br>    <span class="hljs-comment">// 以及一些扩展的hookListener，用于自定义监听某些启动阶段</span><br>    <span class="hljs-type">SpringApplicationRunListeners</span> <span class="hljs-variable">listeners</span> <span class="hljs-operator">=</span> getRunListeners(args);<br>    <br>    <span class="hljs-comment">// 发布 ApplicationStartingEvent</span><br>    listeners.starting(bootstrapContext, <span class="hljs-built_in">this</span>.mainApplicationClass);<br>    <br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">ApplicationArguments</span> <span class="hljs-variable">applicationArguments</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultApplicationArguments</span>(args);<br>        <br>        <span class="hljs-comment">// environment的加载准备，会发布 ApplicationEnvironmentPreparedEvent</span><br>        <span class="hljs-type">ConfigurableEnvironment</span> <span class="hljs-variable">environment</span> <span class="hljs-operator">=</span> prepareEnvironment(listeners, bootstrapContext, applicationArguments);<br>        <br>        <span class="hljs-comment">// 打印banner信息</span><br>        <span class="hljs-type">Banner</span> <span class="hljs-variable">printedBanner</span> <span class="hljs-operator">=</span> printBanner(environment);<br>        <span class="hljs-comment">// 根据当前应用类型（Servlet、Reactive）创建一个 ConfigurableApplicationContext</span><br>        context = createApplicationContext();<br>        context.setApplicationStartup(<span class="hljs-built_in">this</span>.applicationStartup);<br>        <br>        <span class="hljs-comment">// 刷新应用上下文前的准备工作：</span><br>        <span class="hljs-comment">// 1.注册environment（避免重复加载）、应用上下文的后置处理、执行应用上下文刷新前的initializer</span><br>        <span class="hljs-comment">// 2.发布 ApplicationContextInitializedEvent</span><br>        <span class="hljs-comment">// 3.关闭BootstrapContext：这里会发布一个BootstrapContextClosedEvent，监听它能拿到BootstrapContext和ApplicationContext。如果需要做一些bean的迁移可以在此处实现</span><br>        <span class="hljs-comment">// 4.向BeanFactory中添加一些配置属性，往ApplicationContext中添加一些BeanFactory的后置处理</span><br>        <span class="hljs-comment">// 5.核心步骤，加载BeanDefinition</span><br>        <span class="hljs-comment">// 6.加载完毕后，发布 ApplicationPreparedEvent</span><br>        prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);<br>        <br>        <span class="hljs-comment">// 调用Spring的`AbstractApplicationContext#refresh()`方法，刷新上下文</span><br>        refreshContext(context);<br>        <span class="hljs-comment">// 默认空实现，预留的钩子</span><br>        afterRefresh(context, applicationArguments);<br>        <span class="hljs-type">Duration</span> <span class="hljs-variable">timeTakenToStartup</span> <span class="hljs-operator">=</span> Duration.ofNanos(System.nanoTime() - startTime);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logStartupInfo) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">StartupInfoLogger</span>(<span class="hljs-built_in">this</span>.mainApplicationClass).logStarted(getApplicationLog(), timeTakenToStartup);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 发布 ApplicationStartedEvent和AvailabilityChangeEvent(LivenessState.CORRECT)</span><br>        listeners.started(context, timeTakenToStartup);<br>        <span class="hljs-comment">// 调用ApplicationRunner和CommandLineRunner的实现</span><br>        <span class="hljs-comment">// 譬如seata-server的启动就是一个SpringBoot应用，实现了CommandLineRunner来触发调用Server.start</span><br>        callRunners(context, applicationArguments);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> AbandonedRunException) &#123;<br>            <span class="hljs-keyword">throw</span> ex;<br>        &#125;<br>        <span class="hljs-comment">// 失败后会发布 ApplicationFailedEvent</span><br>        handleRunFailure(context, ex, listeners);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(ex);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (context.isRunning()) &#123;<br>            <span class="hljs-type">Duration</span> <span class="hljs-variable">timeTakenToReady</span> <span class="hljs-operator">=</span> Duration.ofNanos(System.nanoTime() - startTime);<br>            <span class="hljs-comment">// 发布 AvailabilityChangeEvent(ReadinessState.ACCEPTING_TRAFFIC)</span><br>            listeners.ready(context, timeTakenToReady);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> AbandonedRunException) &#123;<br>            <span class="hljs-keyword">throw</span> ex;<br>        &#125;<br>        <span class="hljs-comment">// 失败后会发布 ApplicationFailedEvent</span><br>        handleRunFailure(context, ex, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(ex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> context;<br>&#125;<br><br>...<br><br><span class="hljs-keyword">private</span> DefaultBootstrapContext <span class="hljs-title function_">createBootstrapContext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// SpringBoot中的另一个IOC容器，在刷新应用容器之前，可以通过它来创建一些组件实例，通过BootstrapRegistryInitializer接口来实现</span><br>    <span class="hljs-comment">// 譬如说SpringCloud的ConfigServer会在此时注册一些组件</span><br>    <span class="hljs-type">DefaultBootstrapContext</span> <span class="hljs-variable">bootstrapContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultBootstrapContext</span>();<br>    <span class="hljs-built_in">this</span>.bootstrapRegistryInitializers.forEach((initializer) -&gt; initializer.initialize(bootstrapContext));<br>    <span class="hljs-keyword">return</span> bootstrapContext;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="小结">小结</h2><p>在整理完事件顺序和阅读完源码之后，Spring及SpringBoot的启动流程就一目了然了。流程的各个关键阶段都发布了对应的事件来方便做监听和扩展。而且在梳理整个流程的过程中，也会发现一些其它很优秀、很巧妙的设计，比如：</p><ul><li>钩子函数：如AbstractApplicationContext#onRefresh、SpringApplication#afterRefresh</li><li>对象工厂：ObjectFactory替代实际的单例bean，再真正需要的时候从工厂灵活获取真实的bean对象</li><li>BeanPostProcessor：后置处理器接口，Spring实现AOP的经典设计</li><li>PropertySource：应用的键值配置都转换成了这个抽象类。还可以基于它做自定义组件的属性源，如NacosPropertySource</li><li>SpEL：强大的Spring表达式语言。之前也基于它实现过一个<ahref="https://luckycaesar.github.io/article/%E4%BC%98%E9%9B%85%E5%9C%B0%E5%AE%9E%E7%8E%B0%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/">操作日志组件</a></li></ul><p>除了Spring和SpringBoot本身之外，在SpringCloud以及各家大厂的不同版本中，也有一些常见事件，比如SpringCloud#RefreshEvent、SpringCloud#EnvironmentChangeEvent、SpringCloud#RefreshScopeRefreshedEvent，在使用SpringCloud标准的<code>@RefreshScope</code>实现远程配置动态刷新时相关的几个事件。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>Event</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>后台系统接口优化杂谈</title>
    <link href="/article/%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E6%9D%82%E8%B0%88/"/>
    <url>/article/%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E6%9D%82%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="开头闲言">开头闲言</h2><p>通常我们在谈到接口性能优化的时候，更多地是针对2C的、拥有大量用户的业务接口。这些接口的持续优化必不可少，因为用户流量就意味着收入，用户体验的优先级自然是非常高的。然而针对后台运营类的系统接口，通常都比较“包容”，可能大部分系统能做到所谓的<ahref="https://blog.51cto.com/zdytesting/1734583">2-5-10原则</a>中的2秒级（甚至部分场景是5秒、10秒级）的响应即可。一是因为查询的数据量较大，二是后台运营场景下，并不是特别需要那么快速的响应，且运营人员的关注重点主要是在数据的完整性、准确性上。</p><p>当然，这并不意味着这些接口就可以“摆烂”。尤其是随着业务的扩张，运营效率的提升势在必行，而后端接口的优化首当其冲。在绝大部分业务场景下，查询无疑是最最最频繁的，后台系统当然也不例外。而且还多了一种形式-导出，只在返回结果上有差别。然后就是另外一种场景，导入。优化的重点也主要集中在这三种接口上面：<em>查询、导出、导入</em>。</p><p>本文仅做一些思路总结，具体细节不过多探究。</p><h2 id="表和sql">表和SQL</h2><p>这里主要是针对关系型数据库，最具代表也最常用的就是MySQL、Oracle和PostgreSQL了。</p><h3 id="表设计">表设计</h3><p>表结构设计是基础，这里简单整理下一些要点。更深入的设计规范和约束以及原理，推荐去阅读相关的书籍。或者也可以参考一下类似阿里的《Java开发手册》总结的一些经验。</p><ul><li>命名：精准，简要，规范。像Oracle推荐就是全部大写命名。</li><li>类型：选择合适的字段类型。如PostgreSQL就是强类型的，不同类型的比较是会直接抛错的。此外，尽量避免隐式转换，譬如我遇到过的：<em>索引字段是int类型，传入数据时指定jdbcType=deicimal类型</em>，都是数字类型，不会报错，但是会导致索引失效。<ul><li>变长数据<code>varchar</code>/<code>varchar2</code></li><li>定长数据<code>char</code></li><li>金额数字<code>decimal</code>/<code>number</code></li><li>状态/类别/年龄<code>tinyint</code>/<code>smallint</code>/<code>int</code></li><li>ID类型<code>bigint</code>/<code>int</code>/<code>number</code></li><li>时间类型<code>date</code>/<code>datetime</code>/<code>timestamp</code></li><li>只有在特殊的情况下才允许使用<code>text</code>/<code>blob</code>等类型存储超长数据，且最好独立出一张表，主键关联</li><li>编码类型，像MySQL现在一般都使用<code>utf8mb4</code>的编码，预防特殊字符</li></ul></li><li>长度：为字段指定合适的长度，节省表及索引存储空间，更能提升检索速度。<ul><li>变长字符串，根据具体字段含义指定长度，也要记得预留空间。如姓名<code>varchar(20)</code></li><li>定长类型，如身份证号<code>char(18)</code>。<em>但是一般较少使用，固定长度可能为后续的扩展带来额外的改动成本</em>，比如要兼容存储企业的社会信用代码</li><li>整型，如状态<code>tinyint(2)</code>，ID类<code>bigint(20)</code>或者<code>int(11)</code></li><li>金额，明确小数位精度和整数位长度，如<code>number(12,2)</code>或<code>decimal(12,2)</code>，10位整数，2位小数</li></ul></li><li>冗余：如果是页面经常需要查询/导出的表，应该允许一定的字段冗余，方便展示，也避免了多表join或者再在程序中去调用RPC接口填充。</li><li>非空：必填字段标识为<code>NOT NULL</code>。既能在数据库层面做一个兜底的校验，也能保证字段的索引效率。</li></ul><h3 id="索引">索引</h3><p>选择合适的、常用的查询字段创建索引。单列索引、唯一索引、复合索引等等。</p><p>学会查看执行计划，关注索引类型、扫描行数，判断索引失效原因（类型隐式转换，filesort，左模糊/全模糊等等）。允许的情况下像MySQL也提供了<code>force index</code>手动强制指定索引，当然要慎重使用。</p><h3 id="联表">联表</h3><p><strong>禁止出现过多的表join</strong>！一个是确实遇到过此类情况，join滥用，导致性能急剧下降。二是从扩展的角度来看，耦合太多，一些表如果被大量的join（没有做好字段冗余的话），后续要对其进行分拆/修改，影响面会很大。还有就是分开也可以让业务代码逻辑更清晰，方便随时的需求变动，否则随着持续迭代，SQL就无法满足或者会变得很复杂（只针对普通的业务开发）。</p><p>曾经接触过这样的查询SQL，有多达8张表的join。仅是取申请人/创建人/更新人/审批人等的全名/部门数据就出现了n次join，即使它们之间的join条件是有索引的USER_ID字段。分页后单页居然超过4s的响应。后续通过冗余常用的查询和展示字段为json格式，再使用<ahref="https://dev.mysql.com/doc/refman/8.0/en/create-table-generated-columns.html">MySQL虚拟列</a>来映射这些字段优化为2个表的join，大大的提升了查询效率，接口响应在400ms以内（非like查询）。</p><p>当然这只能说是一种奇技淫巧（这里还分享一个MySQL的奇技淫巧：<ahref="https://cloud.tencent.com/developer/article/1193344">STRAIGHT_JOIN</a>），最好还是在表设计阶段就能做好冗余。而且像上面的场景，其实这些员工的数据也应该作为快照留档，而不应该实时的取最新的数据，可能会造成误判，比如人员调岗。</p><p>另外，多表join，当表数据分布情况发生变化时，可能会让优化器对驱动表的选择发生变化（像MySQL）。所以可能出现项目运行一段时间后SQL变慢，还得通过执行计划来判断如何调整join。</p><h2 id="代码实现">代码实现</h2><p>代码实现层面的优化和数据库是相辅相成的。甚至可以说应用代码的设计还要显得更为重要一些。因为现如今流行的数据库，只要按照它们的要求去设计和构建表和索引，问题一般不会太大，大部分场景下交给自带的优化器足够了。</p><h3 id="分页">分页</h3><p>页面查询的分页基本已经成了一种铁律，自不必多说。而针对导出也可以分页查询，分段写单个Sheet或者多个Sheet，像<ahref="https://easyexcel.opensource.alibaba.com/docs/current/quickstart/write">EasyExcel</a>就可以支持。当然也需要注意普通查询下的深度分页问题。</p><ul><li><ahref="https://juejin.cn/post/7012016858379321358">聊聊如何解决MySQL深分页问题</a></li><li><ahref="https://www.cnblogs.com/happyflyingpig/p/15959609.html">记录一次Oracle数据库千万级数据表的分页性能优化</a></li><li><a href="https://segmentfault.com/a/1190000022478915">MyBatis如何实现流式查询</a></li><li><ahref="https://blog.csdn.net/m0_62375467/article/details/129714527">大数据量查询：流式查询与游标查询</a></li></ul><h3 id="循环与映射">循环与映射</h3><p>查询时尽量直接使用SQL返回需要的字段，中间可能最多只是做一些DTO →VO的转换。</p><p>如果确实需要查询后循环处理一些逻辑或者补充一些字段信息（譬如微服务拆分后，需要通过RPC取一些基础信息），那尽量把循环中的I/O操作提到循环外，改为批量查询后再在内存中映射匹配。同样也适用于导入时的循环校验。</p><h3 id="并行">并行</h3><p>一般是在导入/导出时使用。面对大量数据的导入/导出，可能还需要在循环中做一些校验/信息填充，即使是分页或者循环外批量查询映射后，也有可能还是达不到一个理想的响应速度，这时候就该并行处理登场了。</p><ul><li><p>并行流/线程池：最标准的就是使用这两种方式。<em>但是并行流的使用要注意，其底层默认提供的线程池的并行度是跟CPU核心数挂钩的</em>。尤其是目前盛行微服务的容器化部署，可能单个pod的资源只有1个核心甚至少于1个核心，那“并行”其实就还是一个串行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ForkJoinPool#makeCommonPool() 并行度兜底设置</span><br><span class="hljs-keyword">if</span> (parallelism &lt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-comment">// default 1 less than #cores</span><br>    (parallelism = Runtime.getRuntime().availableProcessors() - <span class="hljs-number">1</span>) &lt;= <span class="hljs-number">0</span>)<span class="hljs-comment">// availableProcessors - JVM可用的处理器数量</span><br>    parallelism = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>而且这个默认的池是整个应用程序通用的，所以如果代码中大量的使用并行流且不手动调整并行度（通过系统变量<code>java.util.concurrent.ForkJoinPool.common.parallelism</code>来调整，不推荐）的话，并不能提升处理效率。所以请在条件允许的情况下使用并行流，推荐还是自定义线程池。</p><ul><li><p><ahref="https://luckycaesar.github.io/article/%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E5%B9%B6%E8%A1%8C%E6%B5%81/">什么时候使用并行流</a></p></li><li><p><ahref="https://www.baeldung.com/java-when-to-use-parallel-stream">When toUse a Parallel Stream in Java</a></p></li></ul></li><li><p>协程/虚拟线程：这个在JDK 19中已经发布了<ahref="https://openjdk.org/jeps/425">预览版本</a>（随着JDK21的发布，已经是<ahref="https://openjdk.org/jeps/444">正式版</a>了，实在是太快了orz）。国内像腾讯开源的<ahref="https://github.com/Tencent/TencentKona-8/wiki/KonaFiber%E7%94%A8%E6%88%B7%E6%96%87%E6%A1%A3-292">TencentKona</a>，移植了协程的特性，可以作为尝鲜和参考。</p><p>我尝试了一下，使用协程池可以将并行度提高至线程池的几十上百倍，基本上普通场景下的导入都可以做到<em>整个文件的处理时间≈单笔数据的处理时间</em>。当然作为池，在后台系统的使用场景中没必要设置如此之高的常驻核心线程数，仅作为测试。贴一下demo代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(&quot;fiberDemoExecutor&quot;)</span><br><span class="hljs-keyword">public</span> Executor <span class="hljs-title function_">fiberDemoExecutor</span><span class="hljs-params">(FiberProperties fiberProperties)</span> &#123;<br>    <span class="hljs-type">ThreadPoolTaskExecutor</span> <span class="hljs-variable">poolExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskExecutor</span>();<br>    <span class="hljs-comment">// 这里设置的coreSize=2000</span><br>    poolExecutor.setCorePoolSize(fiberProperties.getCoreSize());<br>    poolExecutor.setMaxPoolSize(fiberProperties.getMaxSize());<br>    poolExecutor.setKeepAliveSeconds(fiberProperties.getKeepAliveSeconds());<br>    poolExecutor.setQueueCapacity(fiberProperties.getQueueSize());<br>    poolExecutor.setThreadFactory(newThreadFactory(fiberProperties.getEnabled()));<br>    poolExecutor.setTaskDecorator((r) -&gt; r);<br>    poolExecutor.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">poolName</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getClass().getSimpleName();<br>            log.warn(poolName + <span class="hljs-string">&quot; is full, caller run&quot;</span>);<br>            <span class="hljs-built_in">super</span>.rejectedExecution(r, e);<br>        &#125;<br>    &#125;);<br>    poolExecutor.initialize();<br>    <span class="hljs-keyword">return</span> poolExecutor;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadFactory <span class="hljs-title function_">newThreadFactory</span><span class="hljs-params">(<span class="hljs-type">boolean</span> enabled)</span> &#123;<br>    <span class="hljs-keyword">if</span> (enabled) &#123;<br>        <span class="hljs-comment">// 创建虚拟线程</span><br>        <span class="hljs-keyword">return</span> Thread.ofVirtual()<br>            .name(<span class="hljs-string">&quot;fiber-demo-&quot;</span>, <span class="hljs-number">0</span>)<br>            .uncaughtExceptionHandler((t, e) -&gt;<br>                log.error(<span class="hljs-string">&quot;thread [&#123;&#125;] got an unexpected exception.&quot;</span>, t.getName(), e))<br>            .factory();<br>    &#125;<br>    <span class="hljs-comment">// 创建线程</span><br>    <span class="hljs-keyword">return</span> Thread.ofPlatform()<br>        .name(<span class="hljs-string">&quot;fiber-demo-&quot;</span>, <span class="hljs-number">0</span>)<br>        .factory();<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParallelDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationListener</span>&lt;ApplicationStartedEvent&gt; &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> ThreadPoolTaskExecutor fiberDemoExecutor;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent</span><span class="hljs-params">(ApplicationStartedEvent event)</span> &#123;<br>        <span class="hljs-comment">// 协程模型</span><br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">2000</span>);<br>        <span class="hljs-type">StopWatch</span> <span class="hljs-variable">stopWatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopWatch</span>();<br>        stopWatch.start();<br>        IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">2000</span>).forEach(value -&gt; fiberDemoExecutor.execute(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 模拟业务逻辑执行时长</span><br>                TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">200</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignore) &#123;<br>            &#125;<br>            countDownLatch.countDown();<br>        &#125;));<br>        <span class="hljs-keyword">try</span> &#123;<br>            countDownLatch.await();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignore) &#123;<br>        &#125;<br>        stopWatch.stop();<br>        <span class="hljs-comment">// timespan-virtual-thread: 229ms</span><br>        System.out.println(<span class="hljs-string">&quot;timespan-virtual-thread: &quot;</span> + stopWatch.getTotalTimeMillis() + <span class="hljs-string">&quot;ms&quot;</span>);<br><br>        <span class="hljs-comment">// 线程模型，并行流默认分配，i7-10700 8核16线程</span><br>        <span class="hljs-type">StopWatch</span> <span class="hljs-variable">stopWatch1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopWatch</span>();<br>        stopWatch1.start();<br>        IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">2000</span>).parallel().forEach(value -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 模拟业务逻辑执行时长</span><br>                TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">200</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignore) &#123;<br>            &#125;<br>        &#125;);<br>        stopWatch1.stop();<br>        <span class="hljs-comment">// timespan-thread: 31712ms</span><br>        System.out.println(<span class="hljs-string">&quot;timespan-thread: &quot;</span> + stopWatch1.getTotalTimeMillis());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="方案设计">方案设计</h2><p>跳出具体实现，从更高一层的方案设计上的改进也是很有必要的。</p><h3 id="数据库选型">数据库选型</h3><p>针对不同的业务场景选择不同的数据库，譬如<ahref="https://developer.aliyun.com/article/64352">什么场景应该用MongoDB</a>。海量日志数据的存储，可以选用ElasticSearch、Solr等。譬如用ES作埋点用户行为日志数据的存储，再在后台做分析统计。</p><h3 id="数据库集群">数据库集群</h3><p>像MySQL原生支持丰富的集群模式，如<ahref="https://dev.mysql.com/doc/refman/8.0/en/replication.html">Replication</a>、<ahref="https://dev.mysql.com/doc/refman/8.0/en/group-replication.html">GroupReplication</a>、<ahref="https://dev.mysql.com/doc/refman/8.0/en/mysql-innodb-cluster-introduction.html">InnoDBCluster</a>，以此为基础做读写分离设计。但是，<ahref="https://xie.infoq.cn/article/b26c3fcd77aba3f242ffcfeb4">设计数据库集群读写分离并非易事</a>。</p><h3 id="分库分表">分库分表</h3><p>参考阿里《Java开发手册》：</p><blockquote><p>【推荐】单表行数超过 500 万行或者单表容量超过2GB，才推荐进行分库分表。</p><p>说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p></blockquote><p>我觉得很有参考的必要，确实大部分业务系统在它的生命周期内，都用不到分库分表。要么业务没了（orz），要么后续就完全推翻重构了。</p><p>当然，话说回来，可预见的数据膨胀和业务增长，尤其是在过去十年里，进行分库/分表/分区是也是必要的。</p><p>说到分表，可能大部分人都是想到一些中间件（<ahref="https://shardingsphere.apache.org/index_zh.html">ApacheShardingSphere</a>）。但其实也不一定非要引入第三方组件，比如自定义规则，页面固定分表条件，手动拼接表后缀来处理分表也未尝不可，好处是不会有较高的学习成本和过多的依赖，缺点当然是SQL不够“优雅”，写起来比较麻烦。且随着数据持续性膨胀，也无法满足更多的分表要求。譬如先按业务渠道横向拆分表，再对日志表或者超大业务表按时间/ID取模等等纵向拆分。</p><h3 id="lucene">Lucene</h3><p>这里单独拎出来，是因为曾经利用Lucene实现过后台单据的综合搜索，不得不感叹倒排索引的设计之巧妙。而且ElasticSearch的底层核心就是它。在需要时，也可以尝试用它去做搜索优化。</p><h3 id="定时任务">定时任务</h3><p>无需实时导出的业务，可以使用任务定时生成文件，提供下载。导入，提交任务，异步处理完成后通知。</p><p>而针对任务本身，可以引入类似SpringBatch的批处理框架来提升处理效率。或者针对集群化部署的大规模业务，引入分布式任务调度中间件如<ahref="https://www.xuxueli.com/xxl-job/">XXL-JOB</a>、<ahref="https://www.aliyun.com/aliware/schedulerx">SchedulerX</a>。再或者更高级的任务调度设计方案，<ahref="https://mp.weixin.qq.com/s/6zY3ZtilM1jA5gMPMDRQyA">支付宝定时任务怎么做？三层分发任务处理框架介绍</a>。</p><h3 id="消息队列">消息队列</h3><p>同样的，有条件的情况下（可能有些后台系统并不会一开始就去依赖消息队列），也可以通过MQ来实现一些异步的处理，可能比任务调度的方案更效率一些，当然要注意消息丢失、重试、事务消息等等。</p><h3 id="缓存">缓存</h3><p>一般后台系统其实很少说大量使用缓存，利用缓存提升效率的场景一般出现在对外的接口或者热点数据里面。毕竟数据一致性的维护还是比较麻烦的，会增加额外的开发运维成本。当然有需求的情况下也可以做缓存。</p><ul><li>MyBatis/JPA：框架自带特性，多级缓存。但是一定要注意合理且正确的使用，否则出现数据不一致会很头疼。</li><li>本地/Redis缓存：本地缓存使用简单但是能力有限，Redis使用复杂且增加了依赖，但是功能强大适合分布式系统。需要手动控制数据一致性，根据业务类型，选择定时任务同步、监听事件实时更新、全量或增量更新、固定时间失效后重做缓存等等。</li></ul><h2 id="结尾碎语">结尾碎语</h2><p>以上，个人经验之谈，像个大杂烩，也没有什么“新”技术。但是，也想借此分享一个Github大佬的经典案例：<ahref="https://github.blog/2021-09-27-partitioning-githubs-relational-databases-scale/">PartitioningGitHub’s relational databases to handlescale</a>。其中提到的数字是亮点：</p><blockquote><p>In 2019, mysql1 answered 950,000 queries/s on average, 900,000queries/s on replicas, and 50,000 queries/s on the primary.</p></blockquote><p>Github截至2019年仍然使用的是MySQL“朴素的”一主多从集群模式，却能够支撑如此之大的访问量，不得不说在技术深度这一块儿确实是炉火纯青。也正如他总结里所说的：</p><blockquote><p>We often choose to leverage “boring” technology that has been provento work at our scale, as reliability remains the primary concern.</p></blockquote><p>不盲目的追求“新”技术，使用久经考验的、所谓“无聊”的技术来构建高效稳定可靠的产品和服务，或许才是普通开发者们应该多多关注的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>后台</tag>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>再遇Spring循环依赖</title>
    <link href="/article/%E5%86%8D%E9%81%87Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    <url>/article/%E5%86%8D%E9%81%87Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>说起Spring中的循环依赖，相信所有的SpringJavaer们都耳熟能详，不论是作为面试八股文死记硬背过，还是在实际项目中踩过坑。我也一样，本以为有Spring来解决这个问题就万事大吉了。然而，这次遇到的却不大一样。</p><p>那先来简单回顾下Spring是如何解决循环依赖的，以及，能否解决所有情况的循环依赖？</p><h3 id="提前暴露和三级缓存">提前暴露和三级缓存</h3><p>Spring创建bean实例的核心逻辑位于<code>AbstractAutowireCapableBeanFactory.doCreateBean</code>方法里面，简单讲主要是这么几个步骤：</p><ul><li>实例化：<code>createBeanInstance</code>，通过构造器实例化，在JVM中创建一个空对象。</li><li>依赖填充：<code>populateBean</code>，<code>@Autowire</code>、<code>@Resource</code>等注解扫描，依赖属性填充。还有就是执行实现了<code>InstantiationAwareBeanPostProcessor</code>接口的增强，譬如我们熟悉的<code>@PostConstructor</code>注解就是在这一步被解析的。</li><li>初始化：<code>initializeBean</code>，通常所说的初始化，一些Aware接口、BeanPostProcessor接口的增强，还有我们熟悉的<code>InitializingBean.afterPropertiesSet</code>方法、<code>@Bean</code>或者xml中bean标签声明的<code>initMethod</code>方法等的执行。</li></ul><p>而循环依赖的问题，就是在上面的步骤中处理的。Spring巧妙的利用了三级缓存以及提前暴露构造器实例化好的空对象来解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Cache of singleton objects: bean name --&gt; bean instance */</span><br><span class="hljs-comment">// 一级缓存</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">256</span>);<br><br><span class="hljs-comment">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span><br><span class="hljs-comment">// 三级缓存</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br><br><span class="hljs-comment">/** Cache of early singleton objects: bean name --&gt; bean instance */</span><br><span class="hljs-comment">// 二级缓存</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure><p>更多的原理和源码分析，网上找了一篇文章讲得很详细：<ahref="https://developer.aliyun.com/article/766880">讲一讲Spring中的循环依赖</a></p><h3 id="解决了哪些情况下的循环依赖">解决了哪些情况下的循环依赖</h3><p>贴一下文中的表格：</p><table><thead><tr class="header"><th style="text-align: left;">依赖情况</th><th style="text-align: left;">依赖注入方式</th><th style="text-align: left;">循环依赖是否被解决</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">AB相互依赖（循环依赖）</td><td style="text-align: left;">均采用setter方法注入</td><td style="text-align: left;">是</td></tr><tr class="even"><td style="text-align: left;">AB相互依赖（循环依赖）</td><td style="text-align: left;">均采用构造器注入</td><td style="text-align: left;">否</td></tr><tr class="odd"><td style="text-align: left;">AB相互依赖（循环依赖）</td><tdstyle="text-align: left;">A中注入B的方式为setter方法，B中注入A的方式为构造器</td><td style="text-align: left;">是</td></tr><tr class="even"><td style="text-align: left;">AB相互依赖（循环依赖）</td><tdstyle="text-align: left;">B中注入A的方式为setter方法，A中注入B的方式为构造器</td><td style="text-align: left;">否</td></tr></tbody></table><p>在了解了bean的创建过程，以及Spring解决循环依赖的方式，就能回答上面那篇文章最后提出的思考题。提前暴露和第三级缓存有一个大前提，那就是构造器实例化阶段已经完成，所以：</p><ol type="1"><li><p>如果A、B均采用构造器注入，那不管是A还是B先创建，在构造器实例化阶段就已经产生了循环依赖，提前暴露也就失效了，无法解决循环依赖。</p></li><li><p>最后一种情况，B中注入A的方式为setter方法，A中注入B的方式为构造器。根据Spring默认创建的顺序，A先创建，此时会去找B的实例，再在B中去注入A，然而此时A正处于构造器实例化的过程中，无法提前暴露到第三级缓存中，所以也无法解决。</p></li><li><p>那反过来，A中注入B的方式为setter方法，B中注入A的方式为构造器。按照A、B的创建先后顺序，A在实例化后被提前暴露进入到第三级缓存当中，而B在实例化注入A时，也能顺利找到提前暴露的A的空对象，所以也就不会报错。</p></li></ol><p>其实除了上面这两种情况，还有一种无法解决的循环依赖，非单例bean的情况。这是自然的，prototype的情况下，Spring并不会管理这些bean的生命周期，也就不存在所谓的循环依赖解决了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCurrentlyInCreationException</span>(beanName);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="报错">报错</h2><p>接下来就看看报错。先描述场景，<em>在同一个项目的不同分支上启动服务，存在循环依赖的两个Service的业务代码完全一样，但是结果却大相径庭</em>。这里使用Aaa和Bbb两个类来做示例，它们之间的循环依赖属于普通的注解注入，而非构造器注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Aaa</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AaaIface</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> Bbb bbb;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 这个@Transactional注解，是问题的核心点之一</span><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testA</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(bbb);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bbb</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BbbIface</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> Aaa aaa;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testB</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(aaa);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前一节所说的A与B之间无法解决的循环依赖通常遇到的报错日志都是类似这样的：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tex">Requested bean is currently in creation: Is there an unresolvable circular reference?<br><br>...<br><br>The dependencies of some of the beans in the application context form a cycle:<br><br>┌─────┐<br>|  aaa defined in file [Aaa.class]<br>↑     ↓<br>|  bbb defined in file [Bbb.class]<br>└─────┘<br></code></pre></td></tr></table></figure><p>而此次遇到的报错却是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name <span class="hljs-string">&#x27;aaa&#x27;</span>: <br>Bean with name <span class="hljs-string">&#x27;aaa&#x27;</span> has been injected into other beans [bbb] in its raw version as part of a circular reference, but has eventually been wrapped.<br>This means that said other beans <span class="hljs-keyword">do</span> not use the <span class="hljs-keyword">final</span> version of the bean.<br>This is often the result of over-eager type matching - consider using <span class="hljs-string">&#x27;getBeanNamesOfType&#x27;</span> with the <span class="hljs-string">&#x27;allowEagerInit&#x27;</span> flag turned off, <span class="hljs-keyword">for</span> example.<br></code></pre></td></tr></table></figure><p>这里面有一些关键字<strong>wrapped、finalversion</strong>等，猜测跟代理有关。那循环依赖时如果存在被包装代理的增强bean，会有什么不一样？</p><p>顺藤摸瓜，找到了报错的源码。这个地方的逻辑是在<code>populateBean()</code>和<code>initializeBean()</code>之后，也就是完成了<code>aaa</code>的初始化后才会触发这些判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 正在创建的aaa的原始bean</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> instanceWrapper.getWrappedInstance();<br><br><span class="hljs-comment">// 是否触发提前暴露：这里三个条件都是true。aaa是单例 &amp;&amp; allowCircularReferences默认为true &amp;&amp; aaa正在创建中</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">earlySingletonExposure</span> <span class="hljs-operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="hljs-built_in">this</span>.allowCircularReferences &amp;&amp;<br>isSingletonCurrentlyInCreation(beanName));<br>...<br><span class="hljs-comment">// 依赖填充和初始化</span><br>populateBean(beanName, mbd, instanceWrapper);<br>exposedObject = initializeBean(beanName, exposedObject, mbd);<br>...<br><span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<br>    <span class="hljs-comment">// 针对提前暴露的情况再进行判断，earlySingletonReference肯定是不会为空的，从二级缓存中会取到</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">earlySingletonReference</span> <span class="hljs-operator">=</span> getSingleton(beanName, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">if</span> (earlySingletonReference != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 这个地方exposedObject居然不等于bean？</span><br>        <span class="hljs-keyword">if</span> (exposedObject == bean) &#123;<br>            exposedObject = earlySingletonReference;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;<br>            String[] dependentBeans = getDependentBeans(beanName);<br>            Set&lt;String&gt; actualDependentBeans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);<br>            <span class="hljs-keyword">for</span> (String dependentBean : dependentBeans) &#123;<br>                <span class="hljs-keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;<br>                    actualDependentBeans.add(dependentBean);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// else if中前面的逻辑先不看，最后触发了这个异常</span><br>            <span class="hljs-keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCurrentlyInCreationException</span>(beanName,<br>                        <span class="hljs-string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; has been injected into other beans [&quot;</span> +<br>                        StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +<br>                        <span class="hljs-string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +<br>                        <span class="hljs-string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +<br>                        <span class="hljs-string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +<br>                        <span class="hljs-string">&quot;&#x27;getBeanNamesForType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看了这段代码，感觉有点晕。先不追究根本原因，来找找解决方案吧。</p><h2 id="解决">解决</h2><p>这个报错的解决方案，网上一搜就有，一般都是使用<code>@Lazy</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-meta">@Lazy</span><br><span class="hljs-keyword">private</span> Bbb bbb;<br></code></pre></td></tr></table></figure><p>Spring创建<code>aaa</code>时发现被<code>@Lazy</code>标识的依赖<code>bbb</code>，就会对其进行处理，实际上创建的是一个代理对象，而不是真正的<code>bbb</code>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">buildLazyResourceProxy</span><span class="hljs-params">(<span class="hljs-keyword">final</span> LookupElement element,</span><br><span class="hljs-params">                                        <span class="hljs-keyword">final</span> <span class="hljs-meta">@Nullable</span> String requestingBeanName)</span> &#123;<br>    <span class="hljs-type">TargetSource</span> <span class="hljs-variable">ts</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TargetSource</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Class&lt;?&gt; getTargetClass() &#123;<br>            <span class="hljs-keyword">return</span> element.lookupType;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isStatic</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getTarget</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> getResource(element, requestingBeanName);<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseTarget</span><span class="hljs-params">(Object target)</span> &#123;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-type">ProxyFactory</span> <span class="hljs-variable">pf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyFactory</span>();<br>    pf.setTargetSource(ts);<br>    <span class="hljs-keyword">if</span> (element.lookupType.isInterface()) &#123;<br>        pf.addInterface(element.lookupType);<br>    &#125;<br>    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> (<span class="hljs-built_in">this</span>.beanFactory <span class="hljs-keyword">instanceof</span> ConfigurableBeanFactory ?<br>                               ((ConfigurableBeanFactory) <span class="hljs-built_in">this</span>.beanFactory).getBeanClassLoader() : <span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">return</span> pf.getProxy(classLoader);<br>&#125;<br></code></pre></td></tr></table></figure><p>所以<code>aaa</code>创建时，触发填充<code>bbb</code>的依赖，实际上获取到的是上面这个代理对象，没有执行<code>bbb</code>的真正创建逻辑，也就是压根儿不会触发循环依赖相关的判断和报错。<em>在启动完成，<code>aaa</code>用到<code>bbb</code>时，会触发上面这个代理对象的<code>getTarget</code>逻辑，获取真正的<code>bbb</code>实例，而此时<code>bbb</code>中依赖的<code>aaa</code>对象可以直接在Spring容器中获取到，不管是代理对象还是原始对象，自然也不会有问题</em>。这就是所谓的Lazy的含义吧。</p><p>报错是解决了，但是为什么会出现这种错误呢？</p><h2 id="追因">追因</h2><h3 id="aop版本">AOP版本</h3><p>有了解决方案，心里就安心多了。在问题分支上开启debug调试，发现走到上面报错源码的地方：<em><code>exposedObject != bean</code>，exposedObject最终变成了一个CGLIB的代理对象，而bean仍然是实例化好的原始对象</em>。那肯定不会相等了，所以为什么exposedObject会变成一个代理对象呢？</p><p>最终定位到了这里：<code>org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#postProcessAfterInitialization()</code>。<em>注意这个方法名称，说明是bean初始化阶段<code>initializeBean</code>里面某个后置处理器的逻辑</em>。这也跟上面报错的源码顺序对得上，在<code>initializeBean</code>之后。</p><p>经过一番追查，发现这里的确是一个重点：<em>spring-aop在某个版本中对于提前暴露的bean和当前正在创建的原始bean的比对逻辑有变动</em>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 核心逻辑所在类</span><br>org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator<br><br><span class="hljs-comment">// 5.0.13.RELEASE之前</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;Object&gt; earlyProxyReferences = Collections.newSetFromMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">16</span>));<br>...<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getEarlyBeanReference</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span> getCacheKey(bean.getClass(), beanName);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;<br>        <span class="hljs-built_in">this</span>.earlyProxyReferences.add(cacheKey);<br>    &#125;<br>    <span class="hljs-keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);<br>&#125;<br>...<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-keyword">if</span> (bean != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span> getCacheKey(bean.getClass(), beanName);<br>        <span class="hljs-comment">// 关键就是下面这个if判断，以前相当于只判断beanName。beanName相同，则认为earlyProxyReferences中的对象和bean是相同的，直接返回bean。</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;<br>            <span class="hljs-keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br><br><span class="hljs-comment">//======================================================================================</span><br><br><span class="hljs-comment">// 5.0.13.RELEASE之后</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Object, Object&gt; earlyProxyReferences = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br>...<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getEarlyBeanReference</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span> getCacheKey(bean.getClass(), beanName);<br>    <span class="hljs-built_in">this</span>.earlyProxyReferences.put(cacheKey, bean);<br>    <span class="hljs-keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);<br>&#125;<br>...<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-keyword">if</span> (bean != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span> getCacheKey(bean.getClass(), beanName);<br>        <span class="hljs-comment">// 但是新版本还增加了bean对象是否相等的判断，如果不等，说明earlyProxyReferences中的对象是被提前代理过的，则当前bean肯定也是需要被代理的，触发执行wrapIfNecessary方法，返回代理后的对象。如果相等，则说明bean无需代理。</span><br>        <span class="hljs-comment">// 当然这里旧版本的并不一定就是有问题的，肯定是有其它的逻辑变动了才会进行调整。</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;<br>            <span class="hljs-keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure><p>exposedObject最终就指向上面这个方法返回的bean，所以如果被代理了，那exposedObject肯定是不等于正在创建的原始bean的。</p><p>到这里本以为找到问题原因了，是版本不一致导致的。然而仔细比对了两个分支的版本后，发现都是使用的<em>5.0.19.RELEASE</em>版本，也就是说执行的都是新逻辑。问题分支出现的旧版本并不是当前业务类所在module依赖的。</p><p>这就有点奇怪了，于是再到没有报错的分支上继续调试。这一调试果然就发现了不一样的地方。</p><h3 id="aspectj增强器和advice增强器">AspectJ增强器和Advice增强器</h3><p>两个分支都出现了一个一样的后置处理<code>AnnotationAwareAspectJAutoProxyCreator</code>（Spring默认），它进行了AOP代理，但是对循环引用的处理逻辑无任何影响。而在出现问题的分支上，<em>多执行了一个<code>DefaultAdvisorAutoProxyCreator</code>的后置处理器，就是它执行完后会进行重复的代理操作，导致bean被</em>二次代理。它们都继承了<code>AbstractAutoProxyCreator</code>类，所以在进行后置增强时都会走到上面的<code>postProcessAfterInitialization</code>逻辑中去。关于这两个类的部分注释如下。</p><p>DefaultAdvisorAutoProxyCreator：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<span class="hljs-meta">@code</span> BeanPostProcessor&#125; implementation that creates AOP proxies based on all<br>candidate &#123;<span class="hljs-meta">@code</span> Advisor&#125;s in the current &#123;<span class="hljs-meta">@code</span> BeanFactory&#125;. This <span class="hljs-keyword">class</span> <span class="hljs-title class_">is</span><br>completely generic; it contains no special code to handle any particular aspects,<br>such as pooling aspects.<br></code></pre></td></tr></table></figure><p>AnnotationAwareAspectJAutoProxyCreator：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">&#123;<span class="hljs-meta">@link</span> AspectJAwareAdvisorAutoProxyCreator&#125; sub<span class="hljs-keyword">class</span> <span class="hljs-title class_">that</span> <span class="hljs-title">processes</span> <span class="hljs-title">all</span> <span class="hljs-title">AspectJ</span><br><span class="hljs-keyword">annotation</span> aspects <span class="hljs-keyword">in</span> the current application context, <span class="hljs-keyword">as</span> well <span class="hljs-keyword">as</span> Spring Advisors.<br></code></pre></td></tr></table></figure><p>可以看出分别是处理基于Spring原生的Advice接口的增强和基于AspectJ注解的增强（也能处理Spring的Advisor）。<strong>在默认情况下，Spring是开启<code>AnnotationAwareAspectJAutoProxyCreator</code>增强器，而不是DefaultAdvisorAutoProxyCreator</strong>，因为前者可以处理不同实现的切面增强。</p><p>找到具体的类就好办了，全局搜索后发现是业务框架层权限jar包里面自动装配的bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@DependsOn(&quot;lifecycleBeanPostProcessor&quot;)</span><br><span class="hljs-keyword">public</span> DefaultAdvisorAutoProxyCreator <span class="hljs-title function_">getDefaultAdvisorAutoProxyCreator</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">DefaultAdvisorAutoProxyCreator</span> <span class="hljs-variable">creator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultAdvisorAutoProxyCreator</span>();<br>    creator.setProxyTargetClass(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">return</span> creator;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们的权限框架使用的是Shiro，在外面封装了一层，使之更适配本地业务。那么加这样的自动装配肯定就跟Shiro的一些增强有关，很明显装配这个bean跟它依赖的<code>lifecycleBeanPostProcessor</code>生命周期增强bean息息相关。但是这里不再去深究Shiro相关的代码和配置，只需要知道确实是这个配置引发了问题即可。</p><h3 id="事务增强">事务增强</h3><p>走到这里，我们了解了是<code>DefaultAdvisorAutoProxyCreator</code>触发了对<code>aaa</code>的代理。那么就还剩下最后一步，到底进行了什么样的增强？</p><p>答案就是<em>事务增强</em>。类Aaa的public方法上有<code>@Transactional</code>注解，那肯定会触发Spring的扫描，对其进行事务增强。贴一下debug截图佐证：</p><figure><img src="/img/transactionInterceptor.png"alt="transactionInterceptor" /><figcaption aria-hidden="true">transactionInterceptor</figcaption></figure><h3 id="根因分析">根因分析</h3><p>最后的最后，再完整的分析一下报错处源码的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<br>    <span class="hljs-comment">// 此时提前暴露的aaa已经被提升到了二级缓存，取出来的就是一个事务增强的代理对象</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">earlySingletonReference</span> <span class="hljs-operator">=</span> getSingleton(beanName, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">if</span> (earlySingletonReference != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 这里exposedObject是经过initializeBean之后包装增强的代理对象，自然不会等于原始bean</span><br>        <span class="hljs-keyword">if</span> (exposedObject == bean) &#123;<br>            exposedObject = earlySingletonReference;<br>        &#125;<br>        <span class="hljs-comment">// allowRawInjectionDespiteWrapping默认等于false</span><br>        <span class="hljs-comment">// hasDependentBean(beanName)：aaa当前肯定有依赖的bean，这里也就是bbb</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;<br>            <span class="hljs-comment">// 取bbb</span><br>            String[] dependentBeans = getDependentBeans(beanName);<br>            Set&lt;String&gt; actualDependentBeans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);<br>            <span class="hljs-keyword">for</span> (String dependentBean : dependentBeans) &#123;<br>                <span class="hljs-comment">// 这里removeSingletonIfCreatedForTypeCheckOnly返回false，所以会把bbb放入actualDependentBeans</span><br>                <span class="hljs-keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;<br>                    actualDependentBeans.add(dependentBean);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;<br>                <span class="hljs-comment">// 不为空，触发报错</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCurrentlyInCreationException</span>(beanName, ...);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 判断bbb是否已经完整的被创建，这里肯定是返回false。因为aaa依赖填充创建bbb时，由于提前暴露，bbb可以正常的完成创建的流程。</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeSingletonIfCreatedForTypeCheckOnly</span><span class="hljs-params">(String beanName)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.alreadyCreated.contains(beanName)) &#123;<br>        <span class="hljs-comment">// 如果没有完成创建，则会从多级缓存中移除bbb</span><br>        removeSingleton(beanName);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// bbb已经完成了创建，alreadyCreated中已经存在bbb</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此处报错的逻辑已然梳理通顺了，能看出来其实在<code>allowRawInjectionDespiteWrapping=false</code>的情况下，后面的报错必然会触发。因为<code>aaa</code>肯定依赖<code>bbb</code>且此时<code>bbb</code>必定已经创建完成。从这个报错来看，Spring认为循环依赖中如果出现代理是有问题的。那为什么呢？先看看关于<code>allowRawInjectionDespiteWrapping</code>属性的注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Set whether to allow the raw injection of a bean instance into some other</span><br><span class="hljs-comment">  * bean&#x27;s property, despite the injected bean eventually getting wrapped</span><br><span class="hljs-comment">  * (for example, through AOP auto-proxying).</span><br><span class="hljs-comment">  * &lt;p&gt;This will only be used as a last resort in case of a circular reference</span><br><span class="hljs-comment">  * that cannot be resolved otherwise: essentially, preferring a raw instance</span><br><span class="hljs-comment">  * getting injected over a failure of the entire bean wiring process.</span><br><span class="hljs-comment">  * &lt;p&gt;Default is &quot;false&quot;, as of Spring 2.0. Turn this on to allow for non-wrapped</span><br><span class="hljs-comment">  * raw beans injected into some of your references, which was Spring 1.2&#x27;s</span><br><span class="hljs-comment">  * (arguably unclean) default behavior.</span><br><span class="hljs-comment">  * &lt;p&gt;&lt;b&gt;<span class="hljs-doctag">NOTE:</span>&lt;/b&gt; It is generally recommended to not rely on circular references</span><br><span class="hljs-comment">  * between your beans, in particular with auto-proxying involved.</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@see</span> #setAllowCircularReferences</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAllowRawInjectionDespiteWrapping</span><span class="hljs-params">(<span class="hljs-type">boolean</span> allowRawInjectionDespiteWrapping)</span> &#123;<br>    <span class="hljs-built_in">this</span>.allowRawInjectionDespiteWrapping = allowRawInjectionDespiteWrapping;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出Spring也特别提醒（NOTE）了涉及自动代理的情况，不要出现循环依赖，但也没有伪代码的例子。那就只能我们自己来找了，一番debug下来，其实原因也很简单，看下截图就明白了：</p><figure><img src="/img/b_a20230312112052.png" alt="bbb中依赖的aaa对象" /><figcaption aria-hidden="true">bbb中依赖的aaa对象</figcaption></figure><figure><img src="/img/a_exo_20230312112104.png"alt="aaa创建时的exposedObjec和earlySingletonReference" /><figcaptionaria-hidden="true">aaa创建时的exposedObjec和earlySingletonReference</figcaption></figure><p>从截图可以很明显的看出来，<em><code>bbb</code>中依赖的<code>aaa</code>的代理对象ab7178dd@6910（这个代理对象和被提升到二级缓存中的earlySingletonReference的对象是同一个）和最终<code>aaa</code>初始化后的代理对象2dd8f255@6967，即exposedObject，是不一样的。因为<code>aaa</code>提前暴露触发的代理和初始化触发的代理是分开的两次触发，得到的对象当然不一样。也就是说此时如果不抛出错误，那么Spring容器中会出现两个不同的<code>aaa</code>的代理对象</em>。这显然是错误的。</p><p>至此，总算是完完整整的梳理出了这个问题的根因。画了一张简单的整体流程图解：</p><figure><img src="/img/Spring循环依赖.jpg"alt="Spring循环依赖和动态代理（点击查看大图）" /><figcaptionaria-hidden="true">Spring循环依赖和动态代理（点击查看大图）</figcaption></figure><h2 id="拓展">拓展</h2><p>梳理完整个流程后，也不得不感叹Spring设计之精妙，当然也非常复杂。最后还可以扩展出一些知识点：</p><ul><li>Spring AOP与AspectJ的比较 <ahref="https://www.baeldung.com/spring-aop-vs-aspectj">Comparing SpringAOP and AspectJ</a></li><li>JDK动态代理：<ahref="https://www.baeldung.com/java-dynamic-proxies">Dynamic Proxies inJava</a></li><li>CGLIB动态代理：<a href="https://www.baeldung.com/cglib">Introductionto cglib</a></li><li>事务：<ahref="https://www.baeldung.com/java-transactions">Introduction toTransactions in Java and Spring</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>循环依赖</tag>
      
      <tag>动态代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BigDecimal使用小结</title>
    <link href="/article/BigDecimal%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"/>
    <url>/article/BigDecimal%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>这些年接触过很多不同业务类型的系统，其中对数字敏感的系统也有很多，在Java中当仁不让的会大量使用BigDecimal，过程中不乏很多踩坑之处，因此做个简单的整理。</p><h2 id="实例化">实例化</h2><p>一般我们都会使用<code>new BigDecimal()</code>构造器和<code>BigDecimal.valueOf()</code>方法来实例化一个BigDecimal对象。这里特别要注意构造器入参为<code>double</code>类型时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// doubleDecimal = 0.1000000000000000055511151231257827021181583404541015625</span><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">doubleDecimal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">0.1d</span>);<br><span class="hljs-comment">// doubleDecimal1 = 1</span><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">doubleDecimal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">1.0d</span>);<br><br><span class="hljs-comment">// stringDecimal = 1.234</span><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">stringDecimal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.234&quot;</span>);<br><br><span class="hljs-comment">// doubleValueDecimal = 1.234，等同于 new BigDecimal(&quot;1.234&quot;)</span><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">doubleValueDecimal</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(<span class="hljs-number">1.234d</span>);<br></code></pre></td></tr></table></figure><p>可以看到<code>double</code>类型的入参会有所谓的”<em>精度丢失</em>“问题，所以在new时推荐使用字符串或其他几种类型参数的构造器，或者使用<code>.valueOf()</code>方法，避免出现这种问题。</p><p>对于这种”<em>精度丢失</em>“问题，在入参为<code>double</code>类型的构造器上有这样一段注释：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tex">* The results of this constructor can be somewhat unpredictable.<br>* One might assume that writing &#123;@code new BigDecimal(0.1)&#125; in<br>* Java creates a &#123;@code BigDecimal&#125; which is exactly equal to<br>* 0.1 (an unscaled value of 1, with a scale of 1), but it is<br>* actually equal to<br>* 0.1000000000000000055511151231257827021181583404541015625.<br>* This is because 0.1 cannot be represented exactly as a<br>* &#123;@code double&#125; (or, for that matter, as a binary fraction of<br>* any finite length).  Thus, the value that is being passed<br>* &lt;em&gt;in&lt;/em&gt; to the constructor is not exactly equal to 0.1,<br>* appearances notwithstanding.<br></code></pre></td></tr></table></figure><p>简单来说就是代码中所传入的 0.1d 并不能真正的表示一个 0.1的double数，实际上在内存中：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">0.1d = 0.1000000000000000055511151231257827021181583404541015625<br></code></pre></td></tr></table></figure><p>所以并不是精度真的丢失了，而是BigDecimal原原本本的返回了0.1double数的真正值，只不过在程序代码逻辑里，我们要的是这个效果：<code>0.1d = 0.1</code>。</p><blockquote><p>至于为何在计算机中，0.1并不等于0.1，可以看这里：<ahref="https://juejin.cn/post/7203622312871231525">0.1 + 0.2 不等于0.3？原来是因为这个</a></p></blockquote><p>可以反过来看看这个例子，<code>.valueOf()</code>和<code>.toString()</code>会对<code>d</code> 这个double数字进行近似运算，认为这个数字就是等于0.1，在程序中会看起来更合理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.1000000000000000055511151231257827021181583404541015625</span>;<br><br><span class="hljs-comment">// decimal = 0.1000000000000000055511151231257827021181583404541015625</span><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">decimal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(d);<br><br><span class="hljs-comment">// strValue = 0.1</span><br><span class="hljs-type">String</span> <span class="hljs-variable">strValue</span> <span class="hljs-operator">=</span> String.valueOf(d);<br><br><span class="hljs-comment">// doubleValue = 0.1</span><br><span class="hljs-type">Double</span> <span class="hljs-variable">doubleValue</span> <span class="hljs-operator">=</span> Double.valueOf(d);<br><br><span class="hljs-comment">// doubleValue1 = 0.1</span><br><span class="hljs-type">String</span> <span class="hljs-variable">doubleValue1</span> <span class="hljs-operator">=</span> Double.toString(d);<br></code></pre></td></tr></table></figure><p>除了用以上的方式进行实例化，BigDecimal也把0 -10的数字初始化为一个缓存常量池，并暴露出几个常用数值，其余的数字会在调用一些实例化方法时判断，如果匹配就直接返回池中初始化好的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Cache of common small BigDecimal values.</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> BigDecimal ZERO_THROUGH_TEN[] = &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(BigInteger.ZERO,       <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">1</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(BigInteger.ONE,        <span class="hljs-number">1</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">1</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(BigInteger.TWO,        <span class="hljs-number">2</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">1</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(BigInteger.valueOf(<span class="hljs-number">3</span>), <span class="hljs-number">3</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">1</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(BigInteger.valueOf(<span class="hljs-number">4</span>), <span class="hljs-number">4</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">1</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(BigInteger.valueOf(<span class="hljs-number">5</span>), <span class="hljs-number">5</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">1</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(BigInteger.valueOf(<span class="hljs-number">6</span>), <span class="hljs-number">6</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">1</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(BigInteger.valueOf(<span class="hljs-number">7</span>), <span class="hljs-number">7</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">1</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(BigInteger.valueOf(<span class="hljs-number">8</span>), <span class="hljs-number">8</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">1</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(BigInteger.valueOf(<span class="hljs-number">9</span>), <span class="hljs-number">9</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">1</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(BigInteger.TEN,        <span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>),<br>&#125;;<br><br><span class="hljs-comment">// The value 0, with a scale of 0.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">ZERO</span> <span class="hljs-operator">=</span> ZERO_THROUGH_TEN[<span class="hljs-number">0</span>];<br><br><span class="hljs-comment">// The value 1, with a scale of 0.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">ONE</span> <span class="hljs-operator">=</span> ZERO_THROUGH_TEN[<span class="hljs-number">1</span>];<br><br><span class="hljs-comment">// The value 10, with a scale of 0.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">TEN</span> <span class="hljs-operator">=</span> ZERO_THROUGH_TEN[<span class="hljs-number">10</span>];<br><br><span class="hljs-comment">// The value 0.1, with a scale of 1.</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">ONE_TENTH</span> <span class="hljs-operator">=</span> valueOf(<span class="hljs-number">1L</span>, <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// The value 0.5, with a scale of 1.</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">ONE_HALF</span> <span class="hljs-operator">=</span> valueOf(<span class="hljs-number">5L</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h2 id="舍入模式">舍入模式</h2><h4id="roundingmode.upbigdecimal.round_up">RoundingMode.UP(BigDecimal.ROUND_UP)</h4><p>向远离0的方向舍入，非0数字生效。正数变大，负数变小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingUp1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2344&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.UP);<span class="hljs-comment">// = 1.235</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingUp2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2345&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.UP);<span class="hljs-comment">// = 1.235</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingUp3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2346&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.UP);<span class="hljs-comment">// = 1.235</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingUp4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2344&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.UP);<span class="hljs-comment">// = -1.235</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingUp5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2345&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.UP);<span class="hljs-comment">// = -1.235</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingUp6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2346&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.UP);<span class="hljs-comment">// = -1.235</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingUp7</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.23401&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.UP);<span class="hljs-comment">// = -1.235</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingUp8</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.23401&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.UP);<span class="hljs-comment">// = 1.235</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingUp9</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2340&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.UP);<span class="hljs-comment">// = -1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingUp10</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2340&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.UP);<span class="hljs-comment">// = 1.234</span><br></code></pre></td></tr></table></figure><h4id="roundingmode.downbigdecimal.round_down">RoundingMode.DOWN(BigDecimal.ROUND_DOWN)</h4><p>向靠近0的方向舍入，非0数字生效。正数变小，负数变大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingDown1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2344&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.DOWN);<span class="hljs-comment">// = 1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingDown2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2345&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.DOWN);<span class="hljs-comment">// = 1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingDown3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2346&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.DOWN);<span class="hljs-comment">// = 1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingDown4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2344&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.DOWN);<span class="hljs-comment">// = -1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingDown5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2345&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.DOWN);<span class="hljs-comment">// = -1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingDown6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2346&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.DOWN);<span class="hljs-comment">// = -1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingDown7</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.23401&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.DOWN);<span class="hljs-comment">// = -1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingDown8</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.23401&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.DOWN);<span class="hljs-comment">// = 1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingDown9</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2340&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.DOWN);<span class="hljs-comment">// = -1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingDown10</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2340&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.DOWN);<span class="hljs-comment">// = 1.234</span><br></code></pre></td></tr></table></figure><h4id="roundingmode.ceilingbigdecimal.round_ceiling">RoundingMode.CEILING(BigDecimal.ROUND_CEILING)</h4><p>向正无穷方向舍入，非0数字生效。正负数都会变大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingCeiling1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2344&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.CEILING);<span class="hljs-comment">// = 1.235</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingCeiling2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2345&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.CEILING);<span class="hljs-comment">// = 1.235</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingCeiling3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2346&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.CEILING);<span class="hljs-comment">// = 1.235</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingCeiling4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2344&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.CEILING);<span class="hljs-comment">// = -1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingCeiling5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2345&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.CEILING);<span class="hljs-comment">// = -1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingCeiling6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2346&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.CEILING);<span class="hljs-comment">// = -1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingCeiling7</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.23401&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.CEILING);<span class="hljs-comment">// = -1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingCeiling8</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.23401&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.CEILING);<span class="hljs-comment">// = 1.235</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingCeiling9</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2340&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.CEILING);<span class="hljs-comment">// = -1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingCeiling10</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2340&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.CEILING);<span class="hljs-comment">// = 1.234</span><br></code></pre></td></tr></table></figure><h4id="roundingmode.floorbigdecimal.round_floor">RoundingMode.FLOOR(BigDecimal.ROUND_FLOOR)</h4><p>向负无穷方向舍入，非0数字生效。正负数都会变小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingFloor1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2344&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.FLOOR);<span class="hljs-comment">// = 1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingFloor2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2345&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.FLOOR);<span class="hljs-comment">// = 1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingFloor3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2346&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.FLOOR);<span class="hljs-comment">// = 1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingFloor4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2344&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.FLOOR);<span class="hljs-comment">// = -1.235</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingFloor5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2345&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.FLOOR);<span class="hljs-comment">// = -1.235</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingFloor6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2346&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.FLOOR);<span class="hljs-comment">// = -1.235</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingFloor7</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.23401&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.FLOOR);<span class="hljs-comment">// = -1.235</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingFloor8</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.23401&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.FLOOR);<span class="hljs-comment">// = 1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingFloor9</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2340&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.FLOOR);<span class="hljs-comment">// = -1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingFloor10</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2340&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.FLOOR);<span class="hljs-comment">// = 1.234</span><br></code></pre></td></tr></table></figure><h4id="roundingmode.half_upbigdecimal.round_half_up">RoundingMode.HALF_UP(BigDecimal.ROUND_HALF_UP)</h4><p>四舍五入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingHalfUp1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2344&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.HALF_UP);<span class="hljs-comment">// = 1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingHalfUp2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2345&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.HALF_UP);<span class="hljs-comment">// = 1.235</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingHalfUp3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2346&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.HALF_UP);<span class="hljs-comment">// = 1.235</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingHalfUp4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2344&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.HALF_UP);<span class="hljs-comment">// = -1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingHalfUp5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2345&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.HALF_UP);<span class="hljs-comment">// = -1.235</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingHalfUp6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2346&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.HALF_UP);<span class="hljs-comment">// = -1.235</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingHalfUp7</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2340&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.HALF_UP);<span class="hljs-comment">// = -1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingHalfUp8</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2340&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.HALF_UP);<span class="hljs-comment">// = 1.234</span><br></code></pre></td></tr></table></figure><h4id="roundingmode.half_downbigdecimal.round_half_down">RoundingMode.HALF_DOWN(BigDecimal.ROUND_HALF_DOWN)</h4><p>五舍六入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingHalfDown1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2344&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.HALF_DOWN);<span class="hljs-comment">// = 1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingHalfDown2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2345&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.HALF_DOWN);<span class="hljs-comment">// = 1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingHalfDown3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2346&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.HALF_DOWN);<span class="hljs-comment">// = 1.235</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingHalfDown4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2344&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.HALF_DOWN);<span class="hljs-comment">// = -1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingHalfDown5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2345&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.HALF_DOWN);<span class="hljs-comment">// = -1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingHalfDown6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2346&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.HALF_DOWN);<span class="hljs-comment">// = -1.235</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingHalfDown7</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2340&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.HALF_DOWN);<span class="hljs-comment">// = -1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingHalfDown8</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2340&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.HALF_DOWN);<span class="hljs-comment">// = 1.234</span><br></code></pre></td></tr></table></figure><h4id="roundingmode.half_evenbigdecimal.round_half_even">RoundingMode.HALF_EVEN(BigDecimal.ROUND_HALF_EVEN)</h4><p>银行家舍入（四舍六入五取偶法）。四舍六入，五分两种情况，如果前一位为奇数，则入，为偶数，则舍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingHalfEven1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2344&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.HALF_EVEN);<span class="hljs-comment">// = 1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingHalfEven2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2345&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.HALF_EVEN);<span class="hljs-comment">// = 1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingHalfEven3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2315&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.HALF_EVEN);<span class="hljs-comment">// = 1.232</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingHalfEven4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2346&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.HALF_EVEN);<span class="hljs-comment">// = 1.235</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingHalfEven5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2344&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.HALF_EVEN);<span class="hljs-comment">// = -1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingHalfEven6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2345&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.HALF_EVEN);<span class="hljs-comment">// = -1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingHalfEven7</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2315&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.HALF_EVEN);<span class="hljs-comment">// = -1.232</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingHalfEven8</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2346&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.HALF_EVEN);<span class="hljs-comment">// = -1.235</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingHalfEven9</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;-1.2340&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.HALF_EVEN);<span class="hljs-comment">// = -1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundingHalfEven10</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2340&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.HALF_EVEN);<span class="hljs-comment">// = 1.234</span><br></code></pre></td></tr></table></figure><h4id="roundingmode.unnecessarybigdecimal.round_unnecessary">RoundingMode.UNNECESSARY(BigDecimal.ROUND_UNNECESSARY)</h4><p>断言传入的数字已经是指定长度精确的，否则抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">rounding1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.234&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.UNNECESSARY);<span class="hljs-comment">// = 1.234</span><br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">rounding2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2340&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.UNNECESSARY);<span class="hljs-comment">// = 1.234</span><br><br><span class="hljs-comment">// &quot;java.lang.ArithmeticException: Rounding necessary&quot;</span><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">rounding3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.2341&quot;</span>).setScale(<span class="hljs-number">3</span>, RoundingMode.UNNECESSARY);<br></code></pre></td></tr></table></figure><h2 id="比较">比较</h2><p>在比较时，使用<code>BigDecimal.ZERO</code>等常量进行<code>equals</code>比较时，一定要注意精度。还有就是使用<code>equals</code>方法和<code>compareTo</code>方法进行比较可能会得到不同的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// b1 = false，要注意这个，BigDecimal.ZERO = 0</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> BigDecimal.ZERO.equals(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.00&quot;</span>));<br><span class="hljs-comment">// b2 = true</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> BigDecimal.ZERO.equals(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0&quot;</span>));<br><br><span class="hljs-comment">// b3 = true</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">b3</span> <span class="hljs-operator">=</span> BigDecimal.ZERO.compareTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0&quot;</span>)) == <span class="hljs-number">0</span>;<br><span class="hljs-comment">// b4 = true</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">b4</span> <span class="hljs-operator">=</span> BigDecimal.ZERO.compareTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.00&quot;</span>)) == <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// b5 = true</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">b5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.00&quot;</span>).compareTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.00&quot;</span>)) == <span class="hljs-number">0</span>;<br><span class="hljs-comment">// b6 = true</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">b6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.00&quot;</span>).equals(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.00&quot;</span>));<br><br><span class="hljs-comment">// b7 = true</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">b7</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.0&quot;</span>).compareTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.00&quot;</span>)) == <span class="hljs-number">0</span>;<br><span class="hljs-comment">// b8 = false</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">b8</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.0&quot;</span>).equals(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.00&quot;</span>));<br></code></pre></td></tr></table></figure><p>总结两点：</p><ul><li><code>equals</code>会对精度进行比较，所以同样的值的精度不同，会认为不相等。如0.0 和 0.00</li><li><code>compareTo</code>方法更符合宏观比较算法，同样值的两个对象，精度一不一样都认为是相等的</li></ul><p>推荐使用<code>compareTo</code>方法，尤其是在进行一些业务逻辑计算之后的比较，使用<code>equals</code>方法容易忽略精度问题（踩过坑T＿T）。</p><h2 id="小数点移位">小数点移位</h2><p>通常要进行小数点移位，想到的都是乘以10、100或者除以10、100来实现，但是在BigDecimal里面，使用乘除法进行移位有很大的风险。</p><p>使用除法进行左移位操作，舍入模式和移位后需要保留的位数必须精确指定，否则就不是简单的移位了，会造成移位后精度损失。同样的，使用乘法进行右移位操作，也涉及到精度问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// = 1.235</span><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">divide</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;123.456&quot;</span>).divide(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;100&quot;</span>), RoundingMode.HALF_EVEN);<br><br><span class="hljs-comment">// = 1.23456</span><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">divide1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;123.456&quot;</span>).divide(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;100&quot;</span>), <span class="hljs-number">5</span>, RoundingMode.UNNECESSARY);<br><br><br><span class="hljs-comment">// = 12345.61200</span><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">multiply</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;123.45612&quot;</span>).multiply(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;100&quot;</span>));<br><br><span class="hljs-comment">// = 12345.61</span><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">multiply1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;123.45612&quot;</span>).multiply(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;100&quot;</span>), MathContext.DECIMAL32);<br><br><span class="hljs-comment">// = 12345.61200</span><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">multiply2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;123.45612&quot;</span>).multiply(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;100&quot;</span>), MathContext.DECIMAL64);<br><br><span class="hljs-comment">// = 12345.61200</span><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">multiply3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;123.45612&quot;</span>).multiply(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;100&quot;</span>), MathContext.DECIMAL128);<br></code></pre></td></tr></table></figure><p>推荐使用<code>movePointLeft</code>和<code>movePointRight</code>方法，简单方便不会出错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// = 1.23456</span><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">movePointLeft</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;123.456&quot;</span>).movePointLeft(<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// = 12345.612</span><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">movePointRight</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;123.45612&quot;</span>).movePointRight(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h2 id="转字符串">转字符串</h2><ul><li>toString()：返回此｛<span class="citation"data-cites="code">@code</span>BigDecimal｝的字符串表示形式，如果需要指数，则使用科学记数法。</li><li>toEngineeringString()：返回此｛<span class="citation"data-cites="code">@code</span>BigDecimal｝的字符串表示形式，如果需要指数，则使用工程符号。类似于科学计数法，但指数的幂都是3的倍数。</li><li>toPlainString()：没有任何计数法表示，返回一个不包含指数的字符串。</li></ul><h2 id="乘除">乘除</h2><ul><li><p><strong>除以0！除以0！除以0！</strong></p></li><li><p>在计算完后必须使用<code>.setScale</code>方法来统一进行最终结果的精度约束。如果只有除法，那必须使用提供了scale和roundingMode参数的<code>.divide</code>方法，因为除法很容易除不尽，会产生无限循环小数。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>BigDecimal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数式编程增强库Vavr初探（二）</title>
    <link href="/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%A2%9E%E5%BC%BA%E5%BA%93Vavr%E5%88%9D%E6%8E%A2%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%A2%9E%E5%BC%BA%E5%BA%93Vavr%E5%88%9D%E6%8E%A2%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本文是翻译Vavr官方文档的<ahref="https://docs.vavr.io/#_introduction">序章</a>，上一篇的<ahref="https://luckycaesar.github.io/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%A2%9E%E5%BC%BA%E5%BA%93vavr%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%80%EF%BC%89/">使用指南</a>介绍了Vavr中的主要组件的定义和使用示例。其中也出现了一些函数式编程的概念，如<em>函数副作用</em>、<em>引用透明性</em>、<em>持久化集合</em>、<em>不可变数据结构</em>等等，在序言中都有更进一步的阐述。</p><h1 id="序章">1. 序章</h1><p>Vavr（过去叫Javaslang）是一个为Java8+而生的函数式库，它提供了持久化数据类型和函数式控制结构。</p><h2 id="用vavr实现java8的函数式数据结构">1.1.用Vavr实现Java8的函数式数据结构</h2><p>Java8的<ahref="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">lambdas(λ)</a>能让我们构建出很棒的API’s，这些API极大的提升了语言的表现力。</p><p>Vavr利用基于函数式模型的lambdas创造了一系列的新特性，其中一个就是函数式集合库，旨在替换Java中的标准库。</p><figure><img src="/img/vavr-collections.png" alt="collections" /><figcaption aria-hidden="true">collections</figcaption></figure><p><em>（这只是一张鸟瞰图，接下来会有更易于阅读的版本。）</em></p><h2 id="函数式编程">1.2. 函数式编程</h2><p>在探讨细节之前，我想先讲解一些基础知识。解释一下我为什么会设计Vavr，特别是新的Java集合类。</p><h3 id="副作用">1.2.1. 副作用</h3><p>Java应用通常都有大量的<ahref="https://en.wikipedia.org/wiki/Side_effect_(computer_science)">副作用</a>。它们改变了某种状态，可能是外界的（程序以外的）。常见的副作用是<em>原地</em>改变对象或者变量，打印到控制台、写到日志文件或者数据库。如果副作用以非预期的方式影响了我们程序的语义，那就认为它是有害的。</p><p>例如，一个函数抛出了异常且这个异常是<em>interpreted</em>，它就被认为是一个<em>影响程序</em>的副作用。而且，<ahref="http://c2.com/cgi/wiki?DontUseExceptionsForFlowControl">异常类似于非本地的go-to语句</a>，它们会破坏正常的控制流。不管怎么说，实际的应用确实会产生副作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> dividend, <span class="hljs-type">int</span> divisor)</span> &#123;<br>    <span class="hljs-comment">// throws if divisor is zero</span><br>    <span class="hljs-keyword">return</span> dividend / divisor;<br>&#125;<br></code></pre></td></tr></table></figure><p>在函数环境下，可以用Try来封装副作用使我们（的程序）处于一个良好的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// = Success(result) or Failure(exception)</span><br>Try&lt;Integer&gt; <span class="hljs-title function_">divide</span><span class="hljs-params">(Integer dividend, Integer divisor)</span> &#123;<br>    <span class="hljs-keyword">return</span> Try.of(() -&gt; dividend / divisor);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个版本的divide方法不会再抛出任何异常，我们利用Try类型显式的显示了可能的失败。</p><h3 id="引用透明性">1.2.2. 引用透明性</h3><p>一个函数，或者更笼统的说一个表达式，对它的调用如果能用它的值替换而不影响程序本身的行为，那就称之为<ahref="https://en.wikipedia.org/wiki/Referential_transparency">引用透明性</a>。简单来讲，给定相同的输入总能得到相同的输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// not referentially transparent</span><br>Math.random();<br><br><span class="hljs-comment">// referentially transparent</span><br>Math.max(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>如果（函数中）涉及的所有表达式都是引用透明的，则称该函数为<ahref="https://en.wikipedia.org/wiki/Pure_function">纯函数</a>。一个由纯函数组成的应用大概率在编译后就可以<em>直接运行</em>，这也很容易解释。单元测试变得易于编写，而调试则成为了过去式。</p><h3 id="对值的思考">1.2.3. 对值的思考</h3><p>Clojure语言创始人Rich Hickey，曾做过一个很棒的演讲<ahref="https://www.youtube.com/watch?v=-6BsiVyC1kM">The Value ofValues</a>。其中最有趣的值就是<ahref="https://en.wikipedia.org/wiki/Immutable_object">不可变</a>值，主要原因是不可变值</p><ul><li><p>天然是线程安全的，因此也无需同步</p></li><li><p>有关于<em>equals</em>和<em>hashcode</em>都是稳定的，所以（不可变值）也是可靠的哈希键</p></li><li><p>无需克隆</p></li><li><p>当被用在未经检查的协变<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[协变与逆变](https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98)。">[1]</span></a></sup>转换（Java特有的）中时也能表现得类型安全</p></li></ul><p>用<em>不可变值</em>搭配<em>引用透明性函数</em>是使Java变得更好的关键，Vavr则提供了必要的<ahref="http://static.javadoc.io/io.vavr/vavr/0.10.4/io/vavr/control/package-summary.html">控件</a>和<ahref="https://static.javadoc.io/io.vavr/vavr/0.10.4/io/vavr/collection/package-summary.html">集合</a>以在日常的Java编程中达成这一目标。</p><h2 id="果壳中的数据结构">1.3. 果壳中的数据结构</h2><p>Vavr的集合库包含了一组丰富的基于lambda之上的函数式数据结构，唯一个与Java原生集合共享的接口是Iterable。（没有共享其他接口的）主要原因是基于Java集合接口的更改器方法<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[mutator method](https://en.wikipedia.org/wiki/Mutator_method)。">[2]</span></a></sup>无法返回一个底层集合类型的对象。</p><p>下面来看看不同类型的数据结构，我们会知道为什么这（不共享集合接口）是非常必要的。</p><h3 id="可变数据结构">1.3.1. 可变数据结构</h3><p>Java是一门面向对象编程语言。我们通过封装对象的状态来达到数据隐藏的目的，然后提供更改器方法控制这种状态。<ahref="https://en.wikipedia.org/wiki/Java_collections_framework">Javacollections framework (JCF)</a> 就是基于此种思想构建的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">// removes all elements from this collection</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我会把<em>void</em>的返回类型理解为一种异味。它就是<ahref="https://en.wikipedia.org/wiki/Side_effect_(computer_science)">副作用</a>产生的证据，会使得状态发生变换。<em>共享</em>可变状态是一个造成失败的主要来源，不仅仅在并发环境中。</p><h3 id="不可变数据结构">1.3.2. 不可变数据结构</h3><p><ahref="https://en.wikipedia.org/wiki/Immutable_object">不可变</a>数据结构被创建后就无法更改。在Java的上下文中，它们以集合包装器的形式被广泛应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Collections.unmodifiableList(otherList);<br><br><span class="hljs-comment">// Boom!</span><br>list.add(<span class="hljs-string">&quot;why not?&quot;</span>);<br></code></pre></td></tr></table></figure><p>有各种各样的库提供了类似实用的方法给我们。（这些方法）返回的结果总是一个特定集合的不可变视图，而且通常在我们调用一个更改器方法后在运行时抛出（异常）。</p><h3 id="持久化数据结构">1.3.3. 持久化数据结构</h3><p>一个<ahref="https://en.wikipedia.org/wiki/Persistent_data_structure">持久化数据结构</a>在被修改时，会保留它以往的版本，也因此形成了<em>事实上</em>的不可变。完全地持久化数据结构允许对任何版本进行更新和查询。</p><p>许多操作只会执行很小的改动，仅仅拷贝上一个版本并不会变得高效。要节省时间和内存，确认两个版本之间的相似之处并尽可能多的共享数据就显得尤为重要。</p><p>这种模型不会强制任何实现细节，此时就该函数式数据结构登场了。</p><h2 id="函数式数据结构">1.4. 函数式数据结构</h2><p>也被称作<ahref="https://en.wikipedia.org/wiki/Purely_functional"><em>纯</em>函数式数据结构</a>，它们是<em>不可变</em>且<em>持久化</em>的。函数式数据结构的方法都是<em>引用透明</em>的。</p><p>Vavr拥有许多很常用的函数式数据结构，接下来会举例进行深入讲解。</p><h3 id="链表">1.4.1. 链表</h3><p>最受欢迎当然也是最简单的一种函数式数据结构就是 <ahref="https://en.wikipedia.org/wiki/Linked_list">（单）链表</a>，它有一个<em>头</em>元素和一个<em>尾</em>列表。链表的行为类似于遵循<ahref="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">后进先出(LIFO)</a>方法的栈。</p><p>在Vavr里我们可以像这样来实例化一个列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// = List(1, 2, 3)</span><br>List&lt;Integer&gt; list1 = List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>列表中的每一个元素都形成了一个独立的节点，最后一个元素的尾部指向Nil，一个空的列表。<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="查看源码可知，这里是按3、2、1的顺序进行构建的，对整个链表的遍历，则会按照1、2、3的顺序输出，遵循后进先出原则。整个链表遍历顺序的**头节点是1，尾节点是3**。">[3]</span></a></sup></p><figure><img src="/img/vavr-list1.png" alt="list1" /><figcaption aria-hidden="true">list1</figcaption></figure><p>这使得我们可以在列表的不同版本之间共享元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// = List(0, 2, 3)</span><br>List&lt;Integer&gt; list2 = list1.tail().prepend(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>新的头元素0被<em>链接</em>到原列表的尾部<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="此时的**尾部**不是按链表的遍历顺序，而是按构建链表时的顺序来定义的。**头元素0**会变成新版本链表遍历顺序的头节点。更新后的新版本链表，遍历出来的结果就是0、2、3。">[4]</span></a></sup>，原来的列表则保持不变。</p><figure><img src="/img/vavr-list2.png" alt="list2" /><figcaption aria-hidden="true">list2</figcaption></figure><p>这些操作都会在常数时间内运行，换句话说就是与列表的大小无关。大部分其它操作都是线性时间，在Vavr里面会通过接口LinearSeq来表示，我们可能已经从Scala中了解过了。</p><p>如果我们需要能在常数时间内执行查询的数据结构，Vavr提供了Array和Vector，它们都拥有<ahref="https://en.wikipedia.org/wiki/Random_access">随机存取</a>的能力。</p><p>Array类型由Java对象数组支持，插入和删除操作都是线性时间。Vector（的时间开销）则介于Array和List之间，它在随机存取和修改时表现的都很不错。</p><p>实际上链表也可以用来实现队列数据结构。</p><h3 id="队列">1.4.2. 队列</h3><p>一个很高效的函数式队列可以基于两个链表来实现。<em>front</em>链表持有<em>出队的</em>元素，<em>rear</em>链表持有<em>入队的</em>元素，入队和出队操作都是O(1)的时间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;Integer&gt; queue = Queue.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>                            .enqueue(<span class="hljs-number">4</span>)<br>                            .enqueue(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><p>队列由3个元素初始化，还有两个元素在rear列表中排队。</p><figure><img src="/img/vavr-queue1.png" alt="queue1" /><figcaption aria-hidden="true">queue1</figcaption></figure><p>如果front列表在出队时元素耗尽，那么rear列表会被翻转成为新的front列表。</p><figure><img src="/img/vavr-queue2.png" alt="queue2" /><figcaption aria-hidden="true">queue2</figcaption></figure><p>一个元素出队时我们会得到第一个元素和剩余队列组成的一对数据。必须返回这个队列的新版本，因为函数式数据结构是不可变且持久化的，原队列不应当受影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;Integer&gt; queue = Queue.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// = (1, Queue(2, 3))</span><br>Tuple2&lt;Integer, Queue&lt;Integer&gt;&gt; dequeued = queue.dequeue();<br></code></pre></td></tr></table></figure><p>当队列为空时会发生什么？这时dequeue()方法会抛出NoSuchElementException，用<em>函数式方式</em>来做的话我们更期望返回一个可选结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// = Some((1, Queue()))</span><br>Queue.of(<span class="hljs-number">1</span>).dequeueOption();<br><br><span class="hljs-comment">// = None</span><br>Queue.empty().dequeueOption();<br></code></pre></td></tr></table></figure><p>一个可选结果可以被进一步处理，不管它是否为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// = Queue(1)</span><br>Queue&lt;Integer&gt; queue = Queue.of(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// = Some((1, Queue()))</span><br>Option&lt;Tuple2&lt;Integer, Queue&lt;Integer&gt;&gt;&gt; dequeued = queue.dequeueOption();<br><br><span class="hljs-comment">// = Some(1)</span><br>Option&lt;Integer&gt; element = dequeued.map(Tuple2::_1);<br><br><span class="hljs-comment">// = Some(Queue())</span><br>Option&lt;Queue&lt;Integer&gt;&gt; remaining = dequeued.map(Tuple2::_2);<br></code></pre></td></tr></table></figure><h3 id="有序集合5">1.4.3.有序集合<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="这里的集合是指**Set**。">[5]</span></a></sup></h3><p>有序集合是比队列使用得更频繁的一种数据结构。我们使用二叉搜索树以函数式方式给它们建模，这些树由一些节点组成，每个节点有一个值且最多只能拥有两个孩子节点。</p><p>我们会在排序的情况下 -使用一个元素比较器来表达，构建二叉搜索树。任何给定节点的左子树的值都严格地小于当前给定节点的值，而所有右子树的值则严格地大于。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// = TreeSet(1, 2, 3, 4, 6, 7, 8)</span><br>SortedSet&lt;Integer&gt; xs = TreeSet.of(<span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure><figure><img src="/img/vavr-binarytree1.png" alt="binarytree1" /><figcaption aria-hidden="true">binarytree1</figcaption></figure><p>这棵树的查询时间复杂度为O(log<sub>n</sub>)。我们从根节点开始搜索，并判断是否找到了目标元素。由于所有的值是整体有序的，所以我们知道下一步该从何处进行搜索，是这棵树的左分支还是右分支。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// = TreeSet(1, 2, 3);</span><br>SortedSet&lt;Integer&gt; set = TreeSet.of(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// = TreeSet(3, 2, 1);</span><br>Comparator&lt;Integer&gt; c = (a, b) -&gt; b - a;<br>SortedSet&lt;Integer&gt; reversed = TreeSet.of(c, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>大部分树的操作本质上都是<ahref="https://en.wikipedia.org/wiki/Recursion">递归</a>。插入函数和搜索函数很类似，当一条搜索路径抵达终点时，会创建一个新节点，然后整个路径会重建到根节点，（在此期间会）尽可能的引用现有的子节点。因此插入操作会花费O(log<sub>n</sub>)的时间和空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// = TreeSet(1, 2, 3, 4, 5, 6, 7, 8)</span><br>SortedSet&lt;Integer&gt; ys = xs.add(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><figure><img src="/img/vavr-binarytree2.png" alt="binarytree2" /><figcaption aria-hidden="true">binarytree2</figcaption></figure><p>为了保持二叉搜索树的性能特点，它需要保持一个平衡。所有从根节点到叶子节点的路径需要在大体上保持等长。</p><p>在Vavr里面我们基于<ahref="https://en.wikipedia.org/wiki/Red–black_tree">红黑树</a>实现了一个二叉搜索树，它使用一种特殊的着色方式来使得二叉树在插入和删除节点时保持平衡。</p><p>如想了解更多关于本章节主题的内容，请查阅Chris Okasaki的书籍 <ahref="http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504">PurelyFunctional Data Structures</a>。</p><h2 id="集合的状态">1.5. 集合的状态</h2><p>一般来说，我们看到的是目前编程语言的趋同。优秀的特性会保留，反之则会消亡。但是Java不同，它注定要一直向后兼容，这是一种优势但也会延缓发展速度。</p><p>Lambda拉近了Java和Scala的距离，当然他们还是不一样的。Scala之父，MartinOdersky，最近在他的<ahref="https://www.youtube.com/watch?v=NW5h8d_ZyOs">BDSBTB 2015keynote</a>里就提到了Java8集合的状态。</p><p>他把Java的Stream形容成一种很花哨的迭代器。Java8 StreamAPI是一个<em>lifted</em>集合的示例，它所做的就是<em>定义</em>一次计算并在另一个明确的步骤中把它<em>link</em>到一个特定的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// i + 1</span><br>i.prepareForAddition()<br> .add(<span class="hljs-number">1</span>)<br> .mapBackToInteger(Mappers.toInteger())<br></code></pre></td></tr></table></figure><p>这就是新的Java8 StreamAPI的工作机制，它就是一个在人所熟知的Java集合之上的计算层。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;] in Java 8</span><br>Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>      .stream()<br>      .map(Object::toString)<br>      .collect(Collectors.toList())<br></code></pre></td></tr></table></figure><p>Vavr则深受Scala的启发。上面的例子在Java8中本应该是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// = Stream(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;) in Vavr</span><br>Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).map(Object::toString)<br></code></pre></td></tr></table></figure><p>过去一年我们在实现Vavr集合库上面付出了很大的努力，它包含了绝大多数的被广泛使用的集合类型。</p><h3 id="seq">1.5.1. Seq</h3><p>我们通过实现序列类型来开启我们的旅程。在上面我们已经详述了链表，之后的Stream是一个惰性链表。它允许我们处理可能的无限长度的元素序列。</p><figure><img src="/img/vavr-collections-seq.png" alt="collections-seq" /><figcaption aria-hidden="true">collections-seq</figcaption></figure><p>所有集合都是迭代器，因此能够被用在增强型for语句里面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (String s : List.of(<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;Advent&quot;</span>)) &#123;<br>    <span class="hljs-comment">// side effects and mutation</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以通过内部化循环并使用lambda注入行为来达到同样的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List.of(<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;Advent&quot;</span>).forEach(s -&gt; &#123;<br>    <span class="hljs-comment">// side effects and mutation</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>总之，如前所见我们更期望的是返回一个带值的表达式而不是不返回任何东西的语句。通过一个简单的例子，我们马上就能意识到这种语句会带来干扰并且会把一个整体的东西分割开。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">String <span class="hljs-title function_">join</span><span class="hljs-params">(String... words)</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">for</span>(String s : words) &#123;<br>        <span class="hljs-keyword">if</span> (builder.length() &gt; <span class="hljs-number">0</span>) &#123;<br>            builder.append(<span class="hljs-string">&quot;, &quot;</span>);<br>        &#125;<br>        builder.append(s);<br>    &#125;<br>    <span class="hljs-keyword">return</span> builder.toString();<br>&#125;<br></code></pre></td></tr></table></figure><p>Vavr集合提供了很多操作底层元素的函数，这让我们可以用很简洁的方式来表达某些事物：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">String <span class="hljs-title function_">join</span><span class="hljs-params">(String... words)</span> &#123;<br>    <span class="hljs-keyword">return</span> List.of(words)<br>               .intersperse(<span class="hljs-string">&quot;, &quot;</span>)<br>               .foldLeft(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(), StringBuilder::append)<br>               .toString();<br>&#125;<br></code></pre></td></tr></table></figure><p>Vavr可以用各种不同的方式来实现许多目标。在这里我们可以通过缩减整个方法体来使列表实例上的函数调用变得更流畅，甚至可以移除这个方法然后直接用我们的列表来获取计算结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List.of(words).mkString(<span class="hljs-string">&quot;, &quot;</span>);<br></code></pre></td></tr></table></figure><p>在实际应用中我们可以借此大幅减少代码行数，也降低了出现bug的风险。</p><h3 id="set和map">1.5.2. Set和Map</h3><p>序列固然很棒，但就完整性来讲，一个集合库也需要不同类型的Sets和Maps。</p><figure><img src="/img/vavr-collections-set-map.png"alt="collections-set-map" /><figcaption aria-hidden="true">collections-set-map</figcaption></figure><p>我们已经描述过如何通过二叉搜索树为有序集合进行建模，而一个有序的Map也不过是一个包含键值对且对键进行了排序的有序集合。</p><p>HashMap的实现是依赖于<ahref="http://lampwww.epfl.ch/papers/idealhashtrees.pdf">Hash ArrayMapped Trie (HAMT)</a>，对应的HashSet也是依赖于一个包含键键对（key-keypairs）的HAMT。</p><p>我们的Map<em>没有</em>一个特殊的Entry类型来表示键值对，作为替代使用的是Vavr中的Tuple2。一个Tuple<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[多元组](https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%85%83%E7%BB%84)，也称为顺序组（英语：Tuple），泛指有限个元素所组成的序列。在数学及计算机科学分别有其特殊的意义。">[6]</span></a></sup>中的字段总是可枚举的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// = (1, &quot;A&quot;)</span><br>Tuple2&lt;Integer, String&gt; entry = Tuple.of(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>);<br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> entry._1;<br><span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> entry._2;<br></code></pre></td></tr></table></figure><p>Maps和Tuples在Vavr中广泛被应用。把Tuples作为处理多值返回类型的一种通用方式已经是惯例了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// = HashMap((0, List(2, 4)), (1, List(1, 3)))</span><br>List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).groupBy(i -&gt; i % <span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// = List((a, 0), (b, 1), (c, 2))</span><br>List.of(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>).zipWithIndex();<br></code></pre></td></tr></table></figure><p>在Vavr里，我们会通过实现<ahref="https://projecteuler.net/archives">99 EulerProblems</a>来考察以及测试我们的库，这是一个很棒的概念性验证，请不要吝啬给我们的库推送PR。</p><section class="footnotes"><hr><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><ahref="https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98">协变与逆变</a>。<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span><a href="https://en.wikipedia.org/wiki/Mutator_method">mutatormethod</a>。 <a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>查看源码可知，这里是按3、2、1的顺序进行构建的，对整个链表的遍历，则会按照1、2、3的顺序输出，遵循后进先出原则。整个链表遍历顺序的<strong>头节点是1，尾节点是3</strong>。<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4"class="footnote-text"><span>此时的<strong>尾部</strong>不是按链表的遍历顺序，而是按构建链表时的顺序来定义的。<strong>头元素0</strong>会变成新版本链表遍历顺序的头节点。更新后的新版本链表，遍历出来的结果就是0、2、3。<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5"class="footnote-text"><span>这里的集合是指<strong>Set</strong>。<a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><ahref="https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%85%83%E7%BB%84">多元组</a>，也称为顺序组（英语：Tuple），泛指有限个元素所组成的序列。在数学及计算机科学分别有其特殊的意义。<a href="#fnref:6" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>函数式编程</tag>
      
      <tag>vavr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数式编程增强库Vavr初探（一）</title>
    <link href="/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%A2%9E%E5%BC%BA%E5%BA%93vavr%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%A2%9E%E5%BC%BA%E5%BA%93vavr%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><ahref="https://github.com/vavr-io/vavr">Vavr</a>是对Java8（及以上版本）的函数式编程体验的增强库，官方介绍如下：</p><blockquote><p>Vavr is an object-functional language extension to Java 8, which aimsto reduce the lines of code and increase code quality. It providespersistent collections, functional abstractions for error handling,concurrent programming, pattern matching and much more.</p><p>Vavr是对Java8的对象-函数式语言的扩展，目的是减少代码行数并提高代码质量。提供了持久化集合，针对错误处理的函数式抽象，并发编程，模式匹配以及其他更丰富的内容。</p></blockquote><p>本文是翻译自Vavr官方文档中的<ahref="https://docs.vavr.io/#_usage_guide">使用指南</a>部分，会出现一些术语，主要参考维基百科。</p><h1 id="使用指南">3. 使用指南</h1><p>Vavr带来的是对一些最基础类型 —很明显在Java中是缺失的或者（实现地）比较简陋的，精心设计的表征：<code>Tuple</code>，<code>Value</code>和<code>λ</code>。</p><p>在Vavr中，一切（实现）都是基于这三个最基本的构建块（buildingblocks）：</p><p><img src="/img/vavr01.jpeg" /></p><h2 id="多元组1">3.1.多元组<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[多元组](https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%85%83%E7%BB%84)，也称为顺序组（英语：Tuple），泛指有限个元素所组成的序列。在数学及计算机科学分别有其特殊的意义。">[1]</span></a></sup></h2><p>Java里面没有一个针对多元组的整体概念。一个Tuple可以将固定数量的元素组合在一起作为一个整体进行传递。不同于Array或者List，它可以持有不同类型的对象，但同时也是不可变的。</p><p>多元组的类型有Tuple1，Tuple2，Tuple3等等，目前最多支持8个元素。对于一个多元组<code>t</code>，可以通过<code>t._1</code>方法访问它的第一个元素，<code>t._2</code>方法访问第二个，以此类推。</p><h3 id="创建多元组">3.1.1. 创建多元组</h3><p>接下来通过一个示例来演示如何创建一个持有String和Integer两种类型的元素的多元组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// (Java，8)</span><br>Tuple2&lt;String, Integer&gt; java8 = Tuple.of(<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-number">8</span>); ❶<br><br><span class="hljs-comment">// &quot;Java&quot;</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> java8._1; ❷<br><br><span class="hljs-comment">// 8</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> java8._2; ❸<br></code></pre></td></tr></table></figure><p>❶ 通过静态工厂方法<code>Tuple.of()</code>来创建一个多元组。</p><p>❷ 获取这个多元组的第一个元素。</p><p>❸ 获取这个多元组的第二个元素。</p><h3 id="组件映射">3.1.2. 组件映射</h3><p>组件映射就是为多元组的每一个元素执行一个函数，然后返回一个新的多元组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// (vavr, 1)</span><br>Tuple2&lt;String, Integer&gt; that = java8.map(<br>s -&gt; s.substring(<span class="hljs-number">2</span>) + <span class="hljs-string">&quot;vr&quot;</span>,<br>    i -&gt; i / <span class="hljs-number">8</span><br>);<br></code></pre></td></tr></table></figure><h3 id="单映射器映射">3.1.3. 单映射器映射</h3><p>当然，也可以通过一个映射函数来映射一个多元组（中的所有元素）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// (vavr, 1)</span><br>Tuple2&lt;String, Integer&gt; that = java8.map(<br>(s, i) -&gt; Tuple.of(s.substring(<span class="hljs-number">2</span>) + <span class="hljs-string">&quot;vr&quot;</span>, i / <span class="hljs-number">8</span>)<br>);<br></code></pre></td></tr></table></figure><h3 id="多元组变换">3.1.4. 多元组变换</h3><p>根据多元组的内容，变换操作可以得到一个新的类型的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// &quot;vavr 1&quot;</span><br><span class="hljs-type">String</span> <span class="hljs-variable">that</span> <span class="hljs-operator">=</span> java8.apply(<br>(s, i) -&gt; s.substring(<span class="hljs-number">2</span>) + <span class="hljs-string">&quot;vr &quot;</span> + i / <span class="hljs-number">8</span><br>);<br></code></pre></td></tr></table></figure><h2 id="函数">3.2. 函数</h2><p>函数式编程的所有工作都与值有关并能使用函数对值进行变换。Java8仅提供了一个接收单个参数的<code>Function</code>和一个接收两个参数的<code>BiFunction</code>，Vavr则把这个参数上限提高到了8个。这些函数式接口被命名为<code>Function0,Function1,Function2,Function3</code>等以此类推。如果需要能抛出检查异常的函数，则可以使用<code>CheckedFunction1,CheckedFunction2</code>等等。</p><p>下面的lambda表达式创建了一个两数相加的函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// sum.apply(1, 2) = 3</span><br>Function2&lt;Integer, Integer, Integer&gt; sum = (a,b) -&gt; a + b;<br></code></pre></td></tr></table></figure><p>这种实现是对下面这种匿名类实现的简写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Function2&lt;Integer, Integer, Integer&gt; sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function2</span>&lt;Integer, Integer, Integer&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">apply</span><span class="hljs-params">(Integer a, Integer b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当然也可以使用静态工厂方法<code>Function3.of(...)</code>接收任意的方法引用来创建函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Function3&lt;String, String, String, String&gt; function3 =<br>        Function3.of(<span class="hljs-built_in">this</span>::methodWhichAccepts3Parameters);<br></code></pre></td></tr></table></figure><p>实际上，Vavr的函数式接口是针对Java8函数式接口的“类固醇”（意思是增强），也提供了更多的特性如：</p><ul><li>组合（Composition）</li><li>提升（Lifting）</li><li>柯里化（Currying）</li><li>记忆化（Memoization）</li></ul><h3 id="组合">3.2.1. 组合</h3><p>对函数可以进行组合。在数学中，函数组合是指把一个函数应用到另一个函数的结果当中从而产生第三个函数。举个例子，函数<code>f: X → Y</code>和函数<code>g: Y → Z</code>可以组合生成一个新的函数<code>h:g(f(X))</code>就能得到<code>X → Z</code>的映射。</p><p>（要实现组合）可以使用<code>andThen</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Function1&lt;Integer, Integer&gt; plusOne = a -&gt; a + <span class="hljs-number">1</span>;<br>Function1&lt;Integer, Integer&gt; multiplyByTwo = a -&gt; a * <span class="hljs-number">2</span>;<br><br>Function1&lt;Integer, Integer&gt; add1AndMultiplyBy2 = plusOne.andThen(multiplyByTwo);<br><br>then(add1AndMultiplyBy2.apply(<span class="hljs-number">2</span>)).isEqualTo(<span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><p>或者<code>compose</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Function1&lt;Integer, Integer&gt; add1AndMultiplyBy2 = multiplyByTwo.compose(plusOne);<br><br>then(add1AndMultiplyBy2.apply(<span class="hljs-number">2</span>)).isEqualTo(<span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><h3 id="提升">3.2.2. 提升</h3><p>我们可以把一个偏函数<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="偏函数和全函数的定义百科中都对应一个词条：https://en.wikipedia.org/wiki/Partial_function">[2]</span></a></sup>提升为一个返回<code>Option</code>结果的全函数<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="偏函数和全函数的定义百科中都对应一个词条：https://en.wikipedia.org/wiki/Partial_function">[2]</span></a></sup>。<em>偏函数</em>是数学中的术语，一个从X到Y的偏函数就是函数 f: X' →Y，X'是X的某个子集。它通过不强制函数f将X中的每一个元素都映射到Y中对应的元素来概括一个函数f: X →Y的概念。这就意味着偏函数仅适用于某些输入值，如果有非法的输入值调用了函数，那么通常会抛出异常。</p><p>下面的方法<code>divide</code>是一个只接收非零除数的偏函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Function2&lt;Integer, Integer, Integer&gt; divide = (a, b) -&gt; a / b;<br></code></pre></td></tr></table></figure><p>我们可以使用<code>lift</code>方法把<code>divide</code>变成一个可以接受所有输入的全函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Function2&lt;Integer, Integer, Option&lt;Integer&gt;&gt; safeDivide = Function2.lift(divide);<br><br><span class="hljs-comment">// = None</span><br>Option&lt;Integer&gt; i1 = safeDivide.apply(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>); ❶<br><br><span class="hljs-comment">// = Some(2)</span><br>Option&lt;Integer&gt; i2 = safeDivide.apply(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>); ❷<br></code></pre></td></tr></table></figure><p>❶如果使用非法的输入值执行函数，被提升的函数会返回<code>None</code>来替代抛出异常。</p><p>❷如果使用合法的输入值执行函数，被提升的函数会返回<code>Some</code>。</p><p>下面的方法<code>sum</code>是一个只接收正数输入的偏函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> first, <span class="hljs-type">int</span> second)</span> &#123;<br>    <span class="hljs-keyword">if</span> (first &lt; <span class="hljs-number">0</span> || second &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Only positive integers are allowed&quot;</span>); ❶<br>    &#125;<br>    <span class="hljs-keyword">return</span> first + second;<br>&#125;<br></code></pre></td></tr></table></figure><p>❶传入负数，函数<code>sum</code>会抛出<code>IllegalArgumentException</code>。</p><p>我们也可以通过方法引用来提升<code>sum</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Function2&lt;Integer, Integer, Option&lt;Integer&gt;&gt; sum = Function2.lift(<span class="hljs-built_in">this</span>::sum);<br><br><span class="hljs-comment">// = None</span><br>Option&lt;Integer&gt; optionalResult = sum.apply(-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); ❶<br></code></pre></td></tr></table></figure><p>❶被提升的函数会捕捉到<code>IllegalArgumentException</code>并映射成<code>None</code>进行返回。</p><h3 id="偏函数应用partial-application">3.2.3. 偏函数应用（Partialapplication）</h3><p>偏函数应用允许你用一个已有的函数通过固定某些值（指参数值）来派生出一个新的函数。你可以固定一个或者多个参数，而且要固定的参数数量会决定新函数的参数数量，这样<code>新参数数量 = （原参数数量 - 要固定的参数数量）</code>。参数都是从左向右依次绑定的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Function2&lt;Integer, Integer, Integer&gt; sum = (a, b) -&gt; a + b;<br>Function1&lt;Integer, Integer&gt; add2 = sum.apply(<span class="hljs-number">2</span>); ❶<br><br>then(add2.apply(<span class="hljs-number">4</span>)).isEqualTo(<span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><p>❶ 第一个参数<code>a</code>的值被固定为2。</p><p>接下来展示的是一个固定了前3个参数的<code>Function5</code>，返回的是一个<code>Function2</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Function5&lt;Integer, Integer, Integer, Integer, Integer, Integer&gt; sum = (a, b, c, d, e) -&gt; a + b + c + d + e;<br>Function2&lt;Integer, Integer, Integer&gt; add6 = sum.apply(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>); ❶<br><br>then(add6.apply(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>)).isEqualTo(<span class="hljs-number">13</span>);<br></code></pre></td></tr></table></figure><p>❶参数<code>a</code>，<code>b</code>，<code>c</code>的值被分别固定成了2，3，1。</p><p>偏函数应用不同于柯里化，会在接下来的章节中进行讨论。</p><h3 id="柯里化">3.2.4. 柯里化</h3><p>柯里化是一种通过固定其中一个参数的值来部分的应用一个函数的技术，从而得到一个返回<code>Function1</code>的<code>Function1</code>函数。</p><p>当函数<code>Function2</code>被<em>柯里化</em>后，得到的结果和对<code>Function2</code>进行<em>偏函数应用</em>的结果很难区别，因为两者都是一个一元函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Function2&lt;Integer, Integer, Integer&gt; sum = (a, b) -&gt; a + b;<br>Function1&lt;Integer, Integer&gt; add2 = sum.curried().apply(<span class="hljs-number">2</span>); ❶<br><br>then(add2.apply(<span class="hljs-number">4</span>)).isEqualTo(<span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><p>❶ 第一个参数的值被固定为2。</p><p>这时你可能注意到了，除了使用了<code>.curried()</code>方法以外，这部分代码和<ahref="#3.2.3.-偏函数应用（Partial-application）">偏函数应用</a>章节中给出的二元函数的例子是一模一样的。但是，在更多元的函数中，它们之间的区别会变得越来越明显。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Function3&lt;Integer, Integer, Integer, Integer&gt; sum = (a, b, c) -&gt; a + b + c;<br><span class="hljs-keyword">final</span> Function1&lt;Integer, Function1&lt;Integer, Integer&gt;&gt; add2 = sum.curried().apply(<span class="hljs-number">2</span>); ❶<br><br>then(add2.apply(<span class="hljs-number">4</span>).apply(<span class="hljs-number">3</span>)).isEqualTo(<span class="hljs-number">9</span>); ❷<br></code></pre></td></tr></table></figure><p>❶ 注意参数中存在的额外的函数。</p><p>❷除了最后一次调用以外，对<code>apply</code>的进一步调用会返回不同的函数<code>Function1</code>。</p><h3 id="记忆化">3.2.5. 记忆化</h3><p>记忆化是缓存的一种形式。一个有记忆的函数只会执行一次然后（之后的执行）会从缓存中取值进行返回。在下面的示例中，第一次执行会计算得到一个随机数然后在第二次执行时会返回缓存的这个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Function0&lt;Double&gt; hashCache =<br>    Function0.of(Math::random).memoized();<br><br><span class="hljs-type">double</span> <span class="hljs-variable">randomValue1</span> <span class="hljs-operator">=</span> hashCache.apply();<br><span class="hljs-type">double</span> <span class="hljs-variable">randomValue2</span> <span class="hljs-operator">=</span> hashCache.apply();<br><br>then(randomValue1).isEqualTo(randomValue2);<br></code></pre></td></tr></table></figure><h2 id="值">3.3. 值</h2><p>在函数式环境中，我们把值认作是一种<ahref="https://en.wikipedia.org/wiki/Normal_form_(abstract_rewriting)">范式</a>（normalform），一个无法进一步求值的表达式。在Java中我们通过把一个对象的状态设置为final并称它为<ahref="https://en.wikipedia.org/wiki/Immutable_object">不可变对象</a>来表达这种含义。</p><p>Vavr中的函数值则对不可变对象进行了抽象，通过在实例之间共享不可变内存实现了高效的写操作。我们就"免费"实现了线程安全！（共享不可变内存这里我理解为Java中final或staticfinal的变量，天然具备线程安全的特性，无需花费额外的成本。）</p><h3 id="option">3.3.1. Option</h3><p>Option是一个单子<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="在函数式编程中，[单子](https://zh.wikipedia.org/wiki/单子_(函数式编程))（monad）是一种抽象，它允许以泛型方式构造程序。支持它的语言可以使用单子来抽象出程序逻辑需要的[样板代码](https://zh.wikipedia.org/w/index.php?title=样板代码&amp;action=edit&amp;redlink=1)。">[3]</span></a></sup>容器类型，代表着一个可选值。Option的实例要么是<code>Some</code>的实例，要么是<code>None</code>的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// optional *value*, no more nulls</span><br>Option&lt;T&gt; option = Option.of(...);<br></code></pre></td></tr></table></figure><p>如果你在使用了Java中的<code>Optional</code>类后再接触Vavr（中的<code>Option</code>），会发现一个很关键的不同点。在<code>Optional</code>里面，调用<code>.map</code>方法然后使其返回null会得到一个空的<code>Optional</code>。而在Vavr里面，会得到一个<code>Some(null)</code>然后导致<code>NullPointerException</code>。</p><p>使用<code>Optional</code>，在下面的场景中是合理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;String&gt; maybeFoo = Optional.of(<span class="hljs-string">&quot;foo&quot;</span>); ❶<br>then(maybeFoo.get()).isEqualTo(<span class="hljs-string">&quot;foo&quot;</span>);<br>Optional&lt;String&gt; maybeFooBar = maybeFoo.map(s -&gt; (String)<span class="hljs-literal">null</span>) ❷<br>                                       .map(s -&gt; s.toUpperCase() + <span class="hljs-string">&quot;bar&quot;</span>);<br>then(maybeFooBar.isPresent()).isFalse();<br></code></pre></td></tr></table></figure><p>❶ 可选项是<code>Some("foo")</code>。</p><p>❷ 结果选项在这里就变成了空。</p><p>而使用了Vavr的<code>Option</code>，在同样的场景下会返回<code>NullPointerException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Option&lt;String&gt; maybeFoo = Option.of(<span class="hljs-string">&quot;foo&quot;</span>); ❶<br>then(maybeFoo.get()).isEqualTo(<span class="hljs-string">&quot;foo&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>    maybeFoo.map(s -&gt; (String)<span class="hljs-literal">null</span>) ❷<br>            .map(s -&gt; s.toUpperCase() + <span class="hljs-string">&quot;bar&quot;</span>); ❸<br>    Assert.fail();<br>&#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123;<br>    <span class="hljs-comment">// this is clearly not the correct approach</span><br>&#125;<br></code></pre></td></tr></table></figure><p>❶ 可选项是<code>Some("foo")</code>。</p><p>❷ 结果选项在这里会是<code>Some(null)</code>。</p><p>❸在<code>null</code>上去执行<code>s.toUpperCase()</code>的调用（会抛错）。</p><p>看起来Vavr的实现好像违背了一些准则，但实际上并没有，它始终遵循着单子在调用<code>.map</code>时维护计算上下文的要求。对于一个<code>Option</code>而言，这就意味着在<code>Some</code>上调用<code>.map</code>会返回<code>Some</code>，在<code>None</code>上调用<code>.map</code>会返回<code>None</code>。而在上面的Java的<code>Optional</code>例子中，上下文从<code>Some</code>变成了<code>None</code>。</p><p>这样看起来<code>Option</code>好像没什么用，但实际上它会强制你关注可能会出现<code>null</code>的场景并能合理的处理它们而不是在不知不觉中接受了它们，而处理<code>null</code>的合理的方式就是使用<code>flatMap</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Option&lt;String&gt; maybeFoo = Option.of(<span class="hljs-string">&quot;foo&quot;</span>); ❶<br>then(maybeFoo.get()).isEqualTo(<span class="hljs-string">&quot;foo&quot;</span>);<br>Option&lt;String&gt; maybeFooBar = maybeFoo.map(s -&gt; (String) <span class="hljs-literal">null</span>) ❷<br>                                .flatMap(s -&gt; Option.of(s) ❸<br>                                    .map(t -&gt; t.toUpperCase() + <span class="hljs-string">&quot;bar&quot;</span>));<br>then(maybeFooBar.isEmpty()).isTrue();<br></code></pre></td></tr></table></figure><p>❶ 可选项是<code>Some("foo")</code>。</p><p>❷ 结果选项在这里会是<code>Some(null)</code>。</p><p>❸<code>s</code>，在这里它的值是<code>null</code>，会变成<code>None</code>。</p><p>或者，可以把<code>.flatMap</code>直接放到有可能出现<code>null</code>值的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Option&lt;String&gt; maybeFoo = Option.of(<span class="hljs-string">&quot;foo&quot;</span>); ❶<br>then(maybeFoo.get()).isEqualTo(<span class="hljs-string">&quot;foo&quot;</span>);<br>Option&lt;String&gt; maybeFooBar = maybeFoo.flatMap(s -&gt; Option.of((String)<span class="hljs-literal">null</span>)) ❷<br>                                     .map(s -&gt; s.toUpperCase() + <span class="hljs-string">&quot;bar&quot;</span>);<br>then(maybeFooBar.isEmpty()).isTrue();<br></code></pre></td></tr></table></figure><p>❶ 可选项是<code>Some("foo")</code>。</p><p>❷ 结果选项是<code>None</code>。</p><p><ahref="http://blog.vavr.io/the-agonizing-death-of-an-astronaut/">Vavr博客</a>中对此进行了更详细的探讨。</p><h3 id="try">3.3.2. Try</h3><p>Try是一个单子容器类型，表示一次要么返回异常，要么返回计算成功的值的计算。和<code>Either</code>有点类似，但在语义上又有所区别。Try的实例都是<code>Success</code>或者<code>Failure</code>的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// no need to handle exceptions</span><br>Try.of(() -&gt; bunchOfWork()).getOrElse(other);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> io.vavr.API.*;        <span class="hljs-comment">// $, Case, Match</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> io.vavr.Predicates.*; <span class="hljs-comment">// instanceOf</span><br><br><span class="hljs-type">A</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Try.of(<span class="hljs-built_in">this</span>::bunchOfWork)<br>    .recover(x -&gt; Match(x).of(<br>        Case($(instanceOf(Exception_1.class)), t -&gt; somethingWithException(t)),<br>        Case($(instanceOf(Exception_2.class)), t -&gt; somethingWithException(t)),<br>        Case($(instanceOf(Exception_n.class)), t -&gt; somethingWithException(t))<br>    ))<br>    .getOrElse(other);<br></code></pre></td></tr></table></figure><h3 id="lazy">3.3.3. Lazy</h3><p>Lazy是一个单子容器类型，表示一个惰性计算的值。同Supplier相比，Lazy是有记忆的，即它只会执行一次并由此具有了<ahref="https://en.wikipedia.org/wiki/Referential_transparency">引用透明性</a>（一个表达式在程序中可以被它等价的值替换，而不影响结果）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Lazy&lt;Double&gt; lazy = Lazy.of(Math::random);<br>lazy.isEvaluated(); <span class="hljs-comment">// = false</span><br>lazy.get();         <span class="hljs-comment">// = 0.123 (random generated)</span><br>lazy.isEvaluated(); <span class="hljs-comment">// = true</span><br>lazy.get();         <span class="hljs-comment">// = 0.123 (memoized)</span><br></code></pre></td></tr></table></figure><p>你也可以（通过Lazy）创建一个真正的惰性值（只适用于接口（interfaces））：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CharSequence</span> <span class="hljs-variable">chars</span> <span class="hljs-operator">=</span> Lazy.val(() -&gt; <span class="hljs-string">&quot;Yay!&quot;</span>, CharSequence.class); <span class="hljs-comment">// 第二个参数是一个interface</span><br></code></pre></td></tr></table></figure><h3 id="either">3.3.4. Either</h3><p>Either表示的是两种可能类型的值。一个Either只会是Left或者Right。如果一个给定的Either是Right，然后把它投射给Left，那么对Left的操作不会对Right的值有任何影响。同样的，如果一个给定的Either是Left，然后把它投射给Right，那么对Right的操作也不会对Left的值有任何影响。如果Left投射给Left或者Right投射给Right，那么这些操作就会互相产生影响。</p><p>例：一个compute()函数，返回了一个Integer值（成功的情况下）或者返回一个String类型的错误信息（失败的情况下）。按惯例，成功的情况下返回Right，失败的情况下返回Left。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Either&lt;String,Integer&gt; value = compute().right().map(i -&gt; i * <span class="hljs-number">2</span>).toEither();<br></code></pre></td></tr></table></figure><p>如果compute()的结果是Right(1)，value的值就是Right(2)。</p><p>如果compute()的结果是Left("error")，value的值就是Left("error")。</p><h3 id="future">3.3.5. Future</h3><p>Future是一个在某个不确定的时刻才会变得可用的计算结果。它提供的所有操作都是非阻塞的，底层的ExecutorService通常被用做执行异步处理程序，比如onComplete(...)。</p><p>一个Future有两种状态：等待中和已完成。</p><p><strong>等待中：</strong>计算正在进行当中，只有一个处于等待中的future才能被标记为已完成或者已撤销。</p><p><strong>已完成：</strong>计算完成后，返回结果就是成功，返回异常或者被撤销则是失败。</p><p>回调可以在任意时间点上被注册到Future。当Future完成时，这些（回调）动作会被执行。注册到已完成的Future上的动作会被立即执行，它可能会运行在一个独立的线程中，这取决于底层的ExecutorService。而那些注册到被撤销的Future上的动作会带着失败的结果被执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// future *value*, result of an async calculation</span><br>Future&lt;T&gt; future = Future.of(...);<br></code></pre></td></tr></table></figure><h3 id="validation">3.3.6. Validation</h3><p>Validation控件是一个<em>应用式函子</em><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="在函数式编程中，[应用式函子](https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%BC%8F%E5%87%BD%E5%AD%90)，或简称应用式（applicative），是在[函子](https://zh.wikipedia.org/wiki/函子_(函数式编程))和[单子](https://zh.wikipedia.org/wiki/单子_(函数式编程))之间的中间结构。应用式函子允许函子式计算成为序列（不同于平常函子），但是不允许使用前面计算的结果于后续计算的定义之中（不同于单子）。">[4]</span></a></sup>，有助于累积错误。在我们尝试组合单子时，会在第一次遇到错误时短路。但是'Validation'可以继续这个组合过程，并累积所有错误。这在对多个字段做校验时尤其有用，比方说一个web表单，你肯定是想一次请求拿到所有可能遇见的错误，而不是一次一个。</p><p>例：在一个web表单中，有'name'和'age'两个字段，希望（提交后）要么创建一个有效的Person实例，要么返回校验的错误列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">PersonValidator</span> <span class="hljs-variable">personValidator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PersonValidator</span>();<br><br><span class="hljs-comment">// Valid(Person(John Dow, 30))</span><br>Validation&lt;Seq&lt;String&gt;, Person&gt; valid = personValidator.validatePerson(<span class="hljs-string">&quot;John Doe&quot;</span>, <span class="hljs-number">30</span>);<br><br><span class="hljs-comment">// Invalid(List(Name contains invalid characters: &#x27;!4?&#x27;, Age must be greater than 0))</span><br>Validation&lt;Seq&lt;String&gt;, Person&gt; invalid = personValidator.validatePerson(<span class="hljs-string">&quot;John? Doe!4&quot;</span>, -<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><code>Validation.Valid</code>实例包含了一个有效的值，而<code>Validation.Invalid</code>实例则包含了一组校验的错误列表。</p><p>下面的这个校验器就是用来把不同的校验结果合并成一个<code>Validation</code>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonValidator</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">VALID_NAME_CHARS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;[a-zA-Z ]&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_AGE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> Validation&lt;Seq&lt;String&gt;, Person&gt; <span class="hljs-title function_">validatePerson</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-keyword">return</span> Validation.combine(validateName(name), validateAge(age)).ap(Person::<span class="hljs-keyword">new</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Validation&lt;String, String&gt; <span class="hljs-title function_">validateName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">return</span> CharSeq.of(name).replaceAll(VALID_NAME_CHARS, <span class="hljs-string">&quot;&quot;</span>).transform(seq -&gt; seq.isEmpty()<br>                ? Validation.valid(name)<br>                : Validation.invalid(<span class="hljs-string">&quot;Name contains invalid characters: &#x27;&quot;</span><br>                + seq.distinct().sorted() + <span class="hljs-string">&quot;&#x27;&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Validation&lt;String, Integer&gt; <span class="hljs-title function_">validateAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-keyword">return</span> age &lt; MIN_AGE<br>                ? Validation.invalid(<span class="hljs-string">&quot;Age must be at least &quot;</span> + MIN_AGE)<br>                : Validation.valid(age);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如果校验成功，即输入的数据是有效的，那么一个<code>Person</code>实例会根据给定的字段<code>name</code>和<code>age</code>被创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person(&quot;</span> + name + <span class="hljs-string">&quot;, &quot;</span> + age + <span class="hljs-string">&quot;)&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="集合">3.4 集合</h2><p>为了满足函数式编程的要求，即所谓不变性，我们做了大量的工作来为Java设计一个全新的集合库。</p><p>Java中的Stream会将计算拔高到一个不同的层次，然后在另一个显式步骤中把它关联到某个特定的集合。而在Vavr中我们抛弃了所有这些额外的公式化的东西。</p><p>新的集合是基于<ahref="http://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html">java.lang.Iterable</a>（来实现的），所以它们也利用了迭代风格的语法糖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1000 random numbers</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> random : Stream.continually(Math::random).take(<span class="hljs-number">1000</span>)) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><code>TraversableOnce</code>拥有大量实用的函数来操作集合，它的API和<ahref="http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">java.util.stream.Stream</a>类似，但却更加成熟。</p><h3 id="list">3.4.1. List</h3><p>Vavr中的<code>List</code>是一个不可变的链表。（对List的）变种（Mutations）会创建新的实例。大多数操作会在线性时间内执行，产生结果的操作将依次执行。</p><h4 id="java8">Java8</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).stream().reduce((i, j) -&gt; i + j);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).sum();<br></code></pre></td></tr></table></figure><h4 id="vavr">Vavr</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// io.vavr.collection.List</span><br>List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).sum();<br></code></pre></td></tr></table></figure><h3 id="stream">3.4.2. Stream</h3><p><code>io.vavr.collection.Stream</code>的（底层）实现是一个惰性的链表，只有在需要时才会对值进行计算。由于它惰性的特性，大多数操作都会在常数时间内执行。操作通常会处于中间且会在一次遍历中被执行。</p><p>streams最妙的是我们可以用它们来表示（理论上）无限长的序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 2, 4, 6, ...</span><br>Stream.from(<span class="hljs-number">1</span>).filter(i -&gt; i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="性能特点">3.4.3. 性能特点</h3><p>表1. 序列操作的时间复杂度</p><table><thead><tr class="header"><th style="text-align: left;"></th><th style="text-align: left;">head()</th><th style="text-align: left;">tail()</th><th style="text-align: left;">get(int)</th><th style="text-align: left;">update(int, T)</th><th style="text-align: left;">prepend(T)</th><th>append(T)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">Array</td><td style="text-align: left;">const</td><td style="text-align: left;">linear</td><td style="text-align: left;">const</td><td style="text-align: left;">const</td><td style="text-align: left;">linear</td><td>linear</td></tr><tr class="even"><td style="text-align: left;">CharSeq</td><td style="text-align: left;">const</td><td style="text-align: left;">linear</td><td style="text-align: left;">const</td><td style="text-align: left;">linear</td><td style="text-align: left;">linear</td><td>linear</td></tr><tr class="odd"><td style="text-align: left;">Iterator</td><td style="text-align: left;">const</td><td style="text-align: left;">const</td><td style="text-align: left;">—</td><td style="text-align: left;">—</td><td style="text-align: left;">—</td><td>—</td></tr><tr class="even"><td style="text-align: left;">List</td><td style="text-align: left;">const</td><td style="text-align: left;">const</td><td style="text-align: left;">linear</td><td style="text-align: left;">linear</td><td style="text-align: left;">const</td><td>linear</td></tr><tr class="odd"><td style="text-align: left;">Queue</td><td style="text-align: left;">const</td><td style="text-align: left;">const<sup>a</sup></td><td style="text-align: left;">linear</td><td style="text-align: left;">linear</td><td style="text-align: left;">const</td><td>const</td></tr><tr class="even"><td style="text-align: left;">PriorityQueue</td><td style="text-align: left;">log</td><td style="text-align: left;">log</td><td style="text-align: left;">—</td><td style="text-align: left;">—</td><td style="text-align: left;">log</td><td>log</td></tr><tr class="odd"><td style="text-align: left;">Stream</td><td style="text-align: left;">const</td><td style="text-align: left;">const</td><td style="text-align: left;">linear</td><td style="text-align: left;">linear</td><td style="text-align: left;">const<sup>lazy</sup></td><td>const<sup>lazy</sup></td></tr><tr class="even"><td style="text-align: left;">Vector</td><td style="text-align: left;">const<sup>eff</sup></td><td style="text-align: left;">const<sup>eff</sup></td><td style="text-align: left;">const<sup>eff</sup></td><td style="text-align: left;">const<sup>eff</sup></td><td style="text-align: left;">const<sup>eff</sup></td><td>const<sup>eff</sup></td></tr></tbody></table><p>表2. Map/Set操作的时间复杂度</p><table><thead><tr class="header"><th style="text-align: left;"></th><th style="text-align: left;">contains/Key</th><th style="text-align: left;">add/put</th><th style="text-align: left;">remove</th><th style="text-align: left;">min</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">HashMap</td><td style="text-align: left;">const<sup>eff</sup></td><td style="text-align: left;">const<sup>eff</sup></td><td style="text-align: left;">const<sup>eff</sup></td><td style="text-align: left;">linear</td></tr><tr class="even"><td style="text-align: left;">HashSet</td><td style="text-align: left;">const<sup>eff</sup></td><td style="text-align: left;">const<sup>eff</sup></td><td style="text-align: left;">const<sup>eff</sup></td><td style="text-align: left;">linear</td></tr><tr class="odd"><td style="text-align: left;">LinkedHashMap</td><td style="text-align: left;">const<sup>eff</sup></td><td style="text-align: left;">linear</td><td style="text-align: left;">linear</td><td style="text-align: left;">linear</td></tr><tr class="even"><td style="text-align: left;">LinkedHashSet</td><td style="text-align: left;">const<sup>eff</sup></td><td style="text-align: left;">linear</td><td style="text-align: left;">linear</td><td style="text-align: left;">linear</td></tr><tr class="odd"><td style="text-align: left;">Tree</td><td style="text-align: left;">log</td><td style="text-align: left;">log</td><td style="text-align: left;">log</td><td style="text-align: left;">log</td></tr><tr class="even"><td style="text-align: left;">TreeMap</td><td style="text-align: left;">log</td><td style="text-align: left;">log</td><td style="text-align: left;">log</td><td style="text-align: left;">log</td></tr><tr class="odd"><td style="text-align: left;">TreeSet</td><td style="text-align: left;">log</td><td style="text-align: left;">log</td><td style="text-align: left;">log</td><td style="text-align: left;">log</td></tr></tbody></table><p>说明：</p><ul><li>const — 常数时间</li><li>const<sup>a</sup> — 摊还常数时间，少数操作可能开销大一点</li><li>const<sup>eff</sup> —有效常数时间，取决于一些假定比如hash键的分布</li><li>const<sup>lazy</sup> — 惰性常数时间，操作是递延的</li><li>log — 对数时间</li><li>linear — 线性时间</li></ul><h2 id="性质检查5">3.5性质检查<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="Property Checking。">[5]</span></a></sup></h2><p>性质检查（也被称作<ahref="https://en.wikipedia.org/wiki/Property_testing">性质检验</a>）是一个很强有力的手段，可以通过函数式的方式帮助我们测试代码的性质。它基于生成的随机数据，再把这些数据传递给用户定义的检查函数。</p><p>Vavr在其<code>io.vavr:vavr-test</code>模块中有对性质检查的支持，所以在测试中要使用它的话得确保引入了这个模块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Arbitrary&lt;Integer&gt; ints = Arbitrary.integer();<br><br><span class="hljs-comment">// square(int) &gt;= 0: OK, passed 1000 tests.</span><br>Property.def(<span class="hljs-string">&quot;square(int) &gt;= 0&quot;</span>)<br>        .forAll(ints)<br>        .suchThat(i -&gt; i * i &gt;= <span class="hljs-number">0</span>)<br>        .check()<br>        .assertIsSatisfied();<br></code></pre></td></tr></table></figure><p>复杂数据结构的生成器都是由一些简单生成器组成的。</p><h2 id="模式匹配">3.6. 模式匹配</h2><p>Scala天然拥有模式匹配的特性，相对于<em>朴素</em>的Java来说这是一个优点。其基础语法和Java的switch类似：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> s = i <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span> =&gt; <span class="hljs-string">&quot;one&quot;</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span> =&gt; <span class="hljs-string">&quot;two&quot;</span><br>  <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-string">&quot;?&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意<em>match</em>是一个表达式，它会产出一个结果。此外，它还提供了：</p><ul><li>具名参数 <code>case i: Int ⇒ "Int " + i</code></li><li>对象解构 <code>case Some(i) ⇒ i</code></li><li>卫<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="在计算机程序设计中，[卫](https://zh.wikipedia.org/wiki/%E5%8D%AB%E8%AF%AD%E5%8F%A5)（guard）是布尔表达式，其结果必须为真，程序才能执行下去。卫语句（guard code或guard clause）用于检查[先决条件](https://zh.wikipedia.org/wiki/先决条件)。">[7]</span></a></sup><code>case Some(i) if i &gt; 0 ⇒ "positive " + i</code></li><li>多重条件 <code>case "-h" | "--help" ⇒ displayHelp</code></li><li>编译期<em>穷尽</em>检查</li></ul><p>模式匹配是一个很棒的特性。它让我们从一堆if-then-else分支中解放了出来，减少了代码量的同时，也能专注于更有意义的部分。</p><h3 id="java匹配的基础知识">3.6.1. Java匹配的基础知识</h3><p>Vavr提供了一个和Scala的match相似的macthAPI，添加如下的引用可以启用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> io.vavr.API.*;<br></code></pre></td></tr></table></figure><p>它提供了静态方法<em>Match</em>，<em>Case</em>，还有所谓的 <em>atomicpatterns</em>：</p><ul><li><code>$()</code> - 通配符模式</li><li><code>$(value)</code> - 等价模式</li><li><code>$(predicate)</code> - 条件模式</li></ul><p>在（一定的/合理的）范围内，最初Scala的示例可以用如下的方式进行实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> Match(i).of(<br>    Case($(<span class="hljs-number">1</span>), <span class="hljs-string">&quot;one&quot;</span>),<br>    Case($(<span class="hljs-number">2</span>), <span class="hljs-string">&quot;two&quot;</span>),<br>    Case($(), <span class="hljs-string">&quot;?&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><p>⚡我们的方法名（Case）统一使用了大写开头，因为Java中的'case'是一个关键字，这让这个API有点特殊。</p><h4 id="穷尽">穷尽</h4><p>最后那个通配符模式<code>$()</code>能帮我们从抛出的匹配错误中解放出来，如果没有任何分支匹配上的话。由于我们无法像Scala编译器那样执行穷尽检查，所以我们提供了可选结果的返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Option&lt;String&gt; s = Match(i).option(<br>    Case($(<span class="hljs-number">0</span>), <span class="hljs-string">&quot;zero&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><h4 id="语法糖">语法糖</h4><p>如上所述，<code>Case</code>允许匹配条件模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Case($(predicate), ...)<br></code></pre></td></tr></table></figure><p>Vavr提供了一组默认的断言。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> io.vavr.Predicates.*;<br></code></pre></td></tr></table></figure><p>它可以用来实现最初的那个Scala的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> Match(i).of(<br>    Case($(is(<span class="hljs-number">1</span>)), <span class="hljs-string">&quot;one&quot;</span>),<br>    Case($(is(<span class="hljs-number">2</span>)), <span class="hljs-string">&quot;two&quot;</span>),<br>    Case($(), <span class="hljs-string">&quot;?&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><p><strong>多重条件</strong></p><p>可以用<code>isIn</code>的断言来检查多重条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Case($(isIn(<span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;--help&quot;</span>)), ...)<br></code></pre></td></tr></table></figure><p><strong>处理副作用<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="在计算机科学中，[函数副作用](https://zh.wikipedia.org/wiki/%E5%89%AF%E4%BD%9C%E7%94%A8_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))指当调用函数时，除了返回可能的函数值之外，还对主调用函数产生附加的影响。">[6]</span></a></sup></strong></p><p>Match就像一个表达式，它会返回一个值。为了处理副作用我们要用到一个返回<code>Void</code>的辅助函数<code>run</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Match(arg).of(<br>    Case($(isIn(<span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;--help&quot;</span>)), o -&gt; run(<span class="hljs-built_in">this</span>::displayHelp)),<br>    Case($(isIn(<span class="hljs-string">&quot;-v&quot;</span>, <span class="hljs-string">&quot;--version&quot;</span>)), o -&gt; run(<span class="hljs-built_in">this</span>::displayVersion)),<br>    Case($(), o -&gt; run(() -&gt; &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(arg);<br>    &#125;))<br>);<br></code></pre></td></tr></table></figure><p>⚡<code>run</code>用于消除歧义，因为<code>void</code>在Java中不是一个有效的返回值。</p><p><strong>注意：</strong><code>run</code>不能当作直接返回值，也就是不能放到lambda表达式的外面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Wrong!</span><br>Case($(isIn(<span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;--help&quot;</span>)), run(<span class="hljs-built_in">this</span>::displayHelp))<br></code></pre></td></tr></table></figure><p>否则，分支就会在模式匹配命中<em>之前</em>执行，这会导致整个匹配表达式的中断。相反我们应该把它放在lambda表达式里面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Ok</span><br>Case($(isIn(<span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;--help&quot;</span>)), o -&gt; run(<span class="hljs-built_in">this</span>::displayHelp))<br></code></pre></td></tr></table></figure><p>总之，<code>run</code>的使用不当很容易造成错误，一定要小心。我们正考虑可能在之后的某个release版本中把它废弃掉，然后会提供一个更好的API来处理函数副作用。</p><h4 id="具名参数">具名参数</h4><p>Vavr使用了lambda的方式为匹配的值提供了具名参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Number</span> <span class="hljs-variable">plusOne</span> <span class="hljs-operator">=</span> Match(obj).of(<br>    Case($(instanceOf(Integer.class)), i -&gt; i + <span class="hljs-number">1</span>),<br>    Case($(instanceOf(Double.class)), d -&gt; d + <span class="hljs-number">1</span>),<br>    Case($(), o -&gt; &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberFormatException</span>(); &#125;)<br>);<br></code></pre></td></tr></table></figure><p>截止目前，我们都是采用原子模式来做值匹配。如果一个原子模式匹配成功，那么匹配对象的真正类型则是从模式的下文中推断出来的。</p><p>接下来，我们来看看能够匹配（理论上）任意深度的对象图的递归模式。</p><h4 id="对象分解">对象分解</h4><p>Java中使用构造器来实例化类。我们可以把<em>对象分解</em>理解成把对象分解为它的各个部分。</p><p>构造器是一个可以施加参数然后返回新实例的函数，那相应的解构器就是一个接收实例（参数）然后返回某部分的函数。这时我们就说一个对象<em>unapplied</em>。</p><p>对象解构不一定是一个唯一操作。比方说，LocalDate能够被分解成：</p><ul><li>年、月、日组件</li><li>代表对应某个时刻的纪元毫秒的long值</li><li>...</li></ul><h3 id="模式">3.6.2. 模式</h3><p>在Vavr中我们使用模式来描述某个特定类型的实例是如何被解构的。这些模式可以和MatchAPI结合在一起使用。</p><h4 id="预定义的模式">预定义的模式</h4><p>针对Vavr中的很多类型都已经有对应的匹配模式了，可以通过如下方式引入它们：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> io.vavr.Patterns.*;<br></code></pre></td></tr></table></figure><p>比如说我们现在需要匹配一个Try的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Match(_try).of(<br>    Case($Success($()), value -&gt; ...),<br>    Case($Failure($()), x -&gt; ...)<br>);<br></code></pre></td></tr></table></figure><p>⚡ Vavr中第一个雏形MatchAPI是允许从匹配模式中提取用户自定义的对象选择。但是如果没有合适的编译器的支持，这肯定是行不通的，因为生成的方法数量会呈指数级增长。目前的API做出了妥协，即所有模式都匹配，但只有根模式会被<em>分解</em>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Match(_try).of(<br>    Case($Success($Tuple2($(<span class="hljs-string">&quot;a&quot;</span>), $())), tuple2 -&gt; ...),<br>    Case($Failure($(instanceOf(Error.class))), error -&gt; ...)<br>);<br></code></pre></td></tr></table></figure><p>可以看到这里的Success和Failure是根模式，它们被分解成了Tuple2和Error，拥有了正确的泛型类型。</p><p>⚡ 深度嵌套的类型是根据匹配参数而不是匹配模式来推断的。</p><h4 id="用户自定义模式">用户自定义模式</h4><p>能够unapply（即<ahref="#对象分解">对象分解</a>提到的概念）任意对象，包括不可变类的实例，都是至关重要的。Vavr提供了编译期注解<code>@Patterns</code>和<code>@Unapply</code>，以声明式的方式实现了这一点。</p><p>要启用annotation processor，需要项目中依赖<ahref="http://search.maven.org/#search%7Cga%7C1%7Cvavr-match">vavr-match</a>包。</p><p>⚡注：当然我们也可以不通过代码生成器而是直接实现这些模式。想了解有关更多的信息，可以查看生成的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> io.vavr.match.annotation.*;<br><br><span class="hljs-meta">@Patterns</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">My</span> &#123;<br><br>    <span class="hljs-meta">@Unapply</span><br>    <span class="hljs-keyword">static</span> &lt;T&gt; Tuple1&lt;T&gt; <span class="hljs-title function_">Optional</span><span class="hljs-params">(java.util.Optional&lt;T&gt; optional)</span> &#123;<br>        <span class="hljs-keyword">return</span> Tuple.of(optional.orElse(<span class="hljs-literal">null</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>annotationprocessor放了一个文件MyPatterns在同一个包中（默认是在target/generated-sources下面），也支持内部类。</p><p>特殊情况：如果类名是$，那么生成的类名就只是个不带前缀的Patterns。</p><h4id="卫7">卫<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="在计算机程序设计中，[卫](https://zh.wikipedia.org/wiki/%E5%8D%AB%E8%AF%AD%E5%8F%A5)（guard）是布尔表达式，其结果必须为真，程序才能执行下去。卫语句（guard code或guard clause）用于检查[先决条件](https://zh.wikipedia.org/wiki/先决条件)。">[7]</span></a></sup></h4><p>现在我们用<em>卫</em>来实现对Optionals的匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Match(optional).of(<br>    Case($Optional($(v -&gt; v != <span class="hljs-literal">null</span>)), <span class="hljs-string">&quot;defined&quot;</span>),<br>    Case($Optional($(v -&gt; v == <span class="hljs-literal">null</span>)), <span class="hljs-string">&quot;empty&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><p>可以通过实现<code>isNull</code>和<code>isNotNull</code>来简化断言。</p><p>⚡是的，把null提取出来看起来很奇怪对不对。那么来尝试一下Vavr中的Option吧，换掉Java中的Optional！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Match(option).of(<br>    Case($Some($()), <span class="hljs-string">&quot;defined&quot;</span>),<br>    Case($None(), <span class="hljs-string">&quot;empty&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><section class="footnotes"><hr><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><ahref="https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%85%83%E7%BB%84">多元组</a>，也称为顺序组（英语：Tuple），泛指有限个元素所组成的序列。在数学及计算机科学分别有其特殊的意义。<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>偏函数和全函数的定义百科中都对应一个词条：https://en.wikipedia.org/wiki/Partial_function<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>在函数式编程中，<ahref="https://zh.wikipedia.org/wiki/单子_(函数式编程)">单子</a>（monad）是一种抽象，它允许以泛型方式构造程序。支持它的语言可以使用单子来抽象出程序逻辑需要的<ahref="https://zh.wikipedia.org/w/index.php?title=样板代码&amp;action=edit&amp;redlink=1">样板代码</a>。<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>在函数式编程中，<ahref="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%BC%8F%E5%87%BD%E5%AD%90">应用式函子</a>，或简称应用式（applicative），是在<ahref="https://zh.wikipedia.org/wiki/函子_(函数式编程)">函子</a>和<ahref="https://zh.wikipedia.org/wiki/单子_(函数式编程)">单子</a>之间的中间结构。应用式函子允许函子式计算成为序列（不同于平常函子），但是不允许使用前面计算的结果于后续计算的定义之中（不同于单子）。<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>Property Checking。<a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:6" class="footnote-text"><span>在计算机科学中，<ahref="https://zh.wikipedia.org/wiki/%E5%89%AF%E4%BD%9C%E7%94%A8_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">函数副作用</a>指当调用函数时，除了返回可能的函数值之外，还对主调用函数产生附加的影响。<a href="#fnref:6" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:7" class="footnote-text"><span>在计算机程序设计中，<ahref="https://zh.wikipedia.org/wiki/%E5%8D%AB%E8%AF%AD%E5%8F%A5">卫</a>（guard）是布尔表达式，其结果必须为真，程序才能执行下去。卫语句（guardcode或guard clause）用于检查<ahref="https://zh.wikipedia.org/wiki/先决条件">先决条件</a>。<a href="#fnref:7" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>函数式编程</tag>
      
      <tag>vavr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优雅地实现操作日志记录</title>
    <link href="/article/%E4%BC%98%E9%9B%85%E5%9C%B0%E5%AE%9E%E7%8E%B0%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/"/>
    <url>/article/%E4%BC%98%E9%9B%85%E5%9C%B0%E5%AE%9E%E7%8E%B0%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考文章：https://tech.meituan.com/2021/09/16/operational-logbook.html</p></blockquote><h2 id="背景">背景</h2><p>最近看到了美团的这篇<ahref="https://tech.meituan.com/2021/09/16/operational-logbook.html">文章</a>，想起以前学习切面编程时，实现过简单的接口操作日志记录注解，能记录单据类型、操作人、操作时间、操作描述、请求参数等，但是主要的日志数据都是固定写死到注解里面的，那如果有更灵活一些的需求呢？譬如：</p><ul><li>记录业务唯一标识，即<strong>业务单号</strong>，需根据每次请求动态获取；</li><li>操作描述支持<strong>动态参数</strong>填入，支持<strong>动态函数</strong>的执行和替换；</li><li>针对比较多字段编辑的场景，需记录更新前的<strong>原始数据</strong>。</li></ul><p>于是重新实现了一版操作日志注解。至于日志记录的必要性以及简单实现等就不过多赘述，这里重点说一下对于以上几个需求的实现。</p><h2 id="流程">流程</h2><figure><img src="/img/操作日志动态函数注册.png" alt="动态函数注册" /><figcaption aria-hidden="true">动态函数注册</figcaption></figure><figure><img src="/img/操作日志切面解析.png" alt="日志切面解析" /><figcaption aria-hidden="true">日志切面解析</figcaption></figure><h2 id="实现">实现</h2><h3 id="自定义注解">1. 自定义注解</h3><p>先看看日志注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> DataLog &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 单笔数据操作时可指定，SpEL.</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">billId</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 单据类型，所属的业务模块，一般指定为固定值.</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">billType</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 操作描述，支持SpEL模板，支持自定义函数.</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">operationDesc</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询更新操作的原始数据时自定义函数名称，根据billId查询.</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">originalDataFunction</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 自定义函数执行时可选的分表字段值，SpEL.</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">shardingId</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注解里面需要用到SpEL，对于动态获取参数字段值，首选的当然是SpEL表达式语言，简单强大。这里面billId、operationDesc、shardingId都需要从参数中动态取值的，而接口的参数会有两种情况，一种是多个参数，一种是整个对象作为请求body的单个参数。</p><p>注解使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 多个参数值</span><br><span class="hljs-meta">@GetMapping(value = &quot;/query&quot;)</span><br><span class="hljs-meta">@DataLog(billId = &quot;#&#123;#id&#125;&quot;,</span><br><span class="hljs-meta">         shardingId = &quot;#&#123;#id&#125;&quot;,</span><br><span class="hljs-meta">         billType = &quot;test&quot;,</span><br><span class="hljs-meta">         operationDesc = &quot;id为#&#123;#id&#125;. id2为#&#123;#id2&#125;&quot;,</span><br><span class="hljs-meta">         originalDataFunction = &quot;prefix&quot;)</span><br><span class="hljs-keyword">public</span> ResultVO&lt;String&gt; <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;id&quot;)</span> String id, <span class="hljs-meta">@RequestParam(&quot;id2&quot;)</span> String id2)</span> &#123;<br>    <span class="hljs-keyword">return</span> ResultUtils.success(<span class="hljs-string">&quot;success&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 单个对象请求</span><br><span class="hljs-meta">@PostMapping(value = &quot;/post&quot;)</span><br><span class="hljs-meta">@DataLog(billId = &quot;#&#123;id&#125;&quot;,</span><br><span class="hljs-meta">         shardingId = &quot;#&#123;id&#125;&quot;,</span><br><span class="hljs-meta">         billType = &quot;test&quot;,</span><br><span class="hljs-meta">         operationDesc = &quot;id是#&#123;id!=null?id:&#x27;默认值&#x27;&#125;&quot;)</span><br><span class="hljs-keyword">public</span> ResultVO&lt;String&gt; <span class="hljs-title function_">post</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> TestDTO dto)</span> &#123;<br>    <span class="hljs-keyword">return</span> ResultUtils.success(<span class="hljs-string">&quot;success&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>针对多参数的情况，取值的写法看起来有些奇怪，这是因为同时使用了SpEL的<code>StandardEvaluationContext</code>和<code>TemplateParserContext</code>，这样做也是为了能兼容操作描述中的<strong>模板表达式</strong>的写法。</p><h3 id="spel实现动态参数获取">2. SpEL实现动态参数获取</h3><p>核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExpressionParser</span> <span class="hljs-variable">PARSER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpelExpressionParser</span>();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">LocalVariableTableParameterNameDiscoverer</span> <span class="hljs-variable">DISCOVERER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalVariableTableParameterNameDiscoverer</span>();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;StandardEvaluationContext&gt; CONTEXT_THREAD_LOCAL = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">templateParse</span><span class="hljs-params">(String text, Method method, Object[] argsObj)</span> &#123;<br>    String[] parameterNames = DISCOVERER.getParameterNames(method);<br>    <span class="hljs-keyword">if</span> (parameterNames == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> text;<br>    &#125;<br>    <span class="hljs-comment">// 由于存在业务操作执行前后都要进行解析的场景，所以使用ThreadLocal存储上下文的context，避免重复创建</span><br>    <span class="hljs-type">StandardEvaluationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> CONTEXT_THREAD_LOCAL.get();<br>    <span class="hljs-keyword">if</span> (context != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> PARSER.parseExpression(text, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplateParserContext</span>()).getValue(context, String.class);<br>    &#125;<br>    context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StandardEvaluationContext</span>();<br>    <span class="hljs-comment">// 把接口的所有参数都放到context中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; parameterNames.length; i++) &#123;<br>        context.setVariable(parameterNames[i], argsObj[i]);<br>    &#125;<br>    <span class="hljs-comment">// 获取对象中的属性值时，使用第一个参数作为rootObject</span><br>    context.setRootObject(argsObj[<span class="hljs-number">0</span>]);<br>    CONTEXT_THREAD_LOCAL.set(context);<br>    <span class="hljs-comment">// 结合使用`模板`和`标准`的表达式解析</span><br>    <span class="hljs-keyword">return</span> PARSER.parseExpression(text, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplateParserContext</span>()).getValue(context, String.class);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeContext</span><span class="hljs-params">()</span> &#123;<br>    CONTEXT_THREAD_LOCAL.remove();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态函数的执行和替换">3. 动态函数的执行和替换</h3><p>注解使用的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(value = &quot;/post2&quot;)</span><br><span class="hljs-meta">@DataLog(billId = &quot;#&#123;id&#125;&quot;,</span><br><span class="hljs-meta">         shardingId = &quot;#&#123;id&#125;&quot;,</span><br><span class="hljs-meta">         billType = &quot;test&quot;,</span><br><span class="hljs-meta">         operationDesc = &quot;id是#&#123;id!=null?id:&#x27;默认值&#x27;&#125;，自定义动态函数@customeFunction(#&#123;id&#125;,#&#123;name&#125;)&quot;)</span><br><span class="hljs-keyword">public</span> ResultVO&lt;String&gt; <span class="hljs-title function_">post2</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> TestDTO dto)</span> &#123;<br>    List&lt;SnEntity&gt; snEntities = snTestMapper.selectList(Wrappers.lambdaQuery(SnEntity.class));<br>    <span class="hljs-keyword">return</span> ResultUtils.success(snEntities.get(<span class="hljs-number">0</span>).getPeriodName());<br>&#125;<br></code></pre></td></tr></table></figure><p>动态函数的使用主要是在 <strong>操作描述(operationDesc)</strong>中，由于某些场景下需要填充一些动态查询的数据到描述中去，故需要支持。这个地方按照原文的思路来做是可以使用<code>MethodBasedEvaluationContext</code>来实现，而<code>StandardEvaluationContext</code>是<code>MethodBasedEvaluationContext</code>的父类，所以也可以使用<code>StandardEvaluationContext#registerFunction</code>函数来进行注册。但这需要获取目标类的Method信息作为参数，感觉比较麻烦，所以我并没有使用这种方法，而是自定义了函数式接口进行注册，先看看自定义函数以及注册的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 函数式接口，便于实现自定义的逻辑</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IFunction</span>&lt;R&gt; &#123;<br>    <span class="hljs-comment">// 动态入参（这里的设计或许不够好）</span><br>    R <span class="hljs-title function_">apply</span><span class="hljs-params">(String... params)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogParseFunctionFactory</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, IFunction&lt;Object&gt;&gt; FUNCTION_MAP = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">32</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 操作日志自定义函数注册.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> functionName 函数名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> function     函数体</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerFunction</span><span class="hljs-params">(String functionName, IFunction&lt;Object&gt; function)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!FUNCTION_MAP.containsKey(functionName)) &#123;<br>            FUNCTION_MAP.put(functionName, function);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实现与注册逻辑</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceRegistry</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> BizMapper bizMapper;<br>    <br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">initRegistry</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 注册自定义函数，customeFunction对应描述中的函数名称</span><br>        LogParseFunctionFactory.registerFunction(<span class="hljs-string">&quot;customeFunction&quot;</span>, (params) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> bizMapper.query(params[<span class="hljs-number">0</span>]);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解析函数名称、执行函数并进行结果替换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 约定函数声明的格式，形如 @functionName(param0,param1)，其中的param可以通过SpEL进行注入，也可以固定</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> <span class="hljs-variable">AT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;@&#x27;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> <span class="hljs-variable">LEFT_BRACKET</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;(&#x27;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> <span class="hljs-variable">RIGHT_BRACKET</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;)&#x27;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">WHITESPACE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EMPTY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">COMMA</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;,&quot;</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">functionParse</span><span class="hljs-params">(String text)</span> &#123;<br>    <span class="hljs-type">char</span>[] chars = text.toCharArray();<br>    <span class="hljs-comment">// 由于需要对占位的函数进行结果替换，需要新字符串，预先扩展一部分空间，避免循环中不必要的扩容操作。空间换时间</span><br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(text.length() + (text.length() / <span class="hljs-number">2</span>));<br>    <span class="hljs-type">int</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chars.length; i++) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> chars[i];<br>        <span class="hljs-keyword">if</span> (AT != ch) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 解析自定义函数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &lt; chars.length &amp;&amp; chars[j] != LEFT_BRACKET) &#123;<br>            j++;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">funcName</span> <span class="hljs-operator">=</span> doParse(chars, j, i);<br>        <span class="hljs-comment">// 解析函数参数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> j;<br>        <span class="hljs-keyword">while</span> (j &lt; chars.length &amp;&amp; chars[j] != RIGHT_BRACKET) &#123;<br>            j++;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> doParse(chars, j, l);<br>        IFunction&lt;Object&gt; function = LogParseFunctionFactory.FUNCTION_MAP.get(funcName.trim());<br>        <span class="hljs-keyword">if</span> (function == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 替换空白，使用apache lang包的replace方法，性能更佳</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">actualParams</span> <span class="hljs-operator">=</span> StringUtils.replace(params, WHITESPACE, EMPTY);<br>        <span class="hljs-comment">// 执行动态函数</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">funcResult</span> <span class="hljs-operator">=</span> function.apply(actualParams.split(COMMA));<br>        <span class="hljs-comment">// 替换动态函数为执行的结果</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">replacement</span> <span class="hljs-operator">=</span> (funcResult == <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot;&quot;</span> : funcResult.toString());<br>        builder.append(text, offset, i).append(replacement);<br>        offset = j + <span class="hljs-number">1</span>;<br>    &#125;<br>    builder.append(text, offset, text.length());<br>    <span class="hljs-keyword">return</span> builder.toString();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">doParse</span><span class="hljs-params">(<span class="hljs-type">char</span>[] chars, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>    <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[x - <span class="hljs-number">1</span> - y];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; (x - <span class="hljs-number">1</span> - y); k++) &#123;<br>        bytes[k] = (<span class="hljs-type">byte</span>) chars[y + <span class="hljs-number">1</span> + k];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="更新前原始数据的获取">4. 更新前原始数据的获取</h3><p>这里要用到的是注解里面的<code>originalDataFunction</code>字段，函数的注册方式同上，只是在调用的地方不太一样，是在操作执行前调用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用示例</span><br><span class="hljs-meta">@PostMapping(value = &quot;/post&quot;)</span><br><span class="hljs-meta">@DataLog(billId = &quot;#&#123;id&#125;&quot;,</span><br><span class="hljs-meta">         shardingId = &quot;#&#123;id&#125;&quot;,</span><br><span class="hljs-meta">         billType = &quot;test&quot;,</span><br><span class="hljs-meta">         originalDataFunction = &quot;originalFunction&quot;)</span><br><span class="hljs-keyword">public</span> ResultVO&lt;String&gt; <span class="hljs-title function_">post</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> TestDTO dto)</span> &#123;<br>    <span class="hljs-keyword">return</span> ResultUtils.success(<span class="hljs-string">&quot;success&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>解析执行逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 注解获取等</span><br>...<br><span class="hljs-type">String</span> <span class="hljs-variable">originalData</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 判断是否指定了自定义函数且单号必须指定</span><br><span class="hljs-keyword">if</span> (StrUtil.isNotBlank(logHandler.originalDataFunction) &amp;&amp; StrUtil.isNotBlank(logHandler.billId)) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">finalBillId</span> <span class="hljs-operator">=</span> ExpressionHandler.templateParse(logHandler.billId, logHandler.method, argsObj);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">shardingId</span> <span class="hljs-operator">=</span> ExpressionHandler.templateParse(logHandler.shardingId, logHandler.method, argsObj);<br>        <span class="hljs-comment">// 自定义函数查询原始数据，也是用的上面的函数注册方法</span><br>        IFunction&lt;Object&gt; function = LogParseFunctionFactory.FUNCTION_MAP.get(logHandler.originalDataFunction);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">originalDataObject</span> <span class="hljs-operator">=</span> Optional.ofNullable(function)<br>            .map(f -&gt; f.apply(finalBillId, shardingId))<br>            .orElse(<span class="hljs-literal">null</span>);<br>        originalData = JsonSerializer.serialize(originalDataObject);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        Log.warn(ex, <span class="hljs-string">&quot;日志内容补充originalData失败&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 业务操作</span><br>    <span class="hljs-keyword">return</span> (result = joinPoint.proceed());<br>&#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>    <span class="hljs-comment">// 异常处理，记录错误信息</span><br>    ...<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 同步解析注解上的其他值，最终再交给线程池异步写入数据库，这里没有把解析处理的逻辑也异步化</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>但是由于原始数据一般都是全量的整条数据，会造成日志表的数据膨胀，且必须在操作前查询，也会影响接口性能，所以需要慎用。</p><h2 id="可能的优化点">可能的优化点</h2><p>上面的SpEL解析代码中使用到了<code>ThreadLocal</code>，目前<strong>解析注解是同步处理</strong>，写数据才进入到<strong>线程池异步写</strong>，虽然实测性能问题不大，但是这里可以扩展优化一下，把解析注解值的过程也搬到线程池中去，这里就涉及到如何在线程池异步的场景下使用<code>ThreadLocal</code>？答案是阿里开源的<ahref="https://github.com/alibaba/transmittable-thread-local"><code>TransmittableThreadLocal</code></a>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>SpEL</tag>
      
      <tag>函数式接口</tag>
      
      <tag>ThreadLocal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>敏感词检测算法 - DFA</title>
    <link href="/article/%E6%95%8F%E6%84%9F%E8%AF%8D%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95-DFA/"/>
    <url>/article/%E6%95%8F%E6%84%9F%E8%AF%8D%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95-DFA/</url>
    
    <content type="html"><![CDATA[<p>之前在系统中开发过一个敏感词检测的功能，最开始我很快完成了功能的设计开发：</p><ul><li>敏感词库：存储所有敏感词的数据库表；</li><li>校验：查出所有敏感词集合，在循环中使用<code>String.contains()</code>方法在目标串中进行敏感词查找，找到后抛出异常提示；</li><li>预加载：敏感词集合不用每次都查数据库，可以提前加载缓存到内存，数据量也并不大。</li></ul><p>但是使用<strong>暴力匹配算法</strong>未免简陋了点，于是便上网查找了下，果然还有更优的解决方案。这里我们先分析下<code>String</code>类的<code>contains</code>方法，即<code>indexOf()</code>方法的实现。</p><h2 id="bf算法">BF算法</h2><blockquote><p>BF算法，即暴力(BruteForce)算法，是普通的模式匹配算法，BF算法的思想就是将目标串S的第一个字符与模式串T的第一个字符进行匹配，若相等，则继续比较S的第二个字符和T的第二个字符；若不相等，则比较S的第二个字符和T的第一个字符，依次比较下去，直到得出最后的匹配结果。BF算法是一种蛮力算法。-- 百度百科</p></blockquote><p>直接看<code>indexOf()</code>方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * source：来源串（输入的文本），target：模式串（敏感词）.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(<span class="hljs-type">char</span>[] source, <span class="hljs-type">int</span> sourceOffset, <span class="hljs-type">int</span> sourceCount,</span><br><span class="hljs-params">            <span class="hljs-type">char</span>[] target, <span class="hljs-type">int</span> targetOffset, <span class="hljs-type">int</span> targetCount,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> fromIndex)</span> &#123;<br>        <span class="hljs-keyword">if</span> (fromIndex &gt;= sourceCount) &#123;<br>            <span class="hljs-keyword">return</span> (targetCount == <span class="hljs-number">0</span> ? sourceCount : -<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (fromIndex &lt; <span class="hljs-number">0</span>) &#123;<br>            fromIndex = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (targetCount == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> fromIndex;<br>        &#125;<br><span class="hljs-comment">// 取敏感词的第一个字符</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> target[targetOffset];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> sourceOffset + (sourceCount - targetCount);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> sourceOffset + fromIndex; i &lt;= max; i++) &#123;<br>            <span class="hljs-comment">/* Look for first character. */</span><br>    <span class="hljs-comment">// 从输入文本中找到匹配敏感词第一个字符的字符</span><br>            <span class="hljs-keyword">if</span> (source[i] != first) &#123;<br>                <span class="hljs-keyword">while</span> (++i &lt;= max &amp;&amp; source[i] != first);<br>            &#125;<br><br>            <span class="hljs-comment">/* Found first character, now look at the rest of v2 */</span><br>    <span class="hljs-comment">// 匹配到了第一个字符，继续向后匹配</span><br>            <span class="hljs-keyword">if</span> (i &lt;= max) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> j + targetCount - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> targetOffset + <span class="hljs-number">1</span>; j &lt; end &amp;&amp;<br>    <span class="hljs-comment">// 输入文本中的下一个字符是否与敏感词中的第二个字符相等，是则继续匹配</span><br>    <span class="hljs-comment">// 否则终止匹配，从文本的下一个字符开始重新匹配</span><br>                     source[j] == target[k]; j++, k++);<br>              <br>              <span class="hljs-comment">// j == end 说明上面这个循环走完了，即文本中完整的匹配到了敏感词，返回匹配的第一个字符处的index，代表成功</span><br>                <span class="hljs-keyword">if</span> (j == end) &#123;<br>                    <span class="hljs-comment">/* Found whole string. */</span><br>                    <span class="hljs-keyword">return</span> i - sourceOffset;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>记source的长度为N，target的长度为M，该算法在最坏的情况下，单个敏感词匹配需要的比较次数为M* (N - M + 1)，表示target在source的最后一段才匹配到，即时间复杂度为O(M *N)，而要检测整个敏感词库（词库总数记为S）复杂度就变为<strong>O(S * M *N)</strong>，效率太低。</p><h2 id="dfa">DFA</h2><blockquote><p>具体实现源码主要参考了这篇文章：https://houbb.github.io/2020/01/07/sensitive-word-dfa</p></blockquote><p>DFA 即 Deterministic FiniteAutomaton，就是<strong>确定有穷自动机</strong>。百科的描述比较抽象，主要是借助一张图来看：</p><figure><img src="/img/DFA.png" alt="DFA" /><figcaption aria-hidden="true">DFA</figcaption></figure><p>大写字母是状态，小写字母是动作，初始状态是S，终止状态是Q。通过状态 +动作可以实现各种状态的转换，如下表：</p><table><thead><tr class="header"><th style="text-align: center;">状态</th><th style="text-align: center;">a</th><th style="text-align: center;">b</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">S</td><td style="text-align: center;">U</td><td style="text-align: center;">V</td></tr><tr class="even"><td style="text-align: center;">U</td><td style="text-align: center;">Q</td><td style="text-align: center;">V</td></tr><tr class="odd"><td style="text-align: center;">V</td><td style="text-align: center;">U</td><td style="text-align: center;">Q</td></tr><tr class="even"><td style="text-align: center;">Q</td><td style="text-align: center;">Q</td><td style="text-align: center;">Q</td></tr></tbody></table><p>而实现敏感词检测的关键就在于将敏感词构建成一个这样的状态图，通常是利用Trie字典树来实现。如下图：</p><blockquote><p>利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较。</p></blockquote><figure><img src="/img/敏感词Trie树.png" alt="敏感词Trie树" /><figcaption aria-hidden="true">敏感词Trie树</figcaption></figure><p>将敏感词库中的词构建成一棵棵字典树，每个节点即表示敏感词中的一个字符，那么从输入文本的第一个字符开始在Trie树上查找，即可实现敏感词的检测。Java中的实现我查了下基本都是利用<code>HashMap</code>来做的，构建完成后呈如下结构：</p><figure><img src="/img/HashMap实现Trie树.png" alt="HashMap实现Trie树" /><figcaption aria-hidden="true">HashMap实现Trie树</figcaption></figure><p>这样就把整个敏感词库构建出来了，只需要遍历一次输入的文本，就可以匹配出所有的敏感词，复杂度为<strong>O(N*M)</strong>，效率相对高了许多。当然，这是以空间换来的，不过现在的服务器资源都比较充足，大部分系统敏感词库的大小也不会太大，是可以接受的。</p><h2 id="小结">小结</h2><p>Trie树除了Hash结构的实现，还有其它数据结构的实现，有待研究。</p><blockquote><p>双数组Trie树：https://www.cnblogs.com/en-heng/p/6265256.html。</p></blockquote><p>目前只是利用DFA的思想实现了最简单基础的敏感词匹配，如果还涉及到组合敏感词、拼音敏感词等等，那就需要更复杂的算法来实现，最近刚好看到一篇文章，先记录下来。</p><blockquote><p>vivo敏感词匹配系统的设计与实现：https://mp.weixin.qq.com/s/ZPqwK5wYg09vsGrluRmNZA</p></blockquote><p>除了实现字符串匹配外，DFA也用于一些其它的场景。还有就是与之相反的NFA- 不确定的有穷自动机，也可以了解学习一下。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法，DFA</tag>
      
      <tag>状态机</tag>
      
      <tag>敏感词检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>性能优化实践小记</title>
    <link href="/article/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5%E5%B0%8F%E8%AE%B0/"/>
    <url>/article/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="背景">背景</h1><p>最近项目里面做了一个分享助力排名中奖的活动，对性能有一定的要求，其实也不高，就100~200TPS左右。但是几个周赶出来的项目设计和实现问题都很多，追求快速完成功能，到性能测试这一步就卡住了，于是就有了这次性能优化之旅。</p><h1 id="三个方向">三个方向</h1><h2 id="一数据库">一、数据库</h2><p>首先当然是数据库表设计，使用的是MySQL数据库，主要是表索引以及尽量简单的查询。由于本次我们的业务比较简单，主要涉及几个表：</p><ul><li>用户参与记录表：哪些用户参与了我们的活动</li><li>用户分享助力关系表：用户之间互相助力的关系记录</li><li>用户被助力次数表：主要用于最终的用户助力次数排行的统计</li></ul><p>这些表的查询相对简单，基本都是按照用户ID（Long）查询相关数据，所以在表查询这块的优化空间并不大。</p><p>然后就是MySQL集群模式，我们采用的是MySQL 8.0 官方推荐的MGR（MySQLGroup Replication）模式，问题不大。</p><h2 id="二代码设计与中间件">二、代码设计与中间件</h2><p>这块的问题是比较多，也是主要需要记录的。因为初期为了赶工，很多地方的设计都是简单粗暴的实现功能，所以这一块是优化的重点。</p><h3 id="引入webflux">1. 引入WebFlux</h3><p>助力相关接口采用WebFlux包装，利用其<strong>异步响应式</strong>的设计提高吞吐量，但效果并不明显，因为我们的并发量也不高，仅作为尝试。</p><h3 id="利用mq解耦削峰">2. 利用MQ解耦削峰</h3><p><strong>点击助力</strong>这个接口可以预见是并发最高的接口，里面主要包含几个步骤：</p><ol type="1"><li>记录A用户给B用户助力；</li><li>记录B用户的被助力次数；</li><li>更新助力次数排行榜：注意的是，如果是直接利用数据库查询排行榜，就没有这个步骤了。但是我这里使用了Redis实现，所以多了一个步骤。</li></ol><p>前两个操作都是<strong>写库操作</strong>，势必要使用事务保证整个操作的原子性，但遇到的问题是，直接使用Spring的本地事务在测试时TPS一直上不去，猜测可能是跟我们在测试环境进行性能测试，一套数据库集群几十个项目在使用有关系。</p><p>由于这个问题比较难定位，时间又紧迫，所以只能从代码层面去优化，主要是引入了RocketMQ，利用其<strong>可靠消息保证最终一致性的分布式事务</strong>来解耦这几个操作：</p><ol type="1"><li><p>接口只做一次写库操作，就是记录A用户给B用户助力。</p></li><li><p>向MQ发送一条<strong>事务消息</strong>，用于记录B用户被助力的次数以及更新助力排行榜。</p></li></ol><p>要注意两个点：</p><ol type="1"><li>需要利用RocketMQ的事务消息机制，先发送prepare消息，再写库，再commitor rollback给MQ。这时Spring的本地事务就可以去掉；</li><li>消费消息时需要针对单个用户加分布式锁，因为服务都是多pod/实例部署，同一个用户的多次助力，可能被不同的实例所消费，为保证数据库记录数据的准确性，需要加锁。这个地方并没有性能要求，更多的是要关注数据的准确与否。</li></ol><p>这里主要是利用MQ的异步、解耦、削峰的特性，来实现对高并发下的接口写操作的分离和快速响应。虽然排行榜的更新有一定的延时（毫秒级或者秒级），但是用户感知不大且不是特别关心，因为助力操作本来就是在分享之后的某个不确定时间点发生的，除了系统需要记录精确的时间点以外，用户更关心的是最终的助力数是否正确。</p><h3 id="redis实现排行榜">3. Redis实现排行榜</h3><p>排行榜的查询，最开始是直接利用MySQL的<strong>order by + <spanclass="citation"data-cites="变量">@变量</span></strong>的方式实现排名和排名序号的递增。但是这样的实现在数据量稍大后，性能急速下降，SQL也比较复杂，后面对其重新设计，利用Redis的<strong>ZSet</strong>来实现排行榜的功能：</p><ul><li>ZSet的value是用户ID，<strong>（初始设计）score是被助力次数</strong>，次数越多，排名越高；</li><li>利用ZSet的<code>zrangebyscore</code>取前10名即可实现排行榜的查询；</li><li>排行榜的更新在MQ消费后向ZSet<code>add</code>即可，因为此命令既可以添加一个新的value，也可以对已经存在的value进行更新。且每消费一条MQ消息即表示某一个用户有一次助力产生，score默认+1即可。</li></ul><p>这里出现了一个很有意思的问题，那就是<strong>如果两个人是相同的助力次数，排名怎么算</strong>？如果都在或者都不在中奖区间以内，那么谁前谁后都无所谓。但是一旦区间的边缘出现两个助力次数一样的排名，一个中奖一个没有中奖，那么就要必须有合理的解释。</p><p>按照正常生活中的逻辑来说，应该是先达到某一助力次数的用户排在前面，即<strong>先到先得</strong>。但是按上面的实现，从ZSet里面取排名时，助力次数（score）相同的情况下，是按照先参加活动的用户排在前面，即先进入ZSet的value排在前面，这是我实际观察得到的结果。这个取值逻辑在程序里面肯定没有问题，但却不符合此时的业务逻辑。</p><p>经过上面的分析，可以看出score需要跟时间挂钩，但如果score直接加上时间戳，那么就是后到先得，不符合我们的逻辑。所以我们可以换一种思路：<strong>Java时间精度默认是毫秒，目前生成的时间戳是13位。所以可以用某个14位数字（未来的某一个时间戳）减去当前的时间戳，再以得到的数字作为小数，助力次数作为整数，就成为了最终的score。</strong></p><p><span class="math inline">\(score = n.(x - y)\)</span><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="score为一个double数，整数部分为助力次数，小数部分为逆向时间戳。这样助力次数越多，自然score越大，助力次数相同的情况下，小数越大排的越靠前。">[1]</span></a></sup></p><p><strong>x</strong> 为某14位数字，我取的是10 000 000 000000，代表的是未来的<em>2286-11-2101:46:40.000</em>这一刻，这个时间点已经大大超出目前绝大部软件系统的生命周期，因此可以认为它是一个常数。<strong>y</strong>即助力那一刻的时间戳。<strong>n</strong> 是助力次数。</p><p><strong>(x -y)得到的是一个逆向时间戳，在助力数n相同的情况下，助力越早，时间戳越小，逆向时间戳越大，最终的score就越大，排名就越靠前。</strong>完美实现了我们想要的效果，先到先得。</p><h3 id="预加载压缩缓存">4. 预加载、压缩、缓存</h3><p>除了助力以外，这次活动还有一个比较麻烦的点在于<strong>分享二维码的生成</strong>。由于我们前端是微信小程序，微信的小程序码接口又只能在服务器端请求且返回的是一个图片Buffer（每个二维码大约110kb左右），所以去实时生成二维码不但需要多次网络IO，返回的数据量也较大，显然达不到性能要求。</p><blockquote><p><ahref="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html">小程序码&gt; wxacode.getUnlimited</a></p></blockquote><p>所以针对二维码的优化，主要是从三个方面来进行的：</p><ol type="1"><li><p><strong>预加载</strong></p><p>二维码是一次生成，永久可用，可以利用前端页面逻辑的顺序性，当用户在分享二维码页面之前的某个页面时，提前通知后端进行预生成，并存储起来。</p></li><li><p><strong>缓存</strong></p><p>存储时使用到的是Redis和OSS，依据前端的需求有两种方式：</p><ul><li>直接存储Base64格式的数据到Redis，接口返回的也是Base64的字符串。</li><li>将Base64转化为png文件上传到OSS，再把链接存储在Redis，返回给前端这个链接地址。</li></ul></li><li><p><strong>压缩</strong></p><p>主要是针对第一种存储方式，一个二维码图片Buffer大约是110kb左右，我们测试的用户数据是10w，如果原始数据直接缓存到Redis中，那么将占用：110(kb)×100000÷1024÷1024≈10(gb)左右的缓存空间，这显然不合理。</p><p>所以便想到了压缩后再进缓存，但必须得保证二维码的清晰程度。经过实际测试，压缩到20kb左右可以兼顾清晰度和空间利用效率，这时只需占用约1.9gb缓存空间，这样一个占用相对来说就可以接受了。而且这只是测试预估的最大值，实际生产环境中参与活动的用户数远没有达到这个数量，只有一半左右。</p></li></ol><p>长远来看，在面对更大体量的数据时，压缩也不好使，还是应该预加载 + OSS+ Redis最佳。</p><h2 id="三参数调优">三、参数调优</h2><p>这一块主要是JVM和Web容器的参数调优，我们实际生产环境的单个pod资源限制标准为2C4G。</p><ol type="1"><li><p><strong>JVM</strong></p><p>主要是以下几个参数，比较通用简单。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-XX:+UseG1GC 使用G1垃圾收集器</span><br><span class="hljs-deletion">-Xms4000m    初始化JVM内存，可以设置的和最大内存一致，避免每次GC后JVM重新分配内存以及扩容带来的影响</span><br><span class="hljs-deletion">-Xmx4000m    最大JVM可用内存</span><br><span class="hljs-deletion">-XX:MaxGCPauseMillis=100  设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Web容器</strong></p><p>我们项目使用的是Undertow而不是Tomcat，从网上找了一些通用的参数调整。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># undertow配置</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">undertow:</span><br>    <span class="hljs-comment"># 设置IO线程数, 它主要执行非阻塞的任务,它们会负责多个连接, 默认设置每个CPU核心一个线程</span><br>    <span class="hljs-comment"># 不要设置过大，如果过大，启动项目会报错：打开文件数过多</span><br>    <span class="hljs-attr">io-threads:</span> <span class="hljs-number">16</span><br>    <span class="hljs-comment"># 阻塞任务线程池, 当执行类似servlet请求阻塞IO操作, undertow会从这个线程池中取得线程</span><br>    <span class="hljs-comment"># 它的值设置取决于系统线程执行任务的阻塞系数，默认值是IO线程数*8</span><br>    <span class="hljs-attr">worker-threads:</span> <span class="hljs-number">256</span><br>    <span class="hljs-comment"># 以下的配置会影响buffer,这些buffer会用于服务器连接的IO操作,有点类似netty的池化内存管理</span><br>    <span class="hljs-comment"># 每块buffer的空间大小,越小的空间被利用越充分，不要设置太大，以免影响其他应用，合适即可</span><br>    <span class="hljs-attr">buffer-size:</span> <span class="hljs-number">1024</span><br>    <span class="hljs-comment"># 是否分配的直接内存(NIO直接分配的堆外内存)</span><br>    <span class="hljs-attr">direct-buffers:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="结果">结果</h1><p>由于请求链路上还有网关与用户鉴权中心的存在，所以我们也分为了两种情况进行测试，走网关和不走网关，用来定位和排除一些应用服务的问题。当然，最终结果是以真实环境的网络链路为标准的，也就是走网关路由和鉴权。</p><p>按照测试部门的要求，使用的工具是Jmeter，几个核心接口线程组的线程数设置为100，永久循环持续5分钟。测试环境开启两个pod，单个pod资源限制2C4G。但是测试环境的数据库集群是多个项目共用的，所以数据库的读写性能在不同时间段测试时表现波动很大，最终取的是一个比较折中的数据。</p><ul><li>不走网关：写接口的TPS保持在400左右，读接口600 ~ 1000。</li><li>走网关：写接口200左右，读接口300 ~ 400。</li></ul><p>本次性能测试的要求并不高，但是对于个人来说也是挺有意义的一次实践，其中的很多思路还是值得记录下来的。</p><section class="footnotes"><hr><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>score为一个double数，整数部分为助力次数，小数部分为逆向时间戳。这样助力次数越多，自然score越大，助力次数相同的情况下，小数越大排的越靠前。<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>性能优化</tag>
      
      <tag>性能测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo版本升级踩坑记录</title>
    <link href="/article/Dubbo%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <url>/article/Dubbo%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="背景">背景</h2><p>最近我们部门负责基础组件的<ahref="https://github.com/yangyang0507"><strong>大佬</strong></a>准备升级下Dubbo（v2.7.3-&gt;v2.7.8），本以为是一次简单的升级，我们各个服务配合刷新下依赖即可，结果却闹出了一系列的问题：</p><ul><li>RPC中枚举序列化问题：这个我们讨论过，应该要<strong>禁止在RPC调用中直接使用枚举作为字段类型</strong></li><li>Dubbo泛化调用问题：2.7.8版本在泛化调用无参方法时，由于没有对types做非空校验，导致NPE，详情戳☞<a href="https://github.com/apache/dubbo/issues/6840">#6840</a></li><li>项目启动时找不到provider接口提供者：2.7.8版本创建的provider都会带有Group标识，但是之前的版本没有这个标识，导致provider匹配不上报NoProvider错误</li><li><u><strong>与Nacos集成引起系统持续不断的创建大量 nacos.naming线程，导致系统负载持续增加出现崩溃的迹象：这是本次重点记录分析的问题</strong></u></li></ul><h2 id="问题发现">问题发现</h2><p>升级上线一小段时间之后，运维通过监控工具<code>prometheus</code>发现各个服务实例创建了大量的线程，最少都有500+，最多的单个实例更是达到了4000+，明显太不正常了。持续关注了一段时间后发现线程数一直在增加，并没有减少的迹象，遂开始排查问题。</p><h2 id="问题解决">问题解决</h2><p>首先由运维暂时性的定时重启实例来保证服务的正常。</p><p>然后利用<ahref="https://arthas.gitee.io/index.html">Arthas</a>的<code>thread</code>命令：查找最忙的N个线程、阻塞其他线程的线程、指定状态（WAITTING、TIMED_WAITTING等）的线程等等，观察发现有大量的<code>nacos.naming</code>线程。遂去GitHubNacos的issues搜索有没有相关的问题描述，果然<ahref="https://github.com/alibaba/nacos/issues/4491">#4491</a>这个issue跟我们的问题很相似，观察到的线程状态跟他的截图也差不多。</p><p>之后定位到的是Dubbo issue<ahref="https://github.com/apache/dubbo/issues/6988">#6988</a>和 <ahref="https://github.com/apache/dubbo/issues/6568">#6568</a>，源自2.7.7版本的一个bug。之后按照Dubbo2.7.9版本的解决方式编译打包了一个新版本来解决这个问题，注意并没有直接升级Dubbo最新版本，是因为怕再出现一些其它问题。</p><h2 id="问题分析">问题分析</h2><p>由于issue上已经把问题代码指出来并进行了修复，那我们现在根据观察到的线程结合源码来反向追踪到问题代码。</p><p>利用<ahref="https://arthas.gitee.io/index.html">Arthas</a>的<code>thread</code>命令查找到的线程，发现大部分的都是<code>nacos.naming</code>相关线程，譬如：</p><ul><li><code>nacos.client.naming.updater</code>：<code>HostReactor</code>实例的周期任务线程，用来更新本地缓存的服务实例列表的定时任务。</li><li><code>nacos.client.naming.client.listener</code>：<code>EventDispatcher</code>实例的周期任务线程，定时监听服务实例变更的消息（从<code>HostReactor</code>处得知）并分发<code>NamingEvent</code>事件给订阅者。</li><li><code>nacos.client.naming.push.receiver</code>：<code>PushReceiver</code>实例的周期任务线程，开启UDP端口，接收Naocs服务端主动推送的实例节点变动信息，调用<code>HostReactor</code>的相关方法来更新服务实例列表，再做ack响应。</li></ul><p>查看相关源码发现，这些线程都跟<code>NacosNamingService</code>这个类有关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实现了NamingService接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NacosNamingService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NamingService</span> &#123;<br>    ...<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(Properties properties)</span> &#123;<br>        namespace = InitUtils.initNamespaceForNaming(properties);<br>        initServerAddr(properties);<br>        InitUtils.initWebRootContext();<br>        initCacheDir();<br>        initLogName(properties);<br><br>        eventDispatcher = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventDispatcher</span>();<br>  <span class="hljs-comment">// 代理对象，跟注册中心Server相关的请求都走它</span><br>        serverProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NamingProxy</span>(namespace, endpoint, serverList, properties);<br>  <span class="hljs-comment">// 客户端心跳</span><br>        beatReactor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeatReactor</span>(serverProxy, initClientBeatThreadCount(properties));<br>  <span class="hljs-comment">// 客户端实例刷新</span><br>        hostReactor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HostReactor</span>(eventDispatcher, serverProxy, cacheDir, isLoadCacheAtStart(properties),<br>            initPollingThreadCount(properties));<br>    &#125;<br>    ...<br></code></pre></td></tr></table></figure><p>再继续追溯，发现其实例都是由<code>NamingFactory</code>创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NamingFactory</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> NamingService <span class="hljs-title function_">createNamingService</span><span class="hljs-params">(String serverList)</span> <span class="hljs-keyword">throws</span> NacosException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; driverImplClass = Class.forName(<span class="hljs-string">&quot;com.alibaba.nacos.client.naming.NacosNamingService&quot;</span>);<br>            <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> driverImplClass.getConstructor(String.class);<br>            <span class="hljs-type">NamingService</span> <span class="hljs-variable">vendorImpl</span> <span class="hljs-operator">=</span> (NamingService)constructor.newInstance(serverList);<br>            <span class="hljs-keyword">return</span> vendorImpl;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NacosException</span>(NacosException.CLIENT_INVALID_PARAM, e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 最终是这个方法被调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> NamingService <span class="hljs-title function_">createNamingService</span><span class="hljs-params">(Properties properties)</span> <span class="hljs-keyword">throws</span> NacosException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; driverImplClass = Class.forName(<span class="hljs-string">&quot;com.alibaba.nacos.client.naming.NacosNamingService&quot;</span>);<br>            <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> driverImplClass.getConstructor(Properties.class);<br>            <span class="hljs-type">NamingService</span> <span class="hljs-variable">vendorImpl</span> <span class="hljs-operator">=</span> (NamingService)constructor.newInstance(properties);<br>            <span class="hljs-keyword">return</span> vendorImpl;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NacosException</span>(NacosException.CLIENT_INVALID_PARAM, e);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NacosFactory</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Create naming service</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> properties init param</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Naming</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NacosException Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 此方法被外部所调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> NamingService <span class="hljs-title function_">createNamingService</span><span class="hljs-params">(Properties properties)</span> <span class="hljs-keyword">throws</span> NacosException &#123;<br>        <span class="hljs-keyword">return</span> NamingFactory.createNamingService(properties);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个方法被两个地方调用到，一个是<code>NacosDiscoveryProperties</code>，一个是<code>NacosNamingServiceUtils</code>。但由于此次问题是由于Dubbo升级导致的，所以最后的调用方可以不用关心前者，它是Nacos注册发现相关的调用。</p><p>继续查看<code>NacosNamingServiceUtils</code>的调用链，最后定位到了问题代码<code>NacosRegistryFactory#createRegistryCacheKey</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建NacosRegistry对象的工厂，NacosRegistry就是Dubbo集成Nacos的注册类，通过它从Nacos上拉取、注册、移除服务实例，</span><br><span class="hljs-comment">// 最终是通过NacosNamingService来实现的，所以每一个NacosRegistry对象都会持有一个NamingService的对象。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NacosRegistryFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractRegistryFactory</span> &#123;<br><br>  <span class="hljs-comment">// 这个方法就是产生问题的方法代码</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> String <span class="hljs-title function_">createRegistryCacheKey</span><span class="hljs-params">(URL url)</span> &#123;<br>      <span class="hljs-comment">/** 问题代码中是没有这一段注释代码的，直接返回了 url.toFullString()</span><br><span class="hljs-comment">        String namespace = url.getParameter(CONFIG_NAMESPACE_KEY);</span><br><span class="hljs-comment">        // 重点一：这一个url.toServiceStringWithoutResolving()方法是没有拼接parameter的</span><br><span class="hljs-comment">        // 也就是说新的url指向的是一个基础protocol+host+port的字符串，相当于移除了多余的参数（传入的URL中是包含其它参数的）。</span><br><span class="hljs-comment">        url = URL.valueOf(url.toServiceStringWithoutResolving());</span><br><span class="hljs-comment">        if (StringUtils.isNotEmpty(namespace)) &#123;</span><br><span class="hljs-comment">            // 如果有namespace则添加为新url的参数</span><br><span class="hljs-comment">            url = url.addParameter(CONFIG_NAMESPACE_KEY, namespace);</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">      */</span><br><br>      <span class="hljs-comment">// 这个方法拼接了URL的完整路径：protocol(+username+password)+host+port+servicekey+其它parameters</span><br>      <span class="hljs-comment">// 上面这段修复代码加上了之后，这个时候parameters其实里面只有namespace一个参数了。</span><br>        <span class="hljs-keyword">return</span> url.toFullString();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Registry <span class="hljs-title function_">createRegistry</span><span class="hljs-params">(URL url)</span> &#123;<br>      <span class="hljs-comment">// 这个地方调用到了创建NamingService实例的方法，可以看出是跟NacosRegistry实例关联的</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NacosRegistry</span>(url, createNamingService(url));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 父类 AbstractRegistryFactory</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractRegistryFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RegistryFactory</span> &#123;<br>  <br>    ...<br>  <br>    <span class="hljs-comment">// 重点二：这个url中包含了其他参数，其中引发bug的就是含有一个timestamp参数，导致缓存未命中，重复大量创建了Registry对象，</span><br>    <span class="hljs-comment">// 进而出现很多的NamingService实例，以及其创建的周期性任务线程。</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Registry <span class="hljs-title function_">getRegistry</span><span class="hljs-params">(URL url)</span> &#123;<br>      <span class="hljs-keyword">if</span> (destroyed.get()) &#123;<br>        LOGGER.warn(<span class="hljs-string">&quot;All registry instances have been destroyed, failed to fetch any instance. &quot;</span> +<br>                    <span class="hljs-string">&quot;Usually, this means no need to try to do unnecessary redundant resource clearance, all registries has been taken care of.&quot;</span>);<br>        <span class="hljs-keyword">return</span> DEFAULT_NOP_REGISTRY;<br>      &#125;<br><br>      url = URLBuilder.from(url)<br>        .setPath(RegistryService.class.getName())<br>        .addParameter(INTERFACE_KEY, RegistryService.class.getName())<br>        .removeParameters(EXPORT_KEY, REFER_KEY)<br>        .build();<br>      <span class="hljs-comment">// 这儿创建一个缓存map的key，避免重复创建 Registry 实例，期望同一个NameSpaceId下的Registry实例只会创建一个（单例）。</span><br>      <span class="hljs-comment">// 但是由于这个方法里面没有将url中的多余参数timestamp移除，导致缓存key未命中重复创建大量的Registry实例。</span><br>      <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> createRegistryCacheKey(url);<br>      <span class="hljs-comment">// Lock the registry access process to ensure a single instance of the registry</span><br>      LOCK.lock();<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> REGISTRIES.get(key);<br>        <span class="hljs-keyword">if</span> (registry != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">return</span> registry;<br>        &#125;<br>        <span class="hljs-comment">//create registry by spi/ioc</span><br>        registry = createRegistry(url);<br>        <span class="hljs-keyword">if</span> (registry == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Can not create registry &quot;</span> + url);<br>        &#125;<br>        REGISTRIES.put(key, registry);<br>        <span class="hljs-keyword">return</span> registry;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// Release the lock</span><br>        LOCK.unlock();<br>      &#125;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>通过Arthas的<code>getstatic</code>命令查看<code>AbstractRegistryFactory</code>的<code>REGISTRIES</code>缓存map中的key，这是我在测试环境获取到的示例：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">[arthas@1]$ getstatic org.apache.dubbo.registry.support.AbstractRegistryFactory REGISTRIES<br>field: REGISTRIES<br>@HashMap[<br>    @String[nacos:<span class="hljs-regexp">//na</span><span class="hljs-keyword">cos</span>-cs.nacos.svc.cluster.local:<span class="hljs-number">8848</span>/DEFAULT_GROUP/org.apache.dubbo.registry.RegistryService?namespace=test-rpc]:@NacosRegistry[nacos:<span class="hljs-regexp">//na</span><span class="hljs-keyword">cos</span>-cs.nacos.svc.cluster.local:<span class="hljs-number">8848</span>/org.apache.dubbo.registry.RegistryService?application=auth-center&amp;dubbo=<span class="hljs-number">2.0</span>.<span class="hljs-number">2</span>&amp;group=DEFAULT_GROUP&amp;id=org.apache.dubbo.config.RegistryConfig<span class="hljs-comment">#0&amp;interface=org.apache.dubbo.registry.RegistryService&amp;namespace=test-rpc&amp;pid=1&amp;qos.enable=false&amp;release=2.7.9&amp;timestamp=1616754580092]</span><br>]<br></code></pre></td></tr></table></figure><p>正确key的组成：</p><p><code>nacos://nacos-cs.nacos.svc.cluster.local:8848/DEFAULT_GROUP/org.apache.dubbo.registry.RegistryService?namespace=test-rpc</code></p><p>源码分析时也参考了这个issue <ahref="https://github.com/apache/dubbo/issues/6568">#6568</a>的debug截图，基本搞清楚了整个问题产生的原因以及解决方式的逻辑。</p><h2 id="小结">小结</h2><p>升级开源基础组件一定要慎重，对于待升级版本的评审还是很重要的，可以预先通过官网、GitHub或者StackOverflow等等调研下相关版本的问题再动手也不迟~</p>]]></content>
    
    
    
    <tags>
      
      <tag>Dubbo</tag>
      
      <tag>Nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并行流引起的MySQL死锁</title>
    <link href="/article/Java%E5%B9%B6%E8%A1%8C%E6%B5%81%E5%BC%95%E8%B5%B7%E7%9A%84MySQL%E6%AD%BB%E9%94%81/"/>
    <url>/article/Java%E5%B9%B6%E8%A1%8C%E6%B5%81%E5%BC%95%E8%B5%B7%E7%9A%84MySQL%E6%AD%BB%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>之前（半年前）有同事在代码中使用<strong>并行流</strong>来操作数据库，基于MySQL5.7版本默认的事务隔离级别<strong>RR（Repeatable Read -可重复读）</strong>，在测试环境中出现了死锁的问题。</p><h2 id="解决方式">解决方式</h2><p>经过同事排查发现是在并发写的情况下触发MySQL的<strong>间隙锁</strong>再引发的死锁，最后把并行流改为串行解决问题，主要是数据量不大没有必要使用并行。</p><h2 id="问题一并行流的使用">问题一、并行流的使用</h2><p>具体分析可以看看这里☞<ahref="https://luckycaesar.github.io/article/%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E5%B9%B6%E8%A1%8C%E6%B5%81/">什么时候使用并行流</a>，翻译至DougLea大神的文章。</p><p>总结来说就是并行流并不一定能提升效率，是和<u>数据量以及流中每个操作的复杂度</u>挂钩的。而且Java底层采用<strong>ForkJoinPool</strong>的方式来实现，并行流的盲目使用反而会带来额外的线程创建的开销，拖慢程序响应速度。</p><h2id="问题二mysql事务隔离级别及读一致性问题分析">问题二、MySQL事务隔离级别及读一致性问题分析</h2><h3 id="事务隔离级别">事务隔离级别</h3><p>MySQL的事务隔离级别主要是为了解决并发事务（基于InnoDB）下的读一致性问题，主要有以下四种：</p><table><thead><tr class="header"><th>隔离级别</th><th>读数据一致性</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr class="odd"><td>未提交读（Read uncommitted）</td><td>最低级别，只能保证不读取物理上损坏的数据</td><td>是</td><td>是</td><td>是</td></tr><tr class="even"><td>已提交读（Read committed，RC）</td><td>语句级</td><td>否</td><td>是</td><td>是</td></tr><tr class="odd"><td>可重复读（Read repeatable，RR）</td><td>事务级</td><td>否</td><td>否</td><td>是</td></tr><tr class="even"><td>可序列化（Serilizable）</td><td>最高级别，事务级</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><ul><li>脏读：事务一读取了事务二未提交的数据（MySQL buffer pool）。</li><li>不可重复读：重点是数据是否被修改。事务一读取数据，事务二对数据进行了修改并提交，事务一再次以同样的条件读取，两次读取的数据不一致。</li><li>幻读：主要是新增or删除操作，重点是数据是否存在。事务一针对某一条件的数据进行读取、修改，然后提交，事务二新增or删除了同样条件的数据，导致事务一提交后发现还存在没有修改到的数据or数据已经不存在。</li></ul><p><u>实际上可能很多业务场景中为了保证数据库吞吐量，对于不可重复读和幻读问题有一定的容忍度，再就是RR级别下扫描的记录都要加锁，而RC级别下扫描过但不匹配的记录不会加锁，或者是先加锁再释放，这对扫描大量数据更新的场景影响很大。</u>所以像阿里云的RDSMySQL的默认隔离级别就调整为RC，而不是RR。</p><h3 id="mvvc行锁间隙锁">MVVC、行锁、间隙锁</h3><p>在MySQL中，读取实际上分为两种：<strong>快照读（官方定义：一致性非锁定读）和当前读</strong>。</p><ul><li><p>快照读：读取的是数据在某一时刻的快照（如果数据行没有发生改变则直接读取），普通的select...where...。<strong>RC和RR级别下默认的读取方式。</strong></p></li><li><p>当前读：始终读取的是最新的数据，如select … lock in sharemode、select … for update、insert、update、delete</p></li></ul><p><strong>MVVC（Multiversion ConcurrencyControl）多版本并发控制</strong>：是通过了乐观锁理论（类似版本号比较）的方式来避免<strong>快照读中的不可重复读和幻读</strong>问题。但InnoDB中实际的实现并不是简单的版本号控制，而是借助了<strong>undolog</strong>。</p><ol type="1"><li><p>修改前的数据会存放于undolog，通过一个滚动指针关联，就是保存了一份之前版本的数据，也是为了事务的回滚操作；</p></li><li><p>每行数据有一个<strong>事务标识符 -TRX_ID</strong>（插入或更新该行的最后一个事务的标识符），通过对比数据行最新的事务ID和当前事务的ID来判断当前事务是直接读取该行数据还是读取undolog中对当前事务可见的版本数据。</p></li></ol><p>由于读取的数据要么是没被修改的，要么是历史版本的，所以在快照读的情况下不会出现不可重复读和幻读问题，但可能读取到过时的数据。</p><p><strong>行锁 + 间隙锁</strong>：组合起来就叫Next-KeyLock，主要是为了解决<strong>RR级别当前读的情况下出现的不可重复读和幻读</strong>问题。</p><ul><li>行锁（记录锁，RecordLock）：排他锁，直接加在索引记录（key）上，事务对数据修改时加行锁，保证可重复读。</li><li>间隙锁（GapLock）：<strong>共享锁</strong>，锁定某个事务扫描到的数据的索引记录的一个间隙（理解为一个范围），即使范围内不存在的数据也会被锁定，这样这个范围内的数据在事务未提交前肯定不会有变动，因为其他事务会被间隙锁阻塞。<strong>只针对非唯一索引</strong>，因为唯一键肯定不会有重复的插入。</li></ul><h2 id="场景复现">场景复现</h2><p>在理解了上述原理的情况下，就可以对问题进行复现：</p><ul><li>并行流开启了多个并行的事务，需要执行写操作，在MySQL5.7默认的<strong>RR</strong>事务隔离级别下，会触发<strong>间隙锁</strong>。</li><li>多个事务同时执行当前读，获取了同一个间隙锁，互相等待，就产生了死锁。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>并行流</tag>
      
      <tag>MySQL</tag>
      
      <tag>死锁</tag>
      
      <tag>间隙锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos不可用？服务不可用？</title>
    <link href="/article/Nacos%E4%B8%8D%E5%8F%AF%E7%94%A8%EF%BC%9F%E6%9C%8D%E5%8A%A1%E4%B8%8D%E5%8F%AF%E7%94%A8%EF%BC%9F/"/>
    <url>/article/Nacos%E4%B8%8D%E5%8F%AF%E7%94%A8%EF%BC%9F%E6%9C%8D%E5%8A%A1%E4%B8%8D%E5%8F%AF%E7%94%A8%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>最近在开发环境中，频频出现服务不可用的问题。还遇到过一次Nacos客户端连接不上服务端，但是管理平台能正常登录的问题。遂决定研究一波，记录下来。</p><h2 id="nacos不可用">Nacos不可用</h2><h3 id="问题">问题</h3><p>部分容器在启动时一直报错，连接不上Nacos服务端，但是Nacos管理界面能正常登录查看，后来经过排查是<strong>集群的某一个节点挂掉了</strong>导致的。但是这时候问题来了，Nacos作为服务发现和注册中心以及配置中心，集群模式下需要保证CP，并采用Raft算法进行选举，就算挂掉一台节点也不应该出现连接不上的问题。所以到底是为什么呢？这里先来简单看看CAP和Raft。</p><h3 id="cap">CAP</h3><blockquote><p>可以戳这里☞ <ahref="http://www.ruanyifeng.com/blog/2018/07/cap.html">CAP定理</a></p></blockquote><p>CAP定理，其实理解起来很简单，主要是针对分布式系统提出来的三个指标，而这三个指标不可能同时满足。</p><ul><li><strong>P</strong> - Partitiontolerance，网络分区容错性，客观存在的，只能接受。</li><li><strong>A</strong> -Availability，可用性，保证服务有响应，可能读取的数据不是最新的。</li><li><strong>C</strong> -Consistency，数据一致性，实例之间的数据保持一致，一台实例更新数据，另一台实例必须同步更新完数据后才能够被访问，保证读取的数据始终是最新的。</li></ul><p>从上面可以看出<strong>A</strong>和<strong>C</strong>之间也是互相矛盾的。所以，要在它们之间寻求平衡，根据不同的场景选取合适的保证。而Nacos作为服务发现与注册中心以及配置中心使用时，必须得保证CP。但是并不是严格的CP，因为在leader节点进行写操作和同步数据时，其它节点是可以提供查询的。而且在Leader节点宕机重新选举时，集群对外无法提供服务。当然，作为一个通用的解决方案，这种情况对于绝大部分系统是可以接受的。</p><h3 id="raft">Raft</h3><p>作为目前比较流行的分布式一致性协议，它的实现和理解起来的难度相对较简单，像Nacos、Redis等都采用了它，先来简单了解下。</p><p>三种状态（角色）：</p><ul><li>Leader：负责接收所有客户端的请求，本地更新后再同步至其它节点。</li><li>Follower：响应Leader的更新请求，同步日志文件到本地。</li><li>Candidate：选主过程中的一个中间角色，候选者。</li></ul><p>如果Follower检测（心跳机制：Leader周期性的发送心跳）到了Leader节点宕机，会触发选举。</p><ul><li>Follower递增自己的任期（term）并转换为Candidate；</li><li>投票给自己并且给所有其它节点发送投票请求；</li><li>如果在相同任期内，获得大多数的选票，则成为新的Leader，并发送心跳保持自己的角色。选票结果采取先到先得的方式；如果自己的任期小于请求中的任期，则会认为请求对应的节点为Leader，自身转换为Follower；如果自己的任期大于请求中的任期，则拒绝投票，保持Candidate；</li><li>如果一段时间内没有选出Leader，可能是出现了平票，则会在选举超时后重新发起（递增任期、发送投票请求）；</li><li>为了避免出现平票的情况，<strong>选举的超时时间是在一个区间内随机选择的（150ms~300ms）</strong>。也就是说，每个节点选举超时的时间是一个随机值，大大降低了一直平票的可能性。</li></ul><p>然后就是所谓的<strong>日志复制</strong>，即数据同步。</p><ul><li>主要是Leader节点同步日志给Follower节点；</li><li>如果出现日志数据不一致的情况，Leader会强制覆盖Follower的日志数据；</li><li>Leader会维护每次同步日志的一个索引，每次同步时Follower会验证这个索引是否和自己本地的日志索引一致，不一致则Leader会在下一次推送日志时缩小这个索引，直到验证通过。</li></ul><h3 id="解决">解决</h3><p>Nacos集群在如上所述的理论支持下，就算Leader宕机，那么也应该是可以继续访问的。这点从我们能正常登录Nacos管理平台且能从控制台的节点列表看到有一台节点处于<code>DOWN</code>的状态而其它都是<code>UP</code>得以验证。那么问题可能就不是出在服务端了，应该是客户端的问题，虽然把DOWN掉的Nacos节点重启后，客户端的访问就正常了。最后，经过和运维的一番排查，发现是<u><strong>yml配置文件中连接Nacos的地址是集群内部访问域名地址，并不是对外的VIP（VirtualIP Address）地址</strong></u>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br>        <span class="hljs-comment"># 下面这个</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">nacos-hs.nacos.svc.cluster.local:8848</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yml</span><br>        <span class="hljs-attr">shared-configs:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">config-port.yml</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">config-actuator.yml</span><br></code></pre></td></tr></table></figure><p>这里就涉及到Nacos的寻址，采用虚拟IP（VIP）的方式。集群模式下，<strong>客户端连接时要使用这个VIP地址，当某个节点不可用时会自动转发到其它可用节点</strong>。本质上是依靠TCP/IP的ARP协议，详细了解学习可以戳这里☞<ahref="https://developer.aliyun.com/article/598792">微服务架构中基于DNS的服务发现</a>。</p><p>这样一来就说的通了，客户端用拿到的IP地址（Java中DNS解析到IP后会缓存下来）一直尝试去连接DOWN掉的Nacos节点，肯定是一直失败，这也造成了一种Nacos集群不可用的假象。后来更新配置文件后，验证也没有问题了。Bingo!</p><h2 id="服务不可用">服务不可用</h2><h3 id="问题-1">问题</h3><p>最近公司项目在搞重构，基本上是推倒重来，新的架构设计，也用上了k8s流水线，很方便我们开发与快速部署。但是问题也随即出现，在dev环境，尤其是在前后端联调（开发会把自己本地的机子注册到Nacos上去）的时候会频繁的出现服务不可用的情况，这是为什么呢？这里先整理下主要用到的开源技术。</p><ul><li>网关：GateWay + Ribbon + Hystrix</li><li>RPC：Dubbo</li><li>服务发现与注册中心：Nacos</li><li>配置中心：Nacos</li><li>其它：SpringCloud Stream + RocketMQ，Redis，MySQL等等</li></ul><p>从报的错误提示”服务不可用“来搜索，发现是网关里面找不到正确的服务实例而报出来的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FallbackController</span> &#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/fallback/common&quot;)</span><br>    <span class="hljs-keyword">public</span> Result&lt;Object&gt; <span class="hljs-title function_">fallbackCommon</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Result.failed(<span class="hljs-string">&quot;服务不可用，请稍后再试！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>会触发这个fallback的提示，是因为对应的路由下的服务实例不可用。所以，对上面所述的情况做下总结：</p><ul><li>服务实例频繁上下线，且实例中有真正的dev容器，也有开发自己的机器；</li><li>采用了Ribbon作为负载均衡器；</li><li>采用Nacos作为服务发现与注册中心。</li></ul><p>这里还是先来简单分析下Nacos和Ribbon的服务实例列表更新机制。</p><h3 id="nacos">Nacos</h3><p>Nacos上的实例分为两种，持久化实例和临时实例，二者可以同时存在。</p><ul><li>临时实例：默认情况下都是临时实例，在健康检查不通过的情况下，随后的一段时间内会被剔除。适合大部分场景，如弹性扩容和缩容，多余的实例会自动销毁。</li><li>持久化实例：在健康检查不通过的情况下，不会剔除当前实例，只会标记为不健康。适合运维场景，实时查看健康状态，便于如告警、扩容等操作。</li></ul><p>是否临时实例由客户端<code>Instance</code>类中的<code>ephemeral</code>属性（短暂的;瞬息的）控制，默认为true。接下来是健康检查机制：</p><ul><li>临时实例：客户端会生成定时任务，<strong>每隔5s向服务端发送心跳告知存活。服务端也存在定时检测，超过15s没有收到心跳则认为不健康，超过30s则剔除实例。</strong></li><li>持久化实例：由服务端主动检测。Server端会生成一个<code>HealthCheckTask</code>，再由<code>TcpSuperSenseProcessor</code>处理，这里利用了NIO来实现。（<code>SocketChannel</code>，<code>Selector.open()</code>）</li></ul><p>目前我们的系统默认都是<strong>临时实例，所以实例变更时会存在时延</strong>。</p><h3 id="ribbon">Ribbon</h3><p>作为SpringCloud中实现客户端负载均衡的利器，Ribbon核心的一些接口如下：</p><ul><li><code>ILoadBalancer</code>，这个接口下的实现<code>BaseLoadBalancer</code>是整个Ribbon实现负载均衡的核心类。</li><li><code>IRule</code>，负载均衡规则选取的核心接口，默认提供了轮询、随机、响应时长权重等等选取合适实例的算法。</li><li><code>IPing</code>，这个接口主要是负责检测Ribbon自己缓存的服务实例是否存活。</li></ul><p>这里面重点要说的是<code>BaseLoadBalancer</code>这个类的核心逻辑，先整理下几个核心属性：</p><ol type="1"><li><code>allServerList</code>和<code>upServerList</code>：这两个集合分别存储了从客户端（这个客户端指的是当前Ribbon所在的服务实例）拉取的所有要进行负载均衡的服务实例列表和经过检测后还存活的服务实例列表。</li><li><code>DEFAULT_RULE</code>：负载均衡选取实例的规则，默认的是轮询。</li><li><code>DEFAULT_PING_STRATEGY</code>：默认Ping的策略，初始化<code>BaseLoadBalancer</code>时默认为null，或者为DummyPing（假Ping，永远返回true）。这个地方是一个核心关注点。</li><li>还用到了两把<code>ReadWriteLock</code>：<code>allServerLock</code>和<code>upServerLock</code>，分别用来控制<code>allServerList</code>和<code>upServerList</code>的读写。</li></ol><p>再就是核心逻辑：</p><ol type="1"><li>首先，不管使用Nacos还是Eureka作为服务发现注册中心，每台实例本地都会缓存一份依赖的服务实例列表。</li><li><strong>Ribbon会从当前所在实例的本地实例列表中拉取（<u>定时，默认30s</u>，在<code>BaseLoadBalancer</code>的实现类<code>DynamicServerListLoadBalancer</code>中）可用的实例列表</strong>，先存放到<code>allServerList</code>。在每次服务实例列表有变更时，先去更新<code>allServerList</code>，然后依据设置的Ping策略去依次判断可用的服务列表，添加到<code>upServerList</code>中。</li><li>默认的负载均衡选取规则是<code>RoundRobinRule</code>，轮询。在选取目标实例时，会判断<code>upServerList</code>是否为空，不为空则依次从<code>allServerList</code>中选取可用的实例作为目标实例。<strong>注意，这个时候由于默认的设置，所以拿到的服务永远是可用的，即<code>isAlive</code>总为true。</strong></li></ol><p>可以看出，<strong>Ribbon在获取最新实例时也是存在时延的，且默认情况下没有开启定时Ping的任务</strong>。</p><h3 id="解决-1">解决</h3><p>所以，问题就很明显了。结合上面的分析，采用定时的方式进行更新，那么必定有延时，当然在实际生产环境中，基本上不可能如此频繁的变更实例，所以一定的延时是完全没有问题的。而在我们的dev环境，由于容器频繁的重新部署或者开发机器上下线，导致经常出现服务不可用的情况，这也很正常。</p><p>当然我们可以改进一下，比如<strong>缩小Ribbon/Nacos的定时拉取/剔除实例的时间间隔，开启Ribbon中定时Ping及时感知服务下线</strong>。但其实我们更应该从另一些方面去减少这类问题的发生，如开发联调规范化、增加多联调环境等等。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Nacos</tag>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RedLock，红锁？</title>
    <link href="/article/RedLock%EF%BC%8C%E7%BA%A2%E9%94%81%EF%BC%9F/"/>
    <url>/article/RedLock%EF%BC%8C%E7%BA%A2%E9%94%81%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>翻译至Redis官网，<ahref="https://redis.io/topics/distlock">原文链接</a></p><p>RedLock，即Distributed locks with Redis，Redis提供的分布式锁。</p></blockquote><h2 id="distributed-locks-with-redis">Distributed locks with Redis</h2><p>在很多场景下，不同的进程需要以互斥的方式去访问共享资源，这时候分布式锁是非常有用的原语。</p><p>目前有很多的库和博客文章描述了如何利用Redis去实现一个分布式锁管理器（DLM- Distributed LockManager），但是每个库都采用了不同的实现方式，与稍微复杂一点的设计相比，这些方式都显得比较简单而且可靠性低。</p><p>这篇文章试图提供一种更规范的算法来实现Redis分布式锁。我们将这种算法命名为RedLock，相较于普通的单Redis实例实现的DLM，我们相信这种方式更加的安全可靠。我们希望社区能够去分析它并提供反馈，然后将其用作实现更复杂或者非传统设计（的分布式锁）的一个起点。</p><h2 id="各个语言的实现库">各个语言的实现库</h2><p>(略).</p><h2 id="安全性和活性的保证">安全性和活性的保证</h2><blockquote><p>活性，并发下线程能及时执行的能力。</p></blockquote><p>我们将只从三个要素来建模我们的设计，因为从我们的角度来看，这三个要素是有效使用分布式锁所需要的最基本的保证。</p><ul><li>安全性：互斥。在给定的任何时刻，仅有一个客户端能够持有锁。</li><li>活性A：无死锁。（其他客户端）最终总是能够获取到锁，即使当前锁定资源的客户端崩溃或者分区。</li><li>活性B：容错。只要大部分（一般定义为超过一半）Redis节点存活，客户端就可以获取和释放锁。</li></ul><h2id="为何基于故障转移的实现方式还不够">为何基于故障转移的实现方式还不够</h2><p>为了理解我们到底想要改进的是什么，让我们先分析一下大多数基于Redis的分布式锁的库的当前状态。</p><p>使用Redis锁定一个资源的最简单方式就是在一台实例上创建一个key。这个key通常是利用Redis的<code>expire</code>命令来限制它的存活时长，所以最终会被释放掉（符合上面列出来的第2个要素）。当客户端需要释放资源时，也可以主动删除这个key。</p><p>从表面上看一切都很好，但其实存在一个问题：在我们架构中会存在单点故障。如果Redismaster节点宕机了怎么办？那好，我们再加一个slave节点，然后在master节点不可用时使用它替代。不幸的是，这种方式并不可取。这样一来，我们无法实现互斥的这一安全性保证，因为Redis的复制（同步）是异步的。</p><p>该模型存在很明显的竞态条件：</p><ol type="1"><li>客户端A获取了master节点的锁（key）。</li><li>master节点在key传输给slave节点之前崩溃了。</li><li>slave节点升级成为master。</li><li>客户端B获取了客户端A当前正在锁定的同一资源的锁（B获取了新的master节点的锁）。<strong>违反了安全性！</strong></li></ol><p>有时候在特殊情况下，譬如在故障期间，多个客户端同时持有锁是完全没有问题的。在这种情况下，你可以使用基于复制算法的解决方案。否则，我们还是建议使用本文所描述的方案。</p><h2 id="单redis实例下的正确实现方式">单Redis实例下的正确实现方式</h2><p>在尝试克服上述单Redis实例设置的局限之前，我们先来看下在这个比较简单的场景中如何正确的进行设置。因为在时刻都有可能存在竞态条件的应用程序中，这实际上是一个可行的解决方案。而且锁定到单个Redis实例是本文所描述的分布式算法的基础。</p><p>为了获取锁，会采用如下的方式</p><p><code>SET resource_name my_random_value NX PX 30000</code></p><p>这条命令只会在key不存在的情况下（<code>NX</code>选项）把它设置进去，过期时间是30000毫秒（<code>PX</code>选项）。key设置了一个对应的值”my_random_value“。这个值在所有的客户端以及锁定请求中必须是唯一的。</p><p>基本上，使用这个随机值是为了以一种安全的方式释放锁。使用一个脚本告诉Redis：<strong>当且仅当key存在且存储在key上的值恰好是我所期望的值时，才能移除此key</strong>。可以使用下面这个Lua脚本实现：<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&quot;get&quot;</span>,KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&quot;del&quot;</span>,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></p><p>（上面这个脚本中）很重要的一点是避免了删除另一个客户端创建的锁。譬如，一个客户端可能获取了该锁，然后在某些操作中阻塞（执行）的时间超过了该锁的有效时间（锁将要过期的时间），之后（操作完成之后）该客户端删除了这个锁（直接执行<code>DEL</code>命令），但其实这个锁已经被其它客户端获取了（或者说删除了其它客户端创建的锁，因为key是一样的）。所以仅仅使用<code>DEL</code>命令是不安全的，因为一个客户端可能删除另一个客户端创建的锁。而使用上述脚本，<strong>由于每个锁都持有一个随机字符串的”签名“（代表某个客户端），因此仅当仍然是设置当前锁的客户端尝试将锁删除时，当前锁才会被删除。</strong></p><p>那么这个随机字符串应该是什么样的呢？我会假设它是来自<code>/dev/random</code>下的20个字节。当然在你自己的程序任务中你可以去找一个更简单的方式来保证它的唯一性。（略，这段后面是一些关于随机串的选取方式。）</p><p>key的存活时间，我们把它叫做”lock validitytime“（锁的有效期）。它既是锁自动释放的时间，又是当前客户端在另一个客户端再次获取锁之前必须执行的操作所需的时间，而在技术上又不违反互斥保证。该时间从获取锁的那一刻起，仅限于给定的时间窗口。</p><p>至此，我们有了一个比较好的方式去获取和释放锁。这个由单个且始终可用的实例组成的非分布式系统是安全的。接下来让我们把这个概念扩展到没有此类保证（始终可用）的分布式系统中去。</p><h2 id="redlock算法">RedLock算法</h2><p>在此算法的分布式版本中，假定我们有N个Redismaster节点。这些节点都是相互独立的，所以我们不会使用复制或者任何其它隐式的协调系统。我们已经描述了如何在一个单实例中去安全的获取和释放锁。想让然的也会认为此算法会采用这种方法在单个实例中获取和释放锁。在我们的例子里面，N=5，这是很合理的一个数值，然后我们会在不同的计算机或者虚拟机内运行5个Redismaster节点，以此来保证它们失败时都是彼此独立的。</p><p>为了保证能获取到锁，客户端会做如下一些操作：</p><ol type="1"><li>获取当前的时间戳（毫秒）。</li><li>按顺序在N个实例中依次尝试获取锁，使用的都是同样的key和随机值。在这个步骤中，当在每一个实例中去设置锁的时候，客户端会设定一个小于锁的自动释放时长的超时时间，以便于能正常的获取锁。比如说锁的自动释放时长是10s，那么这个超时时间会设定为5~50ms之间。这样做是为了避免当一个Redis节点挂掉时，客户端仍然在相当长的一段时间内去尝试连接这个节点。如果一台实例不可用，我们应该尽快的去尝试连接下一台实例。</li><li>客户端会通过当前时间戳减去第一步中获取的时间戳，来计算在所有实例中获取锁所消耗的时间。当且仅当客户端能获取大部分实例的锁时（至少3台，<u><strong>大部分= N/2 +1</strong></u>），而且获取锁的总消耗时长小于锁的有效时长，分布式锁才被认为真正获取成功。</li><li>当锁获取成功后，它的有效时长会被认定为初始化设置的有效时长减去在第3步中计算出来的获取锁消耗的时长。</li><li>如果客户端由于某些原因（要么没有获取到大部分实例的锁，要么实际有效时间变为负数了）获取锁失败了，那么它会尝试去释放所有实例的锁（哪怕是那些它尝试获取锁失败的实例）。</li></ol><h2 id="这种算法是异步的吗">这种算法是异步的吗</h2><p>（可以认为是同步的，因为时钟漂移一般情况下很小。）该算法是基于这样一种假设，即进程（实例）之间在没有同步时钟时，每个进程中的本地时钟都是以相同的速率流动，相比于锁的自动释放时间，误差要小的多。这种假设与现实世界中的计算机非常相似：每台计算机都有一个本地时钟，我们通常可以依赖不同的计算机来获得一个很小的时钟漂移。</p><p>基于这一点，我们需要更好地指定互斥规则：持有锁的客户端在锁有效时间（<u>步骤3中获得的</u>）减去一些时间（为了补偿进程之间的时钟偏移，只有几毫秒）的时长后终止工作，这是可以保证的（互斥）。</p><p>（注：我的理解是<u>锁的实际有效时长 = 初始化时长（TTL） -获取（所有实例中的）锁消耗时长 -时钟漂移</u>，也就是要移除时钟漂移的误差。比如，初始化有效时长10s，获取锁消耗时长2s，不排除时钟漂移误差（假设为1s），那么有效时长为8s。由于存在时钟漂移，最后一台实例实际上相比于第一台实例，是相差了1s之后才开始有效时长计算的，这样就违背了互斥。更严格的话是要计算上时钟漂移误差的。）</p><h2 id="失败后的重试机制">失败后的重试机制</h2><p>当一个客户端无法获取锁时，<u>它应该在一个随机延迟后重试</u>，尝试去同步多个客户端在同一时刻获得同一资源的锁（因为可能导致<ahref="https://www.cnblogs.com/yjmyzz/p/redis-split-brain-analysis.html">脑裂</a>，nobodywins）。同样，当客户端在大多数Redis实例中尝试获取锁的速度越快，出现脑裂（以及重试）的情况的窗口就会越小，因此理想情况下，客户端应该使用多路复用的形式尝试同时发送<code>SET</code>命令给N个实例。</p><p>值得强调的是，对于未能获取大多数锁的客户端，<u>尽可能快的释放（那部分）获取的锁是非常重要的</u>，这样就不用等到key（锁）过期之后才能再次获取（但是，如果发生网络分区，并且客户端再也不能和Redis实例进行通信，那么就要付出可用性上面的代价，因为要等到这个key过期之后才能再次获取）。</p><h2 id="锁的释放">锁的释放</h2><p>锁的释放比较简单，只需要释放所有实例上的锁即可。不管客户端能否成功锁定给定的实例。</p><h2 id="安全性讨论">安全性讨论</h2><p>这种算法安全么？我们可以尝试了解下在不同情况下会发生什么。</p><p>首先，我们假设客户端可以获取大多数实例上的锁。所有的实例都会包含一个具有相同过期时间的key。然而，key是在不同时间被设置的，所以它们也会在不同的时间失效。但是如果第一个key是在时间T1（在和第一台服务器连接之前采样的时间）设置的，并且最后一个key是在时间T2（从最后一台服务器得到答复的时间）设置的，我们可以确定的是集合中第一个key最小的有效时长<strong>MIN_VALIDITY= TTL（应用中设置的过期时间）- (T2 - T1) -CLOCK_DRIFT（时钟漂移）</strong>。所有其它的key都会在之后失效，所以我们可以确保至少这次这些key都会被同时设置。</p><p>在设置大多数key（成功or失败）的这段时间内，另一个客户端将无法获取锁，因为已经存在了N/2+1个key，所以N/2+1个<code>SET NX</code>的操作都会失败。因此如果获取了锁，那么不可能在同一时间去重新获取它（违背了互斥性）。</p><p>然而我们还是要确保同一时间尝试获取锁的多个客户端不能同时成功。</p><p>如果一个客户端使用了一个与锁的最大过期时间（应用中设置的TTL）很接近或者更长一点的时间，来获取了大多数实例上的锁，那么这个锁就会被认为是无效的并且会被释放掉，因此我们只需要考虑客户端用小于有效时长的时间来获取大多数实例上的锁的这种情况。在这种情况下，上面已经说的很清楚了，在MIN_VALIDITY时间段内，没有客户端可以再次获取锁。所以当且仅当锁定大多数实例的时长大于TTL时长，多客户端才可以同时的锁定N/2+1的实例，而这种情况下锁会被视为无效。</p><p>您能否提供正式的安全性的证明，（或者）提出类似的现有算法，或者找出bug？这将不胜感激。</p><h2 id="活性讨论">活性讨论</h2><p>系统的活性主要有以下三个特征：</p><ol type="1"><li>锁的自动释放（当key过期时）：最终所有key都能够被再次获取。</li><li>通常情况下，客户端会在获取锁失败或者锁被获取了但是程序终止的情况下移除锁，使得我们不必等待锁过期后才能够再次获取锁。</li><li>当客户端需要重试获取锁时，它会等待一段时间，这段时间会比需要获取大多数锁的时间更长。这让在资源竞争期间出现脑裂的可能性大大降低。</li></ol><p>然而，当出现网络分区时，我们还是要付出相当于TTL时长的可用性代价，因此如果存在连续的分区，我们会无限期的付出这这个代价。每当客户端获取了锁但是在释放锁之前被分割，就会发生这种情况。</p><p>基本上，如果存在无限期的网络分区，那么系统就可能无限期的处于不可用的状态。</p><h2 id="性能崩溃恢复和fsync">性能，崩溃恢复和fsync</h2><blockquote><p>sync - 不等待实际同步操作成功，直接返回。</p><p>fsync - 等待同步结果成功后才返回。</p></blockquote><p>使用Redis作为一个分布式锁服务，对性能的要求很高，不管是获取/释放锁的延迟，还是每秒能执行的获取/释放操作的次数。为了满足这种需求，与N个Redis服务进行通信的减少延迟的策略必定是多路复用（或者叫穷人的多路复用，把Socket置于非阻塞模式下，发送所有的命令，之后再读取所有的命令，假设客户端和每个实例的RTT（Round-TripTime：往返时延）都是接近的）。</p><p>但是，如果我们想得到能在崩溃后恢复系统的模型，那么我们还需要考虑持久化的问题。</p><p>从根本上看，这里的问题是，假设我们配置Redis时没有设置持久化这一项，客户端要获取总共5台实例里面其中3台实例的锁，然后其中一台实例在客户端获取锁时重启了，这个时候针对同一资源，我们又有3台实例能够被访问获取到锁，然后另一个客户端成功获取到了锁。这就违反了排它锁的安全性。</p><p>如果我们开启了AOF的方式进行持久化，那么情况就会得到很大的改善。例如，我们可以在升级一个服务的时候发送<code>SHUTDOWN</code>命令然后重启它。因为Redis的过期是在语义上实现的，所以当服务关闭时，实际上时间仍在流逝（我的理解是并不是直接关闭，而是会有一段缓冲时间来持久化内存中的数据，重启后不会丢失），我们所有的要求都可以满足。当然，只要是优雅的停机所有的情况都会很好。那么如果突然断电呢？如果Redis默认配置了每秒都进行<code>fsync</code>同步数据到磁盘中，那么还是有可能出现重启之后key丢失的情况。理论上，我们要想在任何情况下的实例重启中都能保证锁的安全性，我们需要启用fsync =一直会处于持久化的设定状态。这反过来会破坏传统上以安全方式实现分布式锁的同级别的CP系统的性能。</p><p>但是事情比乍一看要好得多。基本上，只要实例在崩溃重启后不再参与到任何当前活动的锁当中，算法就能一直保持安全性。所以，当实例重启时一组当前正在活动的锁全部是锁定（其它正常的）实例而非这台正在重新加入系统的实例。</p><p>为了保证这些，我们要做的就是在一台实例崩溃后，至少要（让这台实例）在比我们设置的最大的<strong>TTL时间</strong>更长一点的时间段内保持不可用，这个时间（TTL）就是实例崩溃时存在的所有与锁有关的key变为无效并且自动释放所需的时间。</p><p>使用<em>delayedrestarts</em>（延迟重启）基本上能保证安全性，即便没有任何Redis持久化的设置。但要注意的是，这可能会导致可用性下降。比如说大多数的实例都崩溃了，那么系统就会在TTL时间内变得全局不可用（这儿的全局指的是没有一个资源能够在这段时间内被锁定）。</p><h2 id="让算法更可靠扩展锁">让算法更可靠：扩展锁</h2><p>(略).</p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么时候使用并行流</title>
    <link href="/article/%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E5%B9%B6%E8%A1%8C%E6%B5%81/"/>
    <url>/article/%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E5%B9%B6%E8%A1%8C%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<blockquote><p>翻译至Doug Lea关于并行流的介绍，<ahref="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">原文链接</a></p></blockquote><p><code>java.util.stream</code>框架支持对集合或者其他源进行<u>数据驱动</u>的操作，其中大多数方法都是对每一个数据元素应用相同的操作。<u>当多个内核可用时</u>，我们可以使用集合的<code>parallelStream()</code>方法，使得“数据驱动”变成“数据并行”。但是，什么时候应该这样做呢？（<em>注：说明不是有多核就可以盲目使用并行流</em>）</p><p>当各个操作是独立的，并且<u>计算量很大</u>或者是作用于<u>可以高效拆分数据结构的大量数据元素</u>，或者以上情况都有时，那么请考虑使用<code>S.parallelStream().operation(F)</code>来替代<code>S.stream().operation(F)</code>。下面是详细的说明：</p><ul><li><strong>F</strong>，<u>每个元素的函数操作（通常是一个lambda）是独立的</u>：对每个数据元素的计算是<u>不需要依赖或者不会影响</u>其他任何数据元素的。</li><li><strong>S</strong>，<u>数据源集合可以被高效的拆分</u>。除了Collections外，还有一些其它易于并行化的stream数据源，譬如<code>java.util.SplittableRandom</code>（你可以使用<code>stream.parallel()</code>方法使之并行化）。但是大多数基于IO的数据源还是主要为了顺序使用而设计的。</li><li><u>执行顺序型式的总时间需要超过一个最小的阈值</u>。如今在大多数平台上，这个阈值大约是100微秒（的10倍以内），但是可以不用那么精准的去测量它。在实践中，使用<u><strong>N</strong>（数据元素的个数） 乘以<strong>Q</strong>（每个数据元素在 <strong>F</strong>中消耗的时间成本）</u>就可以很好的估算了。反过来，也可以将<strong>Q</strong> 表示为<u>操作数或者代码的行数</u>，然后检查 <strong>N* Q</strong>至少为10000（如果还是怕这个数太小，也可以再加一两个0）。所以当<strong>F</strong>是一个很简单的函数比如<code>x-&gt;x+1</code>，那么只有当<strong>N&gt;=10000</strong> 时使用parallel并行执行才会有价值。相反，当<strong>F</strong>需要进行大量的计算比如在棋局游戏中找到下一步的最佳走法，那么<strong>Q</strong>这个因子就会很大，以至于只要数据源集合可以被完全的拆分，<strong>N</strong>就变得不那么重要了。</li></ul><p>Stream框架不会（也不能）去强制实施以上这些（<em>标准/理论</em>）。假如每个计算不是独立的，那用并行的方式去运行不但没有任何好处反而会出现很严重的错误。下面是一些其他说明，来自于三个工程问题和一些折中的思想：</p><ul><li>Start-up：<u>启动</u>。由于计算机处理器多年来一直在增加内核，其中大多数还添加了电源控制机制，这可能会导致内核启动速度变慢，有时还会增加JVM、操作系统和管理程序带来的额外开销。因此该阈值就大致相当于足够多的内核开始处理并行子任务所需的时间。一旦它们开始启动，并行计算就会比顺序计算能效更高（当然这取决于不同的处理器和操作系统的实现细节；可以看看这个例子<ahref="http://queue.acm.org/detail.cfm?id=1658422">this article byFederova et al</a>）。</li><li>Granularity：<u>粒度</u>。对已经很小粒度的计算再进行细分是不值得的。Stream框架通常将问题进行分解，以便于系统上所有可用的内核都可以去运行处理。如果启动之后，每个内核实际上什么都做不了，那么设置并行计算（实际上大部分都是顺序计算的）的努力就白费了。考虑到目前内核数的实际范围在2~256之间，该阈值也避免了过度分区的影响。</li><li>Splittability：<u>可分拆性</u>。最有效的可拆分的集合包括ArrayLists和HashMaps（ConcurrentHashMaps），以及普通数组（比如形如T[]的数组，使用<code>java.util.Arrays</code>的静态方法拆分的数组）。效率最低的是LinkedLists，BlockingQueues和大多数基于IO的资源。其他的则介于两者之间（<u>如果数据结构内部支持随机访问、高效搜索，或者二者皆有，那么数据结构往往是高效可分的</u>）。如果拆分数据比处理数据的时间还长，那就没必要了。当然，如果计算的<strong>Q</strong>因子足够的大，即使对于一个<code>LinkedList</code>，使用并行流也可能更具效率，当然这并不常见。除此之外，一些数据源无法被拆分为单个元素，因此在任务划分的精细程度上可能有所限制。</li></ul><p>收集这些影响的详细度量是很困难的（尽管可以谨慎使用比如<ahref="http://openjdk.java.net/projects/code-tools/jmh/">JMH</a>这样的工具）。但总体效果显而易见。你可以自己实验去感受下，比如在一台32核的测试机器上运行<code>ArrayList</code>的<code>max()</code>或者<code>sum()</code>这样的小函数，盈亏平衡点非常接近10K大小。更大的数据量可以看到高达20倍的加速。小于10K大小的运行时间并不比10K大小的运行时间少多少，因此通常比顺序运行时间更慢。（<em>注：上面两句对原句理解的不是特别清楚</em>）更糟糕的减速发生在当数据元素个数少于100时，这将激活一堆线程，然而这些线程最终没有任何事情可做，因为计算在它们开始运行之前就已经完成了。另一方面，当每个元素的计算非常耗时时，使用高效且可以完全分解的集合的好处是显而易见的，比如<code>ArrayList</code>。</p><p>换一种说法，在没有足够的计算量来证明它的合理性时使用<code>parallel()</code>可能会花费大约100微秒的时间，而在证明了其合理性时使用它至少会节省这么多时间（对于非常大的计算，可能会节省数小时）。（<em>注：我的理解是合理的使用<code>parallel()</code>会带来更高的效率，反之则会带来不必要的开销。</em>）具体的成本和收益是会随着时间和平台的变化而变化的，当然也会随着环境的变化而不同。例如，在一段顺序循环中去并行运行一个微小的计算会更突出（<em>注：使用并行操作带来的</em>）加速和减速的效果（做这样的微基准测试可能无法预测实际的使用情况）。</p><h2 id="提问与答疑">提问与答疑</h2><ul><li><p><strong>为什么JVM自己不能确定是否使用并行模式？</strong></p><p>JVM可以尝试，但是通常情况下都会给出糟糕的答案。过去30年来，对完全无导向的全自动的多核并行的追求并没有取得统一的成果，因此，Stream框架采用了更安全的方式，仅要求用户做出是或否的决策。这些决策依赖于工程上的折中，并且这些折中不太可能完全消失，这类似于顺序编程中经常会做的判断。例如，在仅包含单个元素的集合中寻找最大的元素而不是直接使用这个元素（不在集合内部）时，可能会遇到上百倍的开销（减速）。有时候JVM可以为您优化这种开销，但这在顺序的情况下并不常见，在并行的情况下更是从不适用。另一方面，我们也希望工具能帮助用户做更好的决策。</p></li><li><p><strong>我对 F, N, Q, S这些参数的了解甚少，如何去更好的抉择呢？</strong></p><p>这也类似于常见的顺序性编程中出现的问题。比如，S是一个<code>HashSet</code>，调用集合的方法<code>S.contains(x)</code>通常会很快，但是如果是<code>LinkedList</code>就会变慢了，其它的集合介于二者之间。通常，对于使用了集合的组件的作者来说，<u>最好的处理方法不是直接导出集合，而是基于集合导出操作</u>，这样用户就与这些决策隔绝了，这同样适用于并行操作。比如，一个内置“prices”集合的组件，可能会定义一个使用size大小阈值进行判断的方法，除非对每个元素的计算都非常昂贵。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getMaxPrice</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> priceStream().max(); &#125;<br><br><span class="hljs-keyword">private</span> Stream <span class="hljs-title function_">priceStream</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> (prices.size() &lt; MIN_PAR) ? <br>    prices.stream() : prices.parallelStream();<br>&#125;<br></code></pre></td></tr></table></figure><p>你可以通过各种方式扩展这一思想，以处理有关何时以及如何使用并行性的各种考虑。</p></li><li><p><strong>如果我的函数操作可能会涉及到IO或者同步呢？</strong></p><p>一种极端情况是没有通过独立性标准的函数，包括本质上是顺序的IO，对锁定同步资源的访问以及一个并行子任务执行IO失败对其他子任务会产生副作用。将这些函数并行没有多大意义。还有另一种极端情况是，执行偶发且短暂的IO或者很少阻塞的同步计算（例如大多数形式的日志以及对并发集合的大多数使用，如<code>ConcurrentHashMap</code>），这些（<em>使用并行</em>）都是无害的。介于这两者之间的中间情况最需要去判决。如果每个子任务在等待IO或者访问时都阻塞了一段时间，那么CPU资源可能会闲置，并且程序或者JVM也无法通过任何方式去使用它们。（<em>这样的话</em>）每个人都不开心。在这些情况下，使用并行流通常不是一个很好的选择，但还是有可用的比较好的替代方案，比如<code>async-IO</code>以及<code>CompletableFuture</code>的设计。</p></li><li><p><strong>如果我的数据源是基于IO的呢？</strong></p><p>目前，基于JDKIO的Stream源（例如<code>BufferedReader.lines()</code>）主要用于顺序性的使用，在元素到达时逐个处理。支持缓存IO的高效批处理也是有可能的，但是目前需要定制开发Stream源、Spliterators和/或Collectors，在JDK未来的发行版中可能会支持某些常见的类型（<em>数据源</em>）。</p></li><li><p><strong>如果我的程序运行在一台很繁忙的机器上，并且所有的核心都被占用了怎么办？</strong></p><p>机器通常只有一组固定的核心，当进行并行操作的时候不会变魔术般的多出更多的核心。然而，只要清晰的满足了选择并行执行的条件，那么就没有任何理由去担心（<em>机器繁忙的问题</em>）。你的并行任务执行时会与其它任务竞争CPU时间，所以你会看到加速得并没有那么多。在大多数情况下，这仍然比其他方式更有效。在底层机制的设计上，如果没有其他核心可用，你会发现对比顺序执行，（<em>并行执行速度</em>）只会有很小的减缓，除非系统已经超负荷到花费所有的时间在上下文切换上而不是执行真正的任务上，或者是在假定所有处理都是顺序的情况下进行调整的。如果你使用的是这样一个系统，管理员可能已经禁用了将多线程/多核心作为JVM配置的一部分。而如果你是管理员，那么可以考虑这样做（<em>禁用</em>）。</p></li><li><p><strong>是否所有操作都是以并行模式并行化执行？</strong></p><p>是，至少在某种程度上是这样的，尽管Stream框架在选择如何这样做时会遵循源和方法的约束。通常来说，更少的约束使更多潜在的并行性成为可能。另一方面，也无法保证该框架会提取并应用所有可能的并行机会。在某些情况下，如果你有足够的时间和专业知识，你可以手动实现一个更好的并行解决方案。</p></li><li><p><strong>使用并行化的方式能提升多少效率？</strong></p><p>如果你遵循这些准则，通常来说都是很值得的。但是可预测性并不是现代硬件和系统的强项，所以不可能给出普适性的答案。缓存位置、GC效率、JIT编译、内存争用、数据布局、操作系统定时调度策略以及虚拟机监视器的存在都是可能产生重大影响的因素。这些也在顺序执行的性能中发挥作用，但是通常会在并行设置中被放大：在顺序执行中造成10%的差异的问题会在并行执行中产生10倍的差异。</p><p>Stream框架囊括了一些能帮助你提高执行速度的工具。比如，像<code>IntStream</code>这样的原语使用了一些特殊的手段，在并行执行上比顺序执行更具效率，因为它不仅减少了开销（以及空间占用），还增强了缓存的局部性。并且，使用<code>ConcurrentHashMap</code>而不是<code>HashMap</code>作为并行“collect”操作的目标集合能减少内部的开销（<em>注：这里理解为<code>ConcurrentHashMap</code>是数据源集合，而不是collect到<code>ConcurrentHashMap</code>中</em>）。伴随着大家对框架的使用经验的累积，将会出现更多的技巧和指导。</p></li><li><p><strong>这一切都太可怕了！难道我们不应该制定一个使用JVM参数的策略来禁用并行化操作么？</strong></p><p>我们不想告诉你该怎么做，为程序员引入新的会使事情出错的方法是很可怕的。在编码、设计和决策上的错误肯定时有发生。但是有些人几十年来一直在预言，启用应用程序级别的并行会导致不可预知的重大灾难。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java8</tag>
      
      <tag>ParallelStream</tag>
      
      <tag>DougLea</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
