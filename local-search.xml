<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>函数式编程增强库Vavr初探（二）</title>
    <link href="/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%A2%9E%E5%BC%BA%E5%BA%93Vavr%E5%88%9D%E6%8E%A2%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%A2%9E%E5%BC%BA%E5%BA%93Vavr%E5%88%9D%E6%8E%A2%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本文是翻译Vavr官方文档的<a href="https://docs.vavr.io/#_introduction">序章</a>，上一篇的<a href="https://luckycaesar.github.io/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%A2%9E%E5%BC%BA%E5%BA%93vavr%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%80%EF%BC%89/">使用指南</a>介绍了Vavr中的主要组件的定义和使用示例。其中也出现了一些函数式编程的概念，如<em>函数副作用</em>、<em>引用透明性</em>、<em>持久化集合</em>、<em>不可变数据结构</em>等等，在序言中都有更进一步的阐述。</p><h1>1. 序章</h1><p>Vavr（过去叫Javaslang）是一个为Java8+而生的函数式库，它提供了持久化数据类型和函数式控制结构。</p><h2 id="1-1-用Vavr实现Java8的函数式数据结构">1.1. 用Vavr实现Java8的函数式数据结构</h2><p>Java8的<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">lambdas (λ)</a>能让我们创建出绝妙的API，这些API极大的提升了语言的表现力。</p><p>Vavr利用基于函数式模型的lambdas创造了一系列的新特性，其中一个就是函数式集合库，旨在替换Java中的标准库。</p><p><img src="/img/vavr-collections.png" alt="collections"></p><p><em>（这只是一张鸟瞰图，接下来会有更易于阅读的版本。）</em></p><h2 id="1-2-函数式编程">1.2. 函数式编程</h2><p>在探讨细节之前，我想先讲一些基础知识。这能解释我为什么会设计出Vavr，特别是新的Java集合类。</p><h3 id="1-2-1-副作用">1.2.1. 副作用</h3><p>Java应用通常都有大量的<a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)">副作用</a>。它们改变了某种状态，可能是外部世界的（应用程序以外的）。常见的副作用是就地改变对象或者变量，打印到控制台，写到一个日志文件或者数据库。如果副作用以非预期的方式影响了我们程序的语义，那就被认为是有害的。</p><p>例如，如果一个函数抛出了异常且这个异常是<em>interpreted</em>，它就被认为是一个<em>影响程序</em>的副作用。另外，<a href="http://c2.com/cgi/wiki?DontUseExceptionsForFlowControl">异常类似于非本地的go-to语句</a>，它们会破坏正常的控制流。不管怎样，实际的应用确实会产生副作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> dividend, <span class="hljs-type">int</span> divisor)</span> &#123;<br>    <span class="hljs-comment">// throws if divisor is zero</span><br>    <span class="hljs-keyword">return</span> dividend / divisor;<br>&#125;<br></code></pre></td></tr></table></figure><p>在函数环境下，可以用Try来封装副作用使我们（的程序）处于一个良好的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// = Success(result) or Failure(exception)</span><br>Try&lt;Integer&gt; <span class="hljs-title function_">divide</span><span class="hljs-params">(Integer dividend, Integer divisor)</span> &#123;<br>    <span class="hljs-keyword">return</span> Try.of(() -&gt; dividend / divisor);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个版本的divide方法不会再抛出任何异常，我们利用Try类型显式的显示了可能的失败。</p><h3 id="1-2-2-引用透明性">1.2.2. 引用透明性</h3><p>一个函数，或者更笼统的说一个表达式，对它的调用如果能用它的值替换而不影响程序本身的行为，那就称之为<a href="https://en.wikipedia.org/wiki/Referential_transparency">引用透明性</a>。简单来讲，给定相同的输入总能得到相同的输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// not referentially transparent</span><br>Math.random();<br><br><span class="hljs-comment">// referentially transparent</span><br>Math.max(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>如果（函数中）涉及的所有表达式都是引用透明的，则称该函数为<a href="https://en.wikipedia.org/wiki/Pure_function">纯函数</a> 。一个由纯函数组成的应用大概率在编译后就<em>可以运行</em>，对此我们能解释得通。单测易于编写，而调试则成为过去式。</p><h3 id="1-2-3-对值的思考">1.2.3. 对值的思考</h3><p>Clojure语言创始人Rich Hickey，曾做过一个很棒的演讲<a href="https://www.youtube.com/watch?v=-6BsiVyC1kM">The Value of Values</a>。其中最有趣的值就是<a href="https://en.wikipedia.org/wiki/Immutable_object">不可变</a>值，主要原因是不可变值</p><ul><li><p>天然是线程安全的，因此也无需同步</p></li><li><p>有关于<em>equals</em>和<em>hashcode</em>都是稳定的，所以（不可变值）也是可靠的哈希键</p></li><li><p>无需克隆</p></li><li><p>当被用在未经检查的协变转换（Java特有的）中时也能表现得类型安全</p></li></ul><p>用<em>不可变值</em>搭配<em>引用透明性函数</em>是使Java变得更好的关键，Vavr则提供了必要的<a href="http://static.javadoc.io/io.vavr/vavr/0.10.4/io/vavr/control/package-summary.html">控件</a>和<a href="https://static.javadoc.io/io.vavr/vavr/0.10.4/io/vavr/collection/package-summary.html">集合</a>以在日常的Java编程中达成这一目标。</p><h2 id="1-3-果壳中的数据结构">1.3. 果壳中的数据结构</h2><p>Vavr的集合库包含了一组丰富的基于lambda之上的函数式数据结构，唯一个与Java原生集合共享的接口是Iterable。（没有共享其他接口的）主要原因是基于Java集合接口的更改器方法<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="mutator methods：https://en.wikipedia.org/wiki/Mutator_method。">[1]</span></a></sup>无法返回一个底层集合类型的对象。</p><p>下面来看看不同类型的数据结构，我们会知道为什么这（不共享集合接口）是非常必要的。</p><h3 id="1-3-1-可变数据结构">1.3.1. 可变数据结构</h3><p>Java是一门面向对象编程语言。我们通过封装对象的状态来达到数据隐藏的目的，然后提供更改器方法控制这种状态。<a href="https://en.wikipedia.org/wiki/Java_collections_framework">Java collections framework (JCF)</a> 就是基于此种思想构建的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">// removes all elements from this collection</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我会把<em>void</em>的返回类型理解为一种异味。它就是<a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)">副作用</a>产生的证据，会使得状态发生变换。<em>共享</em>可变状态是一个造成失败的主要来源，不仅仅在并发环境中。</p><h3 id="1-3-2-不可变数据结构">1.3.2. 不可变数据结构</h3><p><a href="https://en.wikipedia.org/wiki/Immutable_object">不可变</a>数据结构被创建后就无法更改。在Java的上下文中，它们以集合包装器的形式被广泛应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Collections.unmodifiableList(otherList);<br><br><span class="hljs-comment">// Boom!</span><br>list.add(<span class="hljs-string">&quot;why not?&quot;</span>);<br></code></pre></td></tr></table></figure><p>有各种各样的库提供了类似实用的方法给我们。（这些方法）返回的结果总是一个特定集合的不可变视图，而且通常在我们调用一个更改器方法后在运行时抛出（异常）。</p><h3 id="1-3-3-持久化数据结构">1.3.3. 持久化数据结构</h3><p>一个<a href="https://en.wikipedia.org/wiki/Persistent_data_structure">持久化数据结构</a>在被修改时，会保留它以往的版本，也因此形成了<em>事实上</em>的不可变。完全地持久化数据结构允许对任何版本进行更新和查询。</p><p>许多操作只会执行很小的改动，仅仅拷贝上一个版本并不会变得高效。要节省时间和内存，确认两个版本之间的相似之处并尽可能多的共享数据就显得尤为重要。</p><p>这种模型不会强制任何实现细节，此时函数式数据结构就该登场了。</p><h2 id="1-4-函数式数据结构">1.4. 函数式数据结构</h2><p>也被称作<a href="https://en.wikipedia.org/wiki/Purely_functional"><em>纯</em> 函数式数据结构</a>，它们是<em>不可变</em>且<em>持久化</em>的。函数式数据结构的方法都是<em>引用透明</em>的。</p><p>Vavr拥有许多很常用的函数式数据结构，接下来会用示例进行深入讲解。</p><h3 id="1-4-1-链表">1.4.1. 链表</h3><p>最受欢迎当然也是最简单的一种函数式数据结构就是 <a href="https://en.wikipedia.org/wiki/Linked_list">（单）链表</a>，它有一个<em>头</em>元素和一个<em>尾</em>列表。链表的行为类似于遵循<a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">后进先出 (LIFO)</a>方法的栈。</p><p>在Vavr里我们可以像这样来实例化一个列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// = List(1, 2, 3)</span><br>List&lt;Integer&gt; list1 = List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>列表中的每一个元素都形成了一个独立的节点，最后一个元素的尾部指向Nil，一个空的列表。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="查看源码可知，这里是按3、2、1的顺序进行构建的，对整个链表的遍历，则会按照1、2、3的顺序输出，遵循后进先出原则。整个链表遍历顺序的**头节点是1，尾节点是3**。">[2]</span></a></sup></p><p><img src="/img/vavr-list1.png" alt="list1"></p><p>这使得我们可以在列表的不同版本之间共享元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// = List(0, 2, 3)</span><br>List&lt;Integer&gt; list2 = list1.tail().prepend(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>新的头元素0被<em>链接</em>到原列表的尾部<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="此时的**尾部**不是按链表的遍历顺序，而是按构建链表时的顺序来定义的。**头元素0**会变成新版本链表遍历顺序的头节点。更新后的新版本链表，遍历出来的结果就是0、2、3。">[3]</span></a></sup>，原来的列表则保持不变。</p><p><img src="/img/vavr-list2.png" alt="list2"></p><p>这些操作都会在常数时间内运行，换句话说就是与列表的大小无关。大部分其它操作都是线性时间，在Vavr里面会通过接口LinearSeq来表示，我们可能已经从Scala中了解过了。</p><p>如果我们需要能在常数时间内执行查询的数据结构，Vavr提供了Array和Vector，它们都拥有<a href="https://en.wikipedia.org/wiki/Random_access">随机存取</a>的能力。</p><p>Array类型由Java对象数组支持，插入和删除操作都是线性时间。Vector（的时间开销）则介于Array和List之间，它在随机存取和修改时表现的都很不错。</p><p>实际上链表也可以用来实现队列数据结构。</p><h3 id="1-4-2-队列">1.4.2. 队列</h3><p>一个很高效的函数式队列可以基于两个链表来实现。<em>front</em>链表持有<em>出队的</em>元素，<em>rear</em>链表持有<em>入队的</em>元素，入队和出队操作都是O(1)的时间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;Integer&gt; queue = Queue.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>                            .enqueue(<span class="hljs-number">4</span>)<br>                            .enqueue(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><p>队列由3个元素初始化，还有两个元素在rear列表中排队。</p><p><img src="/img/vavr-queue1.png" alt="queue1"></p><p>如果front列表在出队时元素耗尽，那么rear列表会被翻转成为新的front列表。</p><p><img src="/img/vavr-queue2.png" alt="queue2"></p><p>一个元素出队时我们会得到第一个元素和剩余队列组成的一对数据。必须返回这个队列的新版本，因为函数式数据结构是不可变且持久化的，原队列不应当受影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;Integer&gt; queue = Queue.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// = (1, Queue(2, 3))</span><br>Tuple2&lt;Integer, Queue&lt;Integer&gt;&gt; dequeued = queue.dequeue();<br></code></pre></td></tr></table></figure><p>当队列为空时会发生什么？这时dequeue()方法会抛出NoSuchElementException，用<em>函数式方式</em>来做的话我们更期望返回一个可选结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// = Some((1, Queue()))</span><br>Queue.of(<span class="hljs-number">1</span>).dequeueOption();<br><br><span class="hljs-comment">// = None</span><br>Queue.empty().dequeueOption();<br></code></pre></td></tr></table></figure><p>一个可选结果可以被进一步处理，不管它是否为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// = Queue(1)</span><br>Queue&lt;Integer&gt; queue = Queue.of(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// = Some((1, Queue()))</span><br>Option&lt;Tuple2&lt;Integer, Queue&lt;Integer&gt;&gt;&gt; dequeued = queue.dequeueOption();<br><br><span class="hljs-comment">// = Some(1)</span><br>Option&lt;Integer&gt; element = dequeued.map(Tuple2::_1);<br><br><span class="hljs-comment">// = Some(Queue())</span><br>Option&lt;Queue&lt;Integer&gt;&gt; remaining = dequeued.map(Tuple2::_2);<br></code></pre></td></tr></table></figure><h3 id="1-4-3-有序集合-sup-id-fnref-4-class-footnote-ref-a-href-fn-4-rel-footnote-span-class-hint-top-hint-rounded-aria-label-这里的集合是指Set。-4-span-a-sup">1.4.3. 有序集合<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="这里的集合是指Set。">[4]</span></a></sup></h3><p>有序集合是比队列使用得更频繁的一种数据结构。我们使用二叉搜索树以函数式方式给它们建模，这些树由一些节点组成，每个节点有一个值且最多只能拥有两个孩子节点。</p><p>我们会在排序的情况下 - 使用一个元素比较器来表达，构建二叉搜索树。任何给定节点的左子树的值都严格地小于当前给定节点的值，而所有右子树的值则严格地大于。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// = TreeSet(1, 2, 3, 4, 6, 7, 8)</span><br>SortedSet&lt;Integer&gt; xs = TreeSet.of(<span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure><p><img src="/img/vavr-binarytree1.png" alt="binarytree1"></p><p>这棵树的查询时间复杂度为O(log~n~)。我们从根节点开始搜索，并判断是否找到了目标元素。由于所有的值是整体有序的，所以我们知道下一步该从何处进行搜索，是这棵树的左分支还是右分支。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// = TreeSet(1, 2, 3);</span><br>SortedSet&lt;Integer&gt; set = TreeSet.of(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// = TreeSet(3, 2, 1);</span><br>Comparator&lt;Integer&gt; c = (a, b) -&gt; b - a;<br>SortedSet&lt;Integer&gt; reversed = TreeSet.of(c, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>大部分树的操作本质上都是<a href="https://en.wikipedia.org/wiki/Recursion">递归</a>。插入函数和搜索函数很类似，当一条搜索路径抵达终点时，会创建一个新节点，然后整个路径会重建到根节点，（在此期间会）尽可能的引用现有的子节点。因此插入操作会花费O(log~n~)的时间和空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// = TreeSet(1, 2, 3, 4, 5, 6, 7, 8)</span><br>SortedSet&lt;Integer&gt; ys = xs.add(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><p><img src="/img/vavr-binarytree2.png" alt="binarytree2"></p><p>为了保持二叉搜索树的性能特点，它需要保持一个平衡。所有从根节点到叶子节点的路径需要在大体上保持等长。</p><p>在Vavr里面我们基于<a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">红黑树</a>实现了一个二叉搜索树，它使用一种特殊的着色方式来使得二叉树在插入和删除节点时保持平衡。</p><p>如想了解更多关于本章节主题的内容，请查阅Chris Okasaki的书籍 <a href="http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504">Purely Functional Data Structures</a>。</p><h2 id="1-5-集合的状态">1.5. 集合的状态</h2><p>一般来说，我们看到的是目前编程语言的趋同。优秀的特性会保留，反之则会消亡。但是Java不同，它注定要一直向后兼容，这是一种优势但也会延缓发展速度。</p><p>Lambda拉近了Java和Scala的距离，当然他们还是不一样的。Scala之父，Martin Odersky，最近在他的<a href="https://www.youtube.com/watch?v=NW5h8d_ZyOs">BDSBTB 2015 keynote</a>里就提到了Java8集合的状态。</p><p>他把Java的Stream形容成一种很花哨的迭代器。Java8 Stream API是一个<em>lifted</em>集合的示例，它所做的就是<em>定义</em>一次计算并在另一个明确的步骤中把它<em>link</em>到一个特定的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// i + 1</span><br>i.prepareForAddition()<br> .add(<span class="hljs-number">1</span>)<br> .mapBackToInteger(Mappers.toInteger())<br></code></pre></td></tr></table></figure><p>这就是新的Java8 Stream API的工作机制，它就是一个在人所熟知的Java集合之上的计算层。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;] in Java 8</span><br>Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>      .stream()<br>      .map(Object::toString)<br>      .collect(Collectors.toList())<br></code></pre></td></tr></table></figure><p>Vavr则深受Scala的启发。上面的例子在Java8中本应该是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// = Stream(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;) in Vavr</span><br>Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).map(Object::toString)<br></code></pre></td></tr></table></figure><p>过去一年我们在实现Vavr集合库上面付出了很大的努力，它包含了绝大多数的被广泛使用的集合类型。</p><h3 id="1-5-1-Seq">1.5.1. Seq</h3><p>我们通过实现序列类型来开启我们的旅程。在上面我们已经详述了链表，之后的Stream是一个惰性链表。它允许我们处理可能的无限长度的元素序列。</p><p><img src="/img/vavr-collections-seq.png" alt="collections-seq"></p><p>所有集合都是迭代器，因此能够被用在增强型for语句里面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (String s : List.of(<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;Advent&quot;</span>)) &#123;<br>    <span class="hljs-comment">// side effects and mutation</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以通过内部化循环并使用lambda注入行为来达到同样的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List.of(<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;Advent&quot;</span>).forEach(s -&gt; &#123;<br>    <span class="hljs-comment">// side effects and mutation</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>总之，如前所见我们更期望的是返回一个带值的表达式而不是不返回任何东西的语句。通过一个简单的例子，我们马上就能意识到这种语句会带来干扰并且会把一个整体的东西分割开。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">String <span class="hljs-title function_">join</span><span class="hljs-params">(String... words)</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">for</span>(String s : words) &#123;<br>        <span class="hljs-keyword">if</span> (builder.length() &gt; <span class="hljs-number">0</span>) &#123;<br>            builder.append(<span class="hljs-string">&quot;, &quot;</span>);<br>        &#125;<br>        builder.append(s);<br>    &#125;<br>    <span class="hljs-keyword">return</span> builder.toString();<br>&#125;<br></code></pre></td></tr></table></figure><p>Vavr集合提供了很多操作底层元素的函数，这让我们可以用很简洁的方式来表达某些事物：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">String <span class="hljs-title function_">join</span><span class="hljs-params">(String... words)</span> &#123;<br>    <span class="hljs-keyword">return</span> List.of(words)<br>               .intersperse(<span class="hljs-string">&quot;, &quot;</span>)<br>               .foldLeft(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(), StringBuilder::append)<br>               .toString();<br>&#125;<br></code></pre></td></tr></table></figure><p>Vavr可以用各种不同的方式来实现许多目标。在这里我们可以通过缩减整个方法体来使列表实例上的函数调用变得更流畅，甚至可以移除这个方法然后直接用我们的列表来获取计算结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List.of(words).mkString(<span class="hljs-string">&quot;, &quot;</span>);<br></code></pre></td></tr></table></figure><p>在实际应用中我们可以借此大幅减少代码行数，也降低了出现bug的风险。</p><h3 id="1-5-2-Set和Map">1.5.2. Set和Map</h3><p>序列固然很棒，但就完整性来讲，一个集合库也需要不同类型的Sets和Maps。</p><p><img src="/img/vavr-collections-set-map.png" alt="collections-set-map"></p><p>我们已经描述过如何通过二叉搜索树为有序集合进行建模，而一个有序的Map也不过是一个包含键值对且对键进行了排序的有序集合。</p><p>HashMap的实现是依赖于<a href="http://lampwww.epfl.ch/papers/idealhashtrees.pdf">Hash Array Mapped Trie (HAMT)</a>，对应的HashSet也是依赖于一个包含键键对（key-key pairs）的HAMT。</p><p>我们的Map<em>没有</em>一个特殊的Entry类型来表示键值对，作为替代使用的是Vavr中的Tuple2。一个Tuple<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="**多元组**，也称为**顺序组**（英语：Tuple），泛指有限个[元素](https://zh.m.wikipedia.org/wiki/元素_(數學))所组成的[序列](https://zh.m.wikipedia.org/wiki/序列)。在数学及计算机科学分别有其特殊的意义。">[5]</span></a></sup>中的字段总是可枚举的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// = (1, &quot;A&quot;)</span><br>Tuple2&lt;Integer, String&gt; entry = Tuple.of(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>);<br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> entry._1;<br><span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> entry._2;<br></code></pre></td></tr></table></figure><p>Maps和Tuples在Vavr中广泛被应用。把Tuples作为处理多值返回类型的一种通用方式已经是惯例了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// = HashMap((0, List(2, 4)), (1, List(1, 3)))</span><br>List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).groupBy(i -&gt; i % <span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// = List((a, 0), (b, 1), (c, 2))</span><br>List.of(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>).zipWithIndex();<br></code></pre></td></tr></table></figure><p>在Vavr里，我们会通过实现<a href="https://projecteuler.net/archives">99 Euler Problems</a>来考察以及测试我们的库，这是一个很棒的概念性验证，请不要吝啬给我们的库推送PR。</p><section class="footnotes"><hr><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>mutator methods：<a href="https://en.wikipedia.org/wiki/Mutator_method%E3%80%82">https://en.wikipedia.org/wiki/Mutator_method。</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>查看源码可知，这里是按3、2、1的顺序进行构建的，对整个链表的遍历，则会按照1、2、3的顺序输出，遵循后进先出原则。整个链表遍历顺序的<strong>头节点是1，尾节点是3</strong>。<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>此时的<strong>尾部</strong>不是按链表的遍历顺序，而是按构建链表时的顺序来定义的。<strong>头元素0</strong>会变成新版本链表遍历顺序的头节点。更新后的新版本链表，遍历出来的结果就是0、2、3。<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>这里的集合是指Set。<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><strong>多元组</strong>，也称为<strong>顺序组</strong>（英语：Tuple），泛指有限个<a href="https://zh.m.wikipedia.org/wiki/%E5%85%83%E7%B4%A0_(%E6%95%B8%E5%AD%B8)">元素</a>所组成的<a href="https://zh.m.wikipedia.org/wiki/%E5%BA%8F%E5%88%97">序列</a>。在数学及计算机科学分别有其特殊的意义。<a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>函数式编程</tag>
      
      <tag>vavr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数式编程增强库Vavr初探（一）</title>
    <link href="/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%A2%9E%E5%BC%BA%E5%BA%93vavr%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%A2%9E%E5%BC%BA%E5%BA%93vavr%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/vavr-io/vavr">Vavr</a>是对Java8（及以上版本）的函数式编程体验的增强库，官方介绍如下：</p><blockquote><p>Vavr is an object-functional language extension to Java 8, which aims to reduce the lines of code and increase code quality. It provides persistent collections, functional abstractions for error handling, concurrent programming, pattern matching and much more.<br>Vavr是对Java8的对象-函数式语言的扩展，目的是减少代码行数并提高代码质量。提供了持久化集合，针对错误处理的函数式抽象，并发编程，模式匹配以及其他更丰富的内容。</p></blockquote><p>本文主要是翻译至Vavr官方文档中的<a href="https://docs.vavr.io/#_usage_guide">使用指南</a>部分，会出现一些术语，主要参考维基百科。</p><h1>3. 使用指南</h1><p>Vavr带来的是对一些最基础类型 — 很明显，在Java中是缺失的或者（实现地）比较简陋，的精心设计的表征：<code>Tuple</code>，<code>Value</code>和<code>λ</code>。</p><p>在Vavr中，一切（实现）都是基于这三个最基本的构建块（building blocks）：</p><p><img src="/img/vavr01.jpeg" alt=""></p><h2 id="3-1-多元组-sup-id-fnref-1-class-footnote-ref-a-href-fn-1-rel-footnote-span-class-hint-top-hint-rounded-aria-label-多元组-，也称为-顺序组-（英语：Tuple），泛指有限个-元素-https-zh-m-wikipedia-org-wiki-元素-數學-所组成的-序列-https-zh-m-wikipedia-org-wiki-序列-。在数学及计算机科学分别有其特殊的意义。-1-span-a-sup">3.1. 多元组<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="**多元组**，也称为**顺序组**（英语：Tuple），泛指有限个[元素](https://zh.m.wikipedia.org/wiki/元素_(數學))所组成的[序列](https://zh.m.wikipedia.org/wiki/序列)。在数学及计算机科学分别有其特殊的意义。">[1]</span></a></sup></h2><p>Java里面没有一个针对多元组的整体概念。一个Tuple可以将固定数量的元素组合在一起作为一个整体进行传递。不同于Array或者List，它可以持有不同类型的对象，但同时也是不可变的。</p><p>多元组的类型有Tuple1，Tuple2，Tuple3等等，目前最多支持8个元素。对于一个多元组 <code>t</code>，可以通过<code>t._1</code>方法访问它的第一个元素，<code>t._2</code>方法访问第二个，以此类推。</p><h3 id="3-1-1-创建多元组">3.1.1. 创建多元组</h3><p>接下来通过一个示例来演示如何创建一个持有String和Integer两种类型的元素的多元组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// (Java，8)</span><br>Tuple2&lt;String, Integer&gt; java8 = Tuple.of(<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-number">8</span>); ❶<br><br><span class="hljs-comment">// &quot;Java&quot;</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> java8._1; ❷<br><br><span class="hljs-comment">// 8</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> java8._2; ❸<br></code></pre></td></tr></table></figure><p>❶ 通过静态工厂方法<code>Tuple.of()</code>来创建一个多元组。</p><p>❷ 获取这个多元组的第一个元素。</p><p>❸ 获取这个多元组的第二个元素。</p><h3 id="3-1-2-组件映射">3.1.2. 组件映射</h3><p>组件映射就是为多元组的每一个元素执行一个函数，然后返回一个新的多元组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// (vavr, 1)</span><br>Tuple2&lt;String, Integer&gt; that = java8.map(<br>s -&gt; s.substring(<span class="hljs-number">2</span>) + <span class="hljs-string">&quot;vr&quot;</span>,<br>    i -&gt; i / <span class="hljs-number">8</span><br>);<br></code></pre></td></tr></table></figure><h3 id="3-1-3-单映射器映射">3.1.3. 单映射器映射</h3><p>当然，也可以通过一个映射函数来映射一个多元组（中的所有元素）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// (vavr, 1)</span><br>Tuple2&lt;String, Integer&gt; that = java8.map(<br>(s, i) -&gt; Tuple.of(s.substring(<span class="hljs-number">2</span>) + <span class="hljs-string">&quot;vr&quot;</span>, i / <span class="hljs-number">8</span>)<br>);<br></code></pre></td></tr></table></figure><h3 id="3-1-4-多元组变换">3.1.4. 多元组变换</h3><p>根据多元组的内容，变换操作可以得到一个新的类型的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// &quot;vavr 1&quot;</span><br><span class="hljs-type">String</span> <span class="hljs-variable">that</span> <span class="hljs-operator">=</span> java8.apply(<br>(s, i) -&gt; s.substring(<span class="hljs-number">2</span>) + <span class="hljs-string">&quot;vr &quot;</span> + i / <span class="hljs-number">8</span><br>);<br></code></pre></td></tr></table></figure><h2 id="3-2-函数">3.2. 函数</h2><p>函数式编程的所有工作都与值有关并能使用函数对值进行变换。Java8仅提供了一个接收单个参数的<code>Function</code>和一个接收两个参数的<code>BiFunction</code>，Vavr则把这个参数上限提高到了8个。这些函数式接口被命名为<code>Function0,Function1,Function2,Function3</code>等以此类推。如果需要能抛出检查异常的函数，则可以使用<code>CheckedFunction1,CheckedFunction2</code>等等。</p><p>下面的lambda表达式创建了一个两数相加的函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// sum.apply(1, 2) = 3</span><br>Function2&lt;Integer, Integer, Integer&gt; sum = (a,b) -&gt; a + b;<br></code></pre></td></tr></table></figure><p>这种实现是对下面这种匿名类实现的简写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Function2&lt;Integer, Integer, Integer&gt; sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function2</span>&lt;Integer, Integer, Integer&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">apply</span><span class="hljs-params">(Integer a, Integer b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当然也可以使用静态工厂方法<code>Function3.of(...)</code>接收任意的方法引用来创建函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Function3&lt;String, String, String, String&gt; function3 =<br>        Function3.of(<span class="hljs-built_in">this</span>::methodWhichAccepts3Parameters);<br></code></pre></td></tr></table></figure><p>实际上，Vavr的函数式接口是针对Java8函数式接口的“类固醇”（意思是增强），也提供了更多的特性如：</p><ul><li>组合（Composition）</li><li>提升（Lifting）</li><li>柯里化（Currying）</li><li>记忆化（Memoization）</li></ul><h3 id="3-2-1-组合">3.2.1. 组合</h3><p>对函数可以进行组合。在数学中，函数组合是指把一个函数应用到另一个函数的结果当中从而产生第三个函数。举个例子，函数<code>f: X → Y</code>和函数<code>g: Y → Z</code>可以组合生成一个新的函数<code>h:g(f(X))</code>就能得到<code>X → Z</code>的映射。</p><p>（要实现组合）可以使用<code>andThen</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Function1&lt;Integer, Integer&gt; plusOne = a -&gt; a + <span class="hljs-number">1</span>;<br>Function1&lt;Integer, Integer&gt; multiplyByTwo = a -&gt; a * <span class="hljs-number">2</span>;<br><br>Function1&lt;Integer, Integer&gt; add1AndMultiplyBy2 = plusOne.andThen(multiplyByTwo);<br><br>then(add1AndMultiplyBy2.apply(<span class="hljs-number">2</span>)).isEqualTo(<span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><p>或者<code>compose</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Function1&lt;Integer, Integer&gt; add1AndMultiplyBy2 = multiplyByTwo.compose(plusOne);<br><br>then(add1AndMultiplyBy2.apply(<span class="hljs-number">2</span>)).isEqualTo(<span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><h3 id="3-2-2-提升">3.2.2. 提升</h3><p>我们可以把一个偏函数<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="偏函数和全函数的定义没有找到中文的百科，英语百科中都对应一个词条：https://en.wikipedia.org/wiki/Partial_function">[2]</span></a></sup>提升为一个返回<code>Option</code>结果的全函数<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="偏函数和全函数的定义没有找到中文的百科，英语百科中都对应一个词条：https://en.wikipedia.org/wiki/Partial_function">[2]</span></a></sup>。<em>偏函数</em> 是数学中的术语，一个从X到Y的偏函数就是函数 f: X’ → Y，X’是X的某个子集。它通过不强制函数f将X中的每一个元素都映射到Y中对应的元素来概括一个函数 f: X → Y的概念。这就意味着偏函数仅适用于某些输入值，如果有非法的输入值调用了函数，那么通常会抛出异常。</p><p>下面的方法<code>divide</code>是一个只接收非零除数的偏函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Function2&lt;Integer, Integer, Integer&gt; divide = (a, b) -&gt; a / b;<br></code></pre></td></tr></table></figure><p>我们可以使用<code>lift</code>方法把<code>divide</code>变成一个可以接受所有输入的全函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Function2&lt;Integer, Integer, Option&lt;Integer&gt;&gt; safeDivide = Function2.lift(divide);<br><br><span class="hljs-comment">// = None</span><br>Option&lt;Integer&gt; i1 = safeDivide.apply(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>); ❶<br><br><span class="hljs-comment">// = Some(2)</span><br>Option&lt;Integer&gt; i2 = safeDivide.apply(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>); ❷<br></code></pre></td></tr></table></figure><p>❶ 如果使用非法的输入值执行函数，被提升的函数会返回<code>None</code>来替代抛出异常。</p><p>❷ 如果使用合法的输入值执行函数，被提升的函数会返回<code>Some</code>。</p><p>下面的方法<code>sum</code>是一个只接收正数输入的偏函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> first, <span class="hljs-type">int</span> second)</span> &#123;<br>    <span class="hljs-keyword">if</span> (first &lt; <span class="hljs-number">0</span> || second &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Only positive integers are allowed&quot;</span>); ❶<br>    &#125;<br>    <span class="hljs-keyword">return</span> first + second;<br>&#125;<br></code></pre></td></tr></table></figure><p>❶ 传入负数，函数<code>sum</code>会抛出<code>IllegalArgumentException</code>。</p><p>我们也可以通过方法引用来提升<code>sum</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Function2&lt;Integer, Integer, Option&lt;Integer&gt;&gt; sum = Function2.lift(<span class="hljs-built_in">this</span>::sum);<br><br><span class="hljs-comment">// = None</span><br>Option&lt;Integer&gt; optionalResult = sum.apply(-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); ❶<br></code></pre></td></tr></table></figure><p>❶ 被提升的函数会捕捉到<code>IllegalArgumentException</code>并映射成<code>None</code>进行返回。</p><h3 id="3-2-3-偏函数应用（Partial-application）">3.2.3. 偏函数应用（Partial application）</h3><p>偏函数应用允许你用一个已有的函数通过固定某些值（指参数值）来派生出一个新的函数。你可以固定一个或者多个参数，而且要固定的参数数量会决定新函数的参数数量，这样<code>新参数数量 = （原参数数量 - 要固定的参数数量）</code>。参数都是从左向右依次绑定的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Function2&lt;Integer, Integer, Integer&gt; sum = (a, b) -&gt; a + b;<br>Function1&lt;Integer, Integer&gt; add2 = sum.apply(<span class="hljs-number">2</span>); ❶<br><br>then(add2.apply(<span class="hljs-number">4</span>)).isEqualTo(<span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><p>❶ 第一个参数<code>a</code>的值被固定为2。</p><p>接下来展示的是一个固定了前3个参数的<code>Function5</code>，返回的是一个<code>Function2</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Function5&lt;Integer, Integer, Integer, Integer, Integer, Integer&gt; sum = (a, b, c, d, e) -&gt; a + b + c + d + e;<br>Function2&lt;Integer, Integer, Integer&gt; add6 = sum.apply(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>); ❶<br><br>then(add6.apply(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>)).isEqualTo(<span class="hljs-number">13</span>);<br></code></pre></td></tr></table></figure><p>❶ 参数<code>a</code>，<code>b</code>，<code>c</code>的值被分别固定成了2，3，1。</p><p>偏函数应用不同于柯里化，会在接下来的章节中进行讨论。</p><h3 id="3-2-4-柯里化">3.2.4. 柯里化</h3><p>柯里化是一种通过固定其中一个参数的值来部分的应用一个函数的技术，从而得到一个返回<code>Function1</code>的<code>Function1</code>函数。</p><p>当函数<code>Function2</code>被<em>柯里化</em>后，得到的结果和对<code>Function2</code>进行<em>偏函数应用</em>的结果很难区别，因为两者都是一个一元函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Function2&lt;Integer, Integer, Integer&gt; sum = (a, b) -&gt; a + b;<br>Function1&lt;Integer, Integer&gt; add2 = sum.curried().apply(<span class="hljs-number">2</span>); ❶<br><br>then(add2.apply(<span class="hljs-number">4</span>)).isEqualTo(<span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><p>❶ 第一个参数的值被固定为2。</p><p>这时你可能注意到了，除了使用了<code>.curried()</code>方法以外，这部分代码和<a href="#3.2.3.-%E5%81%8F%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%EF%BC%88Partial-application%EF%BC%89">偏函数应用</a>章节中给出的二元函数的例子是一模一样的。但是，在更多元的函数中，它们之间的区别会变得越来越明显。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Function3&lt;Integer, Integer, Integer, Integer&gt; sum = (a, b, c) -&gt; a + b + c;<br><span class="hljs-keyword">final</span> Function1&lt;Integer, Function1&lt;Integer, Integer&gt;&gt; add2 = sum.curried().apply(<span class="hljs-number">2</span>); ❶<br><br>then(add2.apply(<span class="hljs-number">4</span>).apply(<span class="hljs-number">3</span>)).isEqualTo(<span class="hljs-number">9</span>); ❷<br></code></pre></td></tr></table></figure><p>❶ 注意参数中存在的额外的函数。</p><p>❷ 除了最后一次调用以外，对<code>apply</code>的进一步调用会返回不同的函数<code>Function1</code>。</p><h3 id="3-2-5-记忆化">3.2.5. 记忆化</h3><p>记忆化是缓存的一种形式。一个有记忆的函数只会执行一次然后（之后的执行）会从缓存中取值进行返回。在下面的示例中，第一次执行会计算得到一个随机数然后在第二次执行时会返回缓存的这个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Function0&lt;Double&gt; hashCache =<br>    Function0.of(Math::random).memoized();<br><br><span class="hljs-type">double</span> <span class="hljs-variable">randomValue1</span> <span class="hljs-operator">=</span> hashCache.apply();<br><span class="hljs-type">double</span> <span class="hljs-variable">randomValue2</span> <span class="hljs-operator">=</span> hashCache.apply();<br><br>then(randomValue1).isEqualTo(randomValue2);<br></code></pre></td></tr></table></figure><h2 id="3-3-值">3.3. 值</h2><p>在函数式环境中，我们把值认作是一种<a href="https://en.wikipedia.org/wiki/Normal_form_(abstract_rewriting)">范式</a>（normal form），一个无法进一步求值的表达式。在Java中我们通过把一个对象的状态设置为final并称它为<a href="https://en.wikipedia.org/wiki/Immutable_object">不可变对象</a>来表达这种含义。</p><p>Vavr中的函数值则对不可变对象进行了抽象，通过在实例之间共享不可变内存实现了高效的写操作。我们就&quot;免费&quot;实现了线程安全！（共享不可变内存这里我理解为Java中final或static final的变量，天然具备线程安全的特性，无需花费额外的成本。）</p><h3 id="3-3-1-Option">3.3.1. Option</h3><p>Option是一个单子<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="在[函数式编程](https://zh.wikipedia.org/wiki/函数式编程)中，**单子**（monad）是一种抽象，它允许以[泛型](https://zh.wikipedia.org/wiki/泛型编程)方式构造程序。支持它的语言可以使用单子来抽象出程序逻辑需要的[样板代码](https://zh.wikipedia.org/w/index.php?title=样板代码&action=edit&redlink=1)。">[3]</span></a></sup>容器类型，代表着一个可选值。Option的实例要么是<code>Some</code>的实例，要么是<code>None</code>的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// optional *value*, no more nulls</span><br>Option&lt;T&gt; option = Option.of(...);<br></code></pre></td></tr></table></figure><p>如果你在使用了Java中的<code>Optional</code>类后再接触Vavr（中的<code>Option</code>），会发现一个很关键的不同点。在<code>Optional</code>里面，调用<code>.map</code>方法然后使其返回null会得到一个空的<code>Optional</code>。而在Vavr里面，会得到一个<code>Some(null)</code>然后导致<code>NullPointerException</code>。</p><p>使用<code>Optional</code>，在下面的场景中是合理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;String&gt; maybeFoo = Optional.of(<span class="hljs-string">&quot;foo&quot;</span>); ❶<br>then(maybeFoo.get()).isEqualTo(<span class="hljs-string">&quot;foo&quot;</span>);<br>Optional&lt;String&gt; maybeFooBar = maybeFoo.map(s -&gt; (String)<span class="hljs-literal">null</span>) ❷<br>                                       .map(s -&gt; s.toUpperCase() + <span class="hljs-string">&quot;bar&quot;</span>);<br>then(maybeFooBar.isPresent()).isFalse();<br></code></pre></td></tr></table></figure><p>❶ 可选项是<code>Some(&quot;foo&quot;)</code>。</p><p>❷ 结果选项在这里就变成了空。</p><p>而使用了Vavr的<code>Option</code>，在同样的场景下会返回<code>NullPointerException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Option&lt;String&gt; maybeFoo = Option.of(<span class="hljs-string">&quot;foo&quot;</span>); ❶<br>then(maybeFoo.get()).isEqualTo(<span class="hljs-string">&quot;foo&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>    maybeFoo.map(s -&gt; (String)<span class="hljs-literal">null</span>) ❷<br>            .map(s -&gt; s.toUpperCase() + <span class="hljs-string">&quot;bar&quot;</span>); ❸<br>    Assert.fail();<br>&#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123;<br>    <span class="hljs-comment">// this is clearly not the correct approach</span><br>&#125;<br></code></pre></td></tr></table></figure><p>❶ 可选项是<code>Some(&quot;foo&quot;)</code>。</p><p>❷ 结果选项在这里会是<code>Some(null)</code>。</p><p>❸ 在<code>null</code>上去执行<code>s.toUpperCase()</code>的调用（会抛错）。</p><p>看起来Vavr的实现好像违背了一些准则，但实际上并没有，它始终遵循着单子在调用<code>.map</code>时维护计算上下文的要求。对于一个<code>Option</code>而言，这就意味着在<code>Some</code>上调用<code>.map</code>会返回<code>Some</code>，在<code>None</code>上调用<code>.map</code>会返回<code>None</code>。而在上面的Java的<code>Optional</code>例子中，上下文从<code>Some</code>变成了<code>None</code>。</p><p>这样看起来<code>Option</code>好像没什么用，但实际上它会强制你关注可能会出现<code>null</code>的场景并能合理的处理它们而不是在不知不觉中接受了它们，而处理<code>null</code>的合理的方式就是使用<code>flatMap</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Option&lt;String&gt; maybeFoo = Option.of(<span class="hljs-string">&quot;foo&quot;</span>); ❶<br>then(maybeFoo.get()).isEqualTo(<span class="hljs-string">&quot;foo&quot;</span>);<br>Option&lt;String&gt; maybeFooBar = maybeFoo.map(s -&gt; (String) <span class="hljs-literal">null</span>) ❷<br>                                .flatMap(s -&gt; Option.of(s) ❸<br>                                    .map(t -&gt; t.toUpperCase() + <span class="hljs-string">&quot;bar&quot;</span>));<br>then(maybeFooBar.isEmpty()).isTrue();<br></code></pre></td></tr></table></figure><p>❶ 可选项是<code>Some(&quot;foo&quot;)</code>。</p><p>❷ 结果选项在这里会是<code>Some(null)</code>。</p><p>❸ <code>s</code>，在这里它的值是<code>null</code>，会变成<code>None</code>。</p><p>或者，可以把<code>.flatMap</code>直接放到有可能出现<code>null</code>值的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Option&lt;String&gt; maybeFoo = Option.of(<span class="hljs-string">&quot;foo&quot;</span>); ❶<br>then(maybeFoo.get()).isEqualTo(<span class="hljs-string">&quot;foo&quot;</span>);<br>Option&lt;String&gt; maybeFooBar = maybeFoo.flatMap(s -&gt; Option.of((String)<span class="hljs-literal">null</span>)) ❷<br>                                     .map(s -&gt; s.toUpperCase() + <span class="hljs-string">&quot;bar&quot;</span>);<br>then(maybeFooBar.isEmpty()).isTrue();<br></code></pre></td></tr></table></figure><p>❶ 可选项是<code>Some(&quot;foo&quot;)</code>。</p><p>❷ 结果选项是<code>None</code>。</p><p><a href="http://blog.vavr.io/the-agonizing-death-of-an-astronaut/">Vavr博客</a>中对此进行了更详细的探讨。</p><h3 id="3-3-2-Try">3.3.2. Try</h3><p>Try是一个单子容器类型，表示一次要么返回异常，要么返回计算成功的值的计算。和<code>Either</code>有点类似，但在语义上又有所区别。Try的实例都是<code>Success</code>或者<code>Failure</code>的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// no need to handle exceptions</span><br>Try.of(() -&gt; bunchOfWork()).getOrElse(other);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> io.vavr.API.*;        <span class="hljs-comment">// $, Case, Match</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> io.vavr.Predicates.*; <span class="hljs-comment">// instanceOf</span><br><br><span class="hljs-type">A</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Try.of(<span class="hljs-built_in">this</span>::bunchOfWork)<br>    .recover(x -&gt; Match(x).of(<br>        Case($(instanceOf(Exception_1.class)), t -&gt; somethingWithException(t)),<br>        Case($(instanceOf(Exception_2.class)), t -&gt; somethingWithException(t)),<br>        Case($(instanceOf(Exception_n.class)), t -&gt; somethingWithException(t))<br>    ))<br>    .getOrElse(other);<br></code></pre></td></tr></table></figure><h3 id="3-3-3-Lazy">3.3.3. Lazy</h3><p>Lazy是一个单子容器类型，表示一个惰性计算的值。同Supplier相比，Lazy是有记忆的，即它只会执行一次并由此具有了<a href="https://en.wikipedia.org/wiki/Referential_transparency">引用透明性</a>（一个表达式在程序中可以被它等价的值替换，而不影响结果）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Lazy&lt;Double&gt; lazy = Lazy.of(Math::random);<br>lazy.isEvaluated(); <span class="hljs-comment">// = false</span><br>lazy.get();         <span class="hljs-comment">// = 0.123 (random generated)</span><br>lazy.isEvaluated(); <span class="hljs-comment">// = true</span><br>lazy.get();         <span class="hljs-comment">// = 0.123 (memoized)</span><br></code></pre></td></tr></table></figure><p>你也可以（通过Lazy）创建一个真正的惰性值（只适用于接口（interfaces））：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CharSequence</span> <span class="hljs-variable">chars</span> <span class="hljs-operator">=</span> Lazy.val(() -&gt; <span class="hljs-string">&quot;Yay!&quot;</span>, CharSequence.class); <span class="hljs-comment">// 第二个参数是一个interface</span><br></code></pre></td></tr></table></figure><h3 id="3-3-4-Either">3.3.4. Either</h3><p>Either表示的是两种可能类型的值。一个Either只会是Left或者Right。如果一个给定的Either是Right，然后把它投射给Left，那么对Left的操作不会对Right的值有任何影响。同样的，如果一个给定的Either是Left，然后把它投射给Right，那么对Right的操作也不会对Left的值有任何影响。如果Left投射给Left或者Right投射给Right，那么这些操作就会互相产生影响。</p><p>例：一个compute()函数，返回了一个Integer值（成功的情况下）或者返回一个String类型的错误信息（失败的情况下）。按惯例，成功的情况下返回Right，失败的情况下返回Left。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Either&lt;String,Integer&gt; value = compute().right().map(i -&gt; i * <span class="hljs-number">2</span>).toEither();<br></code></pre></td></tr></table></figure><p>如果compute()的结果是Right(1)，value的值就是Right(2)。</p><p>如果compute()的结果是Left(“error”)，value的值就是Left(“error”)。</p><h3 id="3-3-5-Future">3.3.5. Future</h3><p>Future是一个在某个不确定的时刻才会变得可用的计算结果。它提供的所有操作都是非阻塞的，底层的ExecutorService通常被用做执行异步处理程序，比如onComplete(…)。</p><p>一个Future有两种状态：等待中和已完成。</p><p><strong>等待中：</strong> 计算正在进行当中，只有一个处于等待中的future才能被标记为已完成或者已撤销。</p><p><strong>已完成：</strong> 计算完成后，返回结果就是成功，返回异常或者被撤销则是失败。</p><p>回调可以在任意时间点上被注册到Future。当Future完成时，这些（回调）动作会被执行。注册到已完成的Future上的动作会被立即执行，它可能会运行在一个独立的线程中，这取决于底层的ExecutorService。而那些注册到被撤销的Future上的动作会带着失败的结果被执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// future *value*, result of an async calculation</span><br>Future&lt;T&gt; future = Future.of(...);<br></code></pre></td></tr></table></figure><h3 id="3-3-6-Validation">3.3.6. Validation</h3><p>Validation控件是一个<em>应用式函子</em><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="在[函数式编程](https://zh.wikipedia.org/wiki/函数式编程)中， **应用式函子**，或简称应用式（applicative），是在[函子](https://zh.wikipedia.org/wiki/函子_(函数式编程))和[单子](https://zh.wikipedia.org/wiki/单子_(函数式编程))之间的中间结构。应用式函子允许函子式计算成为序列（不同于平常函子），但是不允许使用前面计算的结果于后续计算的定义之中（不同于单子）。">[4]</span></a></sup>，有助于累积错误。在我们尝试组合单子时，会在第一次遇到错误时短路。但是’Validation’可以继续这个组合过程，并累积所有错误。这在对多个字段做校验时尤其有用，比方说一个web表单，你肯定是想一次请求拿到所有可能遇见的错误，而不是一次一个。</p><p>例：在一个web表单中，有’name’和’age’两个字段，希望（提交后）要么创建一个有效的Person实例，要么返回校验的错误列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">PersonValidator</span> <span class="hljs-variable">personValidator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PersonValidator</span>();<br><br><span class="hljs-comment">// Valid(Person(John Dow, 30))</span><br>Validation&lt;Seq&lt;String&gt;, Person&gt; valid = personValidator.validatePerson(<span class="hljs-string">&quot;John Doe&quot;</span>, <span class="hljs-number">30</span>);<br><br><span class="hljs-comment">// Invalid(List(Name contains invalid characters: &#x27;!4?&#x27;, Age must be greater than 0))</span><br>Validation&lt;Seq&lt;String&gt;, Person&gt; invalid = personValidator.validatePerson(<span class="hljs-string">&quot;John? Doe!4&quot;</span>, -<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><code>Validation.Valid</code>实例包含了一个有效的值，而<code>Validation.Invalid</code>实例则包含了一组校验的错误列表。</p><p>下面的这个校验器就是用来把不同的校验结果合并成一个<code>Validation</code>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonValidator</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">VALID_NAME_CHARS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;[a-zA-Z ]&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_AGE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> Validation&lt;Seq&lt;String&gt;, Person&gt; <span class="hljs-title function_">validatePerson</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-keyword">return</span> Validation.combine(validateName(name), validateAge(age)).ap(Person::<span class="hljs-keyword">new</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Validation&lt;String, String&gt; <span class="hljs-title function_">validateName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">return</span> CharSeq.of(name).replaceAll(VALID_NAME_CHARS, <span class="hljs-string">&quot;&quot;</span>).transform(seq -&gt; seq.isEmpty()<br>                ? Validation.valid(name)<br>                : Validation.invalid(<span class="hljs-string">&quot;Name contains invalid characters: &#x27;&quot;</span><br>                + seq.distinct().sorted() + <span class="hljs-string">&quot;&#x27;&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Validation&lt;String, Integer&gt; <span class="hljs-title function_">validateAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-keyword">return</span> age &lt; MIN_AGE<br>                ? Validation.invalid(<span class="hljs-string">&quot;Age must be at least &quot;</span> + MIN_AGE)<br>                : Validation.valid(age);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如果校验成功，即输入的数据是有效的，那么一个<code>Person</code>实例会根据给定的字段<code>name</code>和<code>age</code>被创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person(&quot;</span> + name + <span class="hljs-string">&quot;, &quot;</span> + age + <span class="hljs-string">&quot;)&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-4-集合">3.4 集合</h2><p>为了满足函数式编程的要求，即所谓不变性，我们做了大量的工作来为Java设计一个全新的集合库。</p><p>Java中的Stream会将计算拔高到一个不同的层次，然后在另一个显式步骤中把它关联到某个特定的集合。而在Vavr中我们抛弃了所有这些额外的公式化的东西。</p><p>新的集合是基于<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html">java.lang.Iterable</a>（来实现的），所以它们也利用了迭代风格的语法糖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1000 random numbers</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> random : Stream.continually(Math::random).take(<span class="hljs-number">1000</span>)) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><code>TraversableOnce</code>拥有大量实用的函数来操作集合，它的API和<a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">java.util.stream.Stream</a>类似，但却更加成熟。</p><h3 id="3-4-1-List">3.4.1. List</h3><p>Vavr中的<code>List</code>是一个不可变的链表。（对List的）变种（Mutations）会创建新的实例。大多数操作会在线性时间内执行，产生结果的操作将依次执行。</p><h4 id="Java8">Java8</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).stream().reduce((i, j) -&gt; i + j);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).sum();<br></code></pre></td></tr></table></figure><h4 id="Vavr">Vavr</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// io.vavr.collection.List</span><br>List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).sum();<br></code></pre></td></tr></table></figure><h3 id="3-4-2-Stream">3.4.2. Stream</h3><p><code>io.vavr.collection.Stream</code>的（底层）实现是一个惰性的链表，只有在需要时才会对值进行计算。由于它惰性的特性，大多数操作都会在常数时间内执行。操作通常会处于中间且会在一次遍历中被执行。</p><p>streams最妙的是我们可以用它们来表示（理论上）无限长的序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 2, 4, 6, ...</span><br>Stream.from(<span class="hljs-number">1</span>).filter(i -&gt; i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="3-4-3-性能特点">3.4.3. 性能特点</h3><p>表1. 序列操作的时间复杂度</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">head()</th><th style="text-align:left">tail()</th><th style="text-align:left">get(int)</th><th style="text-align:left">update(int, T)</th><th style="text-align:left">prepend(T)</th><th>append(T)</th></tr></thead><tbody><tr><td style="text-align:left">Array</td><td style="text-align:left">const</td><td style="text-align:left">linear</td><td style="text-align:left">const</td><td style="text-align:left">const</td><td style="text-align:left">linear</td><td>linear</td></tr><tr><td style="text-align:left">CharSeq</td><td style="text-align:left">const</td><td style="text-align:left">linear</td><td style="text-align:left">const</td><td style="text-align:left">linear</td><td style="text-align:left">linear</td><td>linear</td></tr><tr><td style="text-align:left">Iterator</td><td style="text-align:left">const</td><td style="text-align:left">const</td><td style="text-align:left">—</td><td style="text-align:left">—</td><td style="text-align:left">—</td><td>—</td></tr><tr><td style="text-align:left">List</td><td style="text-align:left">const</td><td style="text-align:left">const</td><td style="text-align:left">linear</td><td style="text-align:left">linear</td><td style="text-align:left">const</td><td>linear</td></tr><tr><td style="text-align:left">Queue</td><td style="text-align:left">const</td><td style="text-align:left">const^a^</td><td style="text-align:left">linear</td><td style="text-align:left">linear</td><td style="text-align:left">const</td><td>const</td></tr><tr><td style="text-align:left">PriorityQueue</td><td style="text-align:left">log</td><td style="text-align:left">log</td><td style="text-align:left">—</td><td style="text-align:left">—</td><td style="text-align:left">log</td><td>log</td></tr><tr><td style="text-align:left">Stream</td><td style="text-align:left">const</td><td style="text-align:left">const</td><td style="text-align:left">linear</td><td style="text-align:left">linear</td><td style="text-align:left">const^lazy^</td><td>const^lazy^</td></tr><tr><td style="text-align:left">Vector</td><td style="text-align:left">const^eff^</td><td style="text-align:left">const^eff^</td><td style="text-align:left">const^eff^</td><td style="text-align:left">const^eff^</td><td style="text-align:left">const^eff^</td><td>const^eff^</td></tr></tbody></table><p>表2. Map/Set操作的时间复杂度</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">contains/Key</th><th style="text-align:left">add/put</th><th style="text-align:left">remove</th><th style="text-align:left">min</th></tr></thead><tbody><tr><td style="text-align:left">HashMap</td><td style="text-align:left">const^eff^</td><td style="text-align:left">const^eff^</td><td style="text-align:left">const^eff^</td><td style="text-align:left">linear</td></tr><tr><td style="text-align:left">HashSet</td><td style="text-align:left">const^eff^</td><td style="text-align:left">const^eff^</td><td style="text-align:left">const^eff^</td><td style="text-align:left">linear</td></tr><tr><td style="text-align:left">LinkedHashMap</td><td style="text-align:left">const^eff^</td><td style="text-align:left">linear</td><td style="text-align:left">linear</td><td style="text-align:left">linear</td></tr><tr><td style="text-align:left">LinkedHashSet</td><td style="text-align:left">const^eff^</td><td style="text-align:left">linear</td><td style="text-align:left">linear</td><td style="text-align:left">linear</td></tr><tr><td style="text-align:left">Tree</td><td style="text-align:left">log</td><td style="text-align:left">log</td><td style="text-align:left">log</td><td style="text-align:left">log</td></tr><tr><td style="text-align:left">TreeMap</td><td style="text-align:left">log</td><td style="text-align:left">log</td><td style="text-align:left">log</td><td style="text-align:left">log</td></tr><tr><td style="text-align:left">TreeSet</td><td style="text-align:left">log</td><td style="text-align:left">log</td><td style="text-align:left">log</td><td style="text-align:left">log</td></tr></tbody></table><p>说明：</p><ul><li>const — 常数时间</li><li>const^a^ — 摊还常数时间，少数操作可能开销大一点</li><li>const^eff^ — 有效常数时间，取决于一些假定比如hash键的分布</li><li>const^lazy^ — 惰性常数时间，操作是递延的</li><li>log — 对数时间</li><li>linear — 线性时间</li></ul><h2 id="3-5-性能-sup-id-fnref-5-class-footnote-ref-a-href-fn-5-rel-footnote-span-class-hint-top-hint-rounded-aria-label-注：这里的”性能（properties）“一词不同于通常所说的软件性能（software-performance）。-5-span-a-sup-检查">3.5 性能<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="注：这里的”性能（properties）“一词不同于通常所说的软件性能（software performance）。">[5]</span></a></sup>检查</h2><p>性能检查（也被称作<a href="https://en.wikipedia.org/wiki/Property_testing">性能测试</a>）是一个很强有力的手段，可以通过函数式的方式帮助我们测试代码的性能。它基于生成的随机数据，再把这些数据传递给用户定义的检查函数。</p><p>Vavr在其<code>io.vavr:vavr-test</code>模块中有对性能检查的支持，所以在测试中要使用它的话得确保引入了这个模块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Arbitrary&lt;Integer&gt; ints = Arbitrary.integer();<br><br><span class="hljs-comment">// square(int) &gt;= 0: OK, passed 1000 tests.</span><br>Property.def(<span class="hljs-string">&quot;square(int) &gt;= 0&quot;</span>)<br>        .forAll(ints)<br>        .suchThat(i -&gt; i * i &gt;= <span class="hljs-number">0</span>)<br>        .check()<br>        .assertIsSatisfied();<br></code></pre></td></tr></table></figure><p>复杂数据结构的生成器都是由一些简单生成器组成的。</p><h2 id="3-6-模式匹配">3.6. 模式匹配</h2><p>Scala天然拥有模式匹配的特性，相对于<em>朴素</em>的Java来说这是一个优点。其基础语法和Java的switch类似：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> s = i <span class="hljs-keyword">match</span> &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span> =&gt; <span class="hljs-string">&quot;one&quot;</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span> =&gt; <span class="hljs-string">&quot;two&quot;</span><br>  <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-string">&quot;?&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意<em>match</em>是一个表达式，它会产出一个结果。此外，它还提供了：</p><ul><li>具名参数 <code>case i: Int ⇒ &quot;Int &quot; + i</code></li><li>对象解构 <code>case Some(i) ⇒ i</code></li><li>卫<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="在[计算机程序设计](https://zh.wikipedia.org/wiki/计算机程序设计)中，**卫**（guard）是[布尔表达式](https://zh.wikipedia.org/wiki/布尔逻辑)，其结果必须为真，程序才能执行下去。**卫语句**（**guard code**或**guard clause**）用于检查[先决条件](https://zh.wikipedia.org/wiki/先决条件)。">[7]</span></a></sup> <code>case Some(i) if i &gt; 0 ⇒ &quot;positive &quot; + i</code></li><li>多重条件 <code>case &quot;-h&quot; | &quot;--help&quot; ⇒ displayHelp</code></li><li>编译期<em>穷尽</em>检查</li></ul><p>模式匹配是一个很棒的特性。它让我们从一堆if-then-else分支中解放了出来，减少了代码量的同时，也能专注于更有意义的部分。</p><h3 id="3-6-1-Java匹配的基础知识">3.6.1. Java匹配的基础知识</h3><p>Vavr提供了一个和Scala的match相似的macth API，添加如下的引用可以启用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> io.vavr.API.*;<br></code></pre></td></tr></table></figure><p>它提供了静态方法<em>Match</em>，<em>Case</em>，还有所谓的 <em>atomic patterns</em>：</p><ul><li><code>$()</code> - 通配符模式</li><li><code>$(value)</code> - 等价模式</li><li><code>$(predicate)</code> - 条件模式</li></ul><p>在（一定的/合理的）范围内，最初Scala的示例可以用如下的方式进行实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> Match(i).of(<br>    Case($(<span class="hljs-number">1</span>), <span class="hljs-string">&quot;one&quot;</span>),<br>    Case($(<span class="hljs-number">2</span>), <span class="hljs-string">&quot;two&quot;</span>),<br>    Case($(), <span class="hljs-string">&quot;?&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><p>⚡ 我们的方法名（Case）统一使用了大写开头，因为Java中的’case’是一个关键字，这让这个API有点特殊。</p><h4 id="穷尽">穷尽</h4><p>最后那个通配符模式<code>$()</code>能帮我们从抛出的匹配错误中解放出来，如果没有任何分支匹配上的话。由于我们无法像Scala编译器那样执行穷尽检查，所以我们提供了可选结果的返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Option&lt;String&gt; s = Match(i).option(<br>    Case($(<span class="hljs-number">0</span>), <span class="hljs-string">&quot;zero&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><h4 id="语法糖">语法糖</h4><p>如上所述，<code>Case</code>允许匹配条件模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Case($(predicate), ...)<br></code></pre></td></tr></table></figure><p>Vavr提供了一组默认的断言。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> io.vavr.Predicates.*;<br></code></pre></td></tr></table></figure><p>它可以用来实现最初的那个Scala的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> Match(i).of(<br>    Case($(is(<span class="hljs-number">1</span>)), <span class="hljs-string">&quot;one&quot;</span>),<br>    Case($(is(<span class="hljs-number">2</span>)), <span class="hljs-string">&quot;two&quot;</span>),<br>    Case($(), <span class="hljs-string">&quot;?&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><p><strong>多重条件</strong></p><p>可以用<code>isIn</code>的断言来检查多重条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Case($(isIn(<span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;--help&quot;</span>)), ...)<br></code></pre></td></tr></table></figure><p><strong>处理副作用<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="在计算机科学中，**函数副作用**指当调用[函数](https://zh.wikipedia.org/wiki/函数)时，除了返回可能的函数值之外，还对主调用函数产生附加的影响。">[6]</span></a></sup></strong></p><p>Match就像一个表达式，它会返回一个值。为了处理副作用我们要用到一个返回<code>Void</code>的辅助函数<code>run</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Match(arg).of(<br>    Case($(isIn(<span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;--help&quot;</span>)), o -&gt; run(<span class="hljs-built_in">this</span>::displayHelp)),<br>    Case($(isIn(<span class="hljs-string">&quot;-v&quot;</span>, <span class="hljs-string">&quot;--version&quot;</span>)), o -&gt; run(<span class="hljs-built_in">this</span>::displayVersion)),<br>    Case($(), o -&gt; run(() -&gt; &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(arg);<br>    &#125;))<br>);<br></code></pre></td></tr></table></figure><p>⚡ <code>run</code>用于消除歧义，因为<code>void</code>在Java中不是一个有效的返回值。</p><p><strong>注意：</strong><code>run</code>不能当作直接返回值，也就是不能放到lambda表达式的外面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Wrong!</span><br>Case($(isIn(<span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;--help&quot;</span>)), run(<span class="hljs-built_in">this</span>::displayHelp))<br></code></pre></td></tr></table></figure><p>否则，分支就会在模式匹配命中<em>之前</em>执行，这会导致整个匹配表达式的中断。相反我们应该把它放在lambda表达式里面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Ok</span><br>Case($(isIn(<span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;--help&quot;</span>)), o -&gt; run(<span class="hljs-built_in">this</span>::displayHelp))<br></code></pre></td></tr></table></figure><p>总之，<code>run</code>的使用不当很容易造成错误，一定要小心。我们正考虑可能在之后的某个release版本中把它废弃掉，然后会提供一个更好的API来处理函数副作用。</p><h4 id="具名参数">具名参数</h4><p>Vavr使用了lambda的方式为匹配的值提供了具名参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Number</span> <span class="hljs-variable">plusOne</span> <span class="hljs-operator">=</span> Match(obj).of(<br>    Case($(instanceOf(Integer.class)), i -&gt; i + <span class="hljs-number">1</span>),<br>    Case($(instanceOf(Double.class)), d -&gt; d + <span class="hljs-number">1</span>),<br>    Case($(), o -&gt; &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberFormatException</span>(); &#125;)<br>);<br></code></pre></td></tr></table></figure><p>截止目前，我们都是采用原子模式来做值匹配。如果一个原子模式匹配成功，那么匹配对象的真正类型则是从模式的下文中推断出来的。</p><p>接下来，我们来看看能够匹配（理论上）任意深度的对象图的递归模式。</p><h4 id="对象分解">对象分解</h4><p>Java中使用构造器来实例化类。我们可以把<em>对象分解</em>理解成把对象分解为它的各个部分。</p><p>构造器是一个可以施加参数然后返回新实例的函数，那相应的解构器就是一个接收实例（参数）然后返回某部分的函数。这时我们就说一个对象<em>unapplied</em>。</p><p>对象解构不一定是一个唯一操作。比方说，LocalDate能够被分解成：</p><ul><li>年、月、日组件</li><li>代表对应某个时刻的纪元毫秒的long值</li><li>…</li></ul><h3 id="3-6-2-模式">3.6.2. 模式</h3><p>在Vavr中我们使用模式来描述某个特定类型的实例是如何被解构的。这些模式可以和Match API结合在一起使用。</p><h4 id="预定义的模式">预定义的模式</h4><p>针对Vavr中的很多类型都已经有对应的匹配模式了，可以通过如下方式引入它们：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> io.vavr.Patterns.*;<br></code></pre></td></tr></table></figure><p>比如说我们现在需要匹配一个Try的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Match(_try).of(<br>    Case($Success($()), value -&gt; ...),<br>    Case($Failure($()), x -&gt; ...)<br>);<br></code></pre></td></tr></table></figure><p>⚡ Vavr中第一个雏形Match API是允许从匹配模式中提取用户自定义的对象选择。但是如果没有合适的编译器的支持，这肯定是行不通的，因为生成的方法数量会呈指数级增长。目前的API做出了妥协，即所有模式都匹配，但只有根模式会被<em>分解</em>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Match(_try).of(<br>    Case($Success($Tuple2($(<span class="hljs-string">&quot;a&quot;</span>), $())), tuple2 -&gt; ...),<br>    Case($Failure($(instanceOf(Error.class))), error -&gt; ...)<br>);<br></code></pre></td></tr></table></figure><p>可以看到这里的Success和Failure是根模式，它们被分解成了Tuple2和Error，拥有了正确的泛型类型。</p><p>⚡ 深度嵌套的类型是根据匹配参数而不是匹配模式来推断的。</p><h4 id="用户自定义模式">用户自定义模式</h4><p>能够unapply（即<a href="#%E5%AF%B9%E8%B1%A1%E5%88%86%E8%A7%A3">对象分解</a>提到的概念）任意对象，包括不可变类的实例，都是至关重要的。Vavr提供了编译期注解<code>@Patterns</code>和<code>@Unapply</code>，以声明式的方式实现了这一点。</p><p>要启用annotation processor，需要项目中依赖<a href="http://search.maven.org/#search%7Cga%7C1%7Cvavr-match">vavr-match</a>包。</p><p>⚡ 注：当然我们也可以不通过代码生成器而是直接实现这些模式。想了解有关更多的信息，可以查看生成的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> io.vavr.match.annotation.*;<br><br><span class="hljs-meta">@Patterns</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">My</span> &#123;<br><br>    <span class="hljs-meta">@Unapply</span><br>    <span class="hljs-keyword">static</span> &lt;T&gt; Tuple1&lt;T&gt; <span class="hljs-title function_">Optional</span><span class="hljs-params">(java.util.Optional&lt;T&gt; optional)</span> &#123;<br>        <span class="hljs-keyword">return</span> Tuple.of(optional.orElse(<span class="hljs-literal">null</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>annotation processor放了一个文件MyPatterns在同一个包中（默认是在target/generated-sources下面），也支持内部类。</p><p>特殊情况：如果类名是$，那么生成的类名就只是个不带前缀的Patterns。</p><h4 id="卫-sup-id-fnref-7-class-footnote-ref-a-href-fn-7-rel-footnote-span-class-hint-top-hint-rounded-aria-label-在-计算机程序设计-https-zh-wikipedia-org-wiki-计算机程序设计-中，-卫-（guard）是-布尔表达式-https-zh-wikipedia-org-wiki-布尔逻辑-，其结果必须为真，程序才能执行下去。-卫语句-（-guard-code-或-guard-clause-）用于检查-先决条件-https-zh-wikipedia-org-wiki-先决条件-。-7-span-a-sup">卫<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="在[计算机程序设计](https://zh.wikipedia.org/wiki/计算机程序设计)中，**卫**（guard）是[布尔表达式](https://zh.wikipedia.org/wiki/布尔逻辑)，其结果必须为真，程序才能执行下去。**卫语句**（**guard code**或**guard clause**）用于检查[先决条件](https://zh.wikipedia.org/wiki/先决条件)。">[7]</span></a></sup></h4><p>现在我们用<em>卫</em>来实现对Optionals的匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Match(optional).of(<br>    Case($Optional($(v -&gt; v != <span class="hljs-literal">null</span>)), <span class="hljs-string">&quot;defined&quot;</span>),<br>    Case($Optional($(v -&gt; v == <span class="hljs-literal">null</span>)), <span class="hljs-string">&quot;empty&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><p>可以通过实现<code>isNull</code>和<code>isNotNull</code>来简化断言。</p><p>⚡ 是的，把null提取出来看起来很奇怪对不对。那么来尝试一下Vavr中的Option吧，换掉Java中的Optional！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Match(option).of(<br>    Case($Some($()), <span class="hljs-string">&quot;defined&quot;</span>),<br>    Case($None(), <span class="hljs-string">&quot;empty&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><section class="footnotes"><hr><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><strong>多元组</strong>，也称为<strong>顺序组</strong>（英语：Tuple），泛指有限个<a href="https://zh.m.wikipedia.org/wiki/%E5%85%83%E7%B4%A0_(%E6%95%B8%E5%AD%B8)">元素</a>所组成的<a href="https://zh.m.wikipedia.org/wiki/%E5%BA%8F%E5%88%97">序列</a>。在数学及计算机科学分别有其特殊的意义。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>偏函数和全函数的定义没有找到中文的百科，英语百科中都对应一个词条：<a href="https://en.wikipedia.org/wiki/Partial_function">https://en.wikipedia.org/wiki/Partial_function</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>在<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">函数式编程</a>中，<strong>单子</strong>（monad）是一种抽象，它允许以<a href="https://zh.wikipedia.org/wiki/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B">泛型</a>方式构造程序。支持它的语言可以使用单子来抽象出程序逻辑需要的<a href="https://zh.wikipedia.org/w/index.php?title=%E6%A0%B7%E6%9D%BF%E4%BB%A3%E7%A0%81&amp;action=edit&amp;redlink=1">样板代码</a>。<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>在<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">函数式编程</a>中， <strong>应用式函子</strong>，或简称应用式（applicative），是在<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E5%AD%90_(%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B)">函子</a>和<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%AD%90_(%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B)">单子</a>之间的中间结构。应用式函子允许函子式计算成为序列（不同于平常函子），但是不允许使用前面计算的结果于后续计算的定义之中（不同于单子）。<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>注：这里的”性能（properties）“一词不同于通常所说的软件性能（software performance）。<a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span>在计算机科学中，<strong>函数副作用</strong>指当调用<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0">函数</a>时，除了返回可能的函数值之外，还对主调用函数产生附加的影响。<a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span>在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">计算机程序设计</a>中，<strong>卫</strong>（guard）是<a href="https://zh.wikipedia.org/wiki/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91">布尔表达式</a>，其结果必须为真，程序才能执行下去。<strong>卫语句</strong>（<strong>guard code</strong>或<strong>guard clause</strong>）用于检查<a href="https://zh.wikipedia.org/wiki/%E5%85%88%E5%86%B3%E6%9D%A1%E4%BB%B6">先决条件</a>。<a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>函数式编程</tag>
      
      <tag>vavr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优雅地实现操作日志记录</title>
    <link href="/article/%E4%BC%98%E9%9B%85%E5%9C%B0%E5%AE%9E%E7%8E%B0%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/"/>
    <url>/article/%E4%BC%98%E9%9B%85%E5%9C%B0%E5%AE%9E%E7%8E%B0%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考文章：<a href="https://tech.meituan.com/2021/09/16/operational-logbook.html">https://tech.meituan.com/2021/09/16/operational-logbook.html</a></p></blockquote><h2 id="背景">背景</h2><p>最近参与了系统的重构，新的版本，需要对以前操作日志的实现进行改动，以前的操作日志是基于注解实现的，能记录单据类型、操作人、操作时间、操作描述、请求参数等。现在新的日志记录需要支持更多：</p><ul><li>新增业务唯一标识记录，即<strong>业务单号</strong>；</li><li>操作描述支持<strong>动态参数</strong>填入，支持<strong>动态函数</strong>的执行和替换；</li><li>针对比较多字段编辑的场景，需记录更新前的<strong>原始数据</strong>。</li></ul><p>于是参考了美团的这篇文章，重新实现了解析操作日志的逻辑。至于操作日志的必要性以及简单实现等就不过多赘述，原文有更详细的描述，这里重点说一下对于几个新增需求的实现。</p><h2 id="流程">流程</h2><p><img src="/img/%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E5%8A%A8%E6%80%81%E5%87%BD%E6%95%B0%E6%B3%A8%E5%86%8C.png" alt="动态函数注册"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E5%88%87%E9%9D%A2%E8%A7%A3%E6%9E%90.png" alt="日志切面解析"></p><h2 id="实现">实现</h2><h3 id="1-自定义注解">1. 自定义注解</h3><p>先看看日志注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> DataLog &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 单笔数据操作时可指定，SpEL.</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">billId</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 单据类型，所属的业务模块，一般指定为固定值.</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">billType</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 操作描述，支持SpEL模板，支持自定义函数.</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">operationDesc</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询更新操作的原始数据时自定义函数名称，根据billId查询.</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">originalDataFunction</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 自定义函数执行时可选的分表字段值，SpEL.</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">shardingId</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注解里面需要用到SpEL，对于动态获取参数字段值，首选的当然是SpEL表达式语言，简单强大。这里面billId、operationDesc、shardingId都需要从参数中动态取值的，而接口的参数会有两种情况，一种是多个参数，一种是整个对象作为请求body的单个参数。</p><p>注解使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 多个参数值</span><br><span class="hljs-meta">@GetMapping(value = &quot;/query&quot;)</span><br><span class="hljs-meta">@DataLog(billId = &quot;#&#123;#id&#125;&quot;,</span><br><span class="hljs-meta">         shardingId = &quot;#&#123;#id&#125;&quot;,</span><br><span class="hljs-meta">         billType = &quot;test&quot;,</span><br><span class="hljs-meta">         operationDesc = &quot;id为#&#123;#id&#125;. id2为#&#123;#id2&#125;&quot;,</span><br><span class="hljs-meta">         originalDataFunction = &quot;prefix&quot;)</span><br><span class="hljs-keyword">public</span> ResultVO&lt;String&gt; <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;id&quot;)</span> String id, <span class="hljs-meta">@RequestParam(&quot;id2&quot;)</span> String id2)</span> &#123;<br>    <span class="hljs-keyword">return</span> ResultUtils.success(<span class="hljs-string">&quot;success&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 单个对象请求</span><br><span class="hljs-meta">@PostMapping(value = &quot;/post&quot;)</span><br><span class="hljs-meta">@DataLog(billId = &quot;#&#123;id&#125;&quot;,</span><br><span class="hljs-meta">         shardingId = &quot;#&#123;id&#125;&quot;,</span><br><span class="hljs-meta">         billType = &quot;test&quot;,</span><br><span class="hljs-meta">         operationDesc = &quot;id是#&#123;id!=null?id:&#x27;默认值&#x27;&#125;&quot;)</span><br><span class="hljs-keyword">public</span> ResultVO&lt;String&gt; <span class="hljs-title function_">post</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> TestDTO dto)</span> &#123;<br>    <span class="hljs-keyword">return</span> ResultUtils.success(<span class="hljs-string">&quot;success&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>针对多参数的情况，取值的写法看起来有些奇怪，这是因为同时使用了SpEL的 <code>StandardEvaluationContext</code>和<code>TemplateParserContext</code>，这样做也是为了能兼容操作描述中的<strong>模板表达式</strong>的写法。</p><h3 id="2-SpEL实现动态参数获取">2. SpEL实现动态参数获取</h3><p>核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExpressionParser</span> <span class="hljs-variable">PARSER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpelExpressionParser</span>();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">LocalVariableTableParameterNameDiscoverer</span> <span class="hljs-variable">DISCOVERER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalVariableTableParameterNameDiscoverer</span>();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;StandardEvaluationContext&gt; CONTEXT_THREAD_LOCAL = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">templateParse</span><span class="hljs-params">(String text, Method method, Object[] argsObj)</span> &#123;<br>    String[] parameterNames = DISCOVERER.getParameterNames(method);<br>    <span class="hljs-keyword">if</span> (parameterNames == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> text;<br>    &#125;<br>    <span class="hljs-comment">// 由于存在业务操作执行前后都要进行解析的场景，所以使用ThreadLocal存储上下文的context，避免重复创建</span><br>    <span class="hljs-type">StandardEvaluationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> CONTEXT_THREAD_LOCAL.get();<br>    <span class="hljs-keyword">if</span> (context != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> PARSER.parseExpression(text, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplateParserContext</span>()).getValue(context, String.class);<br>    &#125;<br>    context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StandardEvaluationContext</span>();<br>    <span class="hljs-comment">// 把接口的所有参数都放到context中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; parameterNames.length; i++) &#123;<br>        context.setVariable(parameterNames[i], argsObj[i]);<br>    &#125;<br>    <span class="hljs-comment">// 获取对象中的属性值时，使用第一个参数作为rootObject</span><br>    context.setRootObject(argsObj[<span class="hljs-number">0</span>]);<br>    CONTEXT_THREAD_LOCAL.set(context);<br>    <span class="hljs-comment">// 结合使用`模板`和`标准`的表达式解析</span><br>    <span class="hljs-keyword">return</span> PARSER.parseExpression(text, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplateParserContext</span>()).getValue(context, String.class);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeContext</span><span class="hljs-params">()</span> &#123;<br>    CONTEXT_THREAD_LOCAL.remove();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-动态函数的执行和替换">3. 动态函数的执行和替换</h3><p>注解使用的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(value = &quot;/post2&quot;)</span><br><span class="hljs-meta">@DataLog(billId = &quot;#&#123;id&#125;&quot;,</span><br><span class="hljs-meta">         shardingId = &quot;#&#123;id&#125;&quot;,</span><br><span class="hljs-meta">         billType = &quot;test&quot;,</span><br><span class="hljs-meta">         operationDesc = &quot;id是#&#123;id!=null?id:&#x27;默认值&#x27;&#125;，自定义动态函数@customeFunction(#&#123;id&#125;,#&#123;name&#125;)&quot;)</span><br><span class="hljs-keyword">public</span> ResultVO&lt;String&gt; <span class="hljs-title function_">post2</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> TestDTO dto)</span> &#123;<br>    List&lt;SnEntity&gt; snEntities = snTestMapper.selectList(Wrappers.lambdaQuery(SnEntity.class));<br>    <span class="hljs-keyword">return</span> ResultUtils.success(snEntities.get(<span class="hljs-number">0</span>).getPeriodName());<br>&#125;<br></code></pre></td></tr></table></figure><p>动态函数的使用主要是在 <strong>操作描述(operationDesc)</strong> 中，由于某些场景下需要填充一些动态查询的数据到描述中去，故需要支持。这个地方按照原文的思路来做是可以使用<code>MethodBasedEvaluationContext</code>来实现，而<code>StandardEvaluationContext</code>是<code>MethodBasedEvaluationContext</code>的父类，所以也可以使用<code>StandardEvaluationContext#registerFunction</code>函数来进行注册。但这需要获取目标类的Method信息作为参数，感觉比较麻烦，所以我并没有使用这种方法，而是自定义了函数式接口进行注册，先看看自定义函数以及注册的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 函数式接口，便于实现自定义的逻辑</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IFunction</span>&lt;R&gt; &#123;<br>    <span class="hljs-comment">// 动态入参（这里的设计或许不够好）</span><br>    R <span class="hljs-title function_">apply</span><span class="hljs-params">(String... params)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogParseFunctionFactory</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, IFunction&lt;Object&gt;&gt; FUNCTION_MAP = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">32</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 操作日志自定义函数注册.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> functionName 函数名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> function     函数体</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerFunction</span><span class="hljs-params">(String functionName, IFunction&lt;Object&gt; function)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!FUNCTION_MAP.containsKey(functionName)) &#123;<br>            FUNCTION_MAP.put(functionName, function);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实现与注册逻辑</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceRegistry</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> BizMapper bizMapper;<br>    <br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">initRegistry</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 注册自定义函数，customeFunction对应描述中的函数名称</span><br>        LogParseFunctionFactory.registerFunction(<span class="hljs-string">&quot;customeFunction&quot;</span>, (params) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> bizMapper.query(params[<span class="hljs-number">0</span>]);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解析函数名称、执行函数并进行结果替换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 约定函数声明的格式，形如 @functionName(param0,param1)，其中的param可以通过SpEL进行注入，也可以固定</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> <span class="hljs-variable">AT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;@&#x27;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> <span class="hljs-variable">LEFT_BRACKET</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;(&#x27;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> <span class="hljs-variable">RIGHT_BRACKET</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;)&#x27;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">WHITESPACE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EMPTY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">COMMA</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;,&quot;</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">functionParse</span><span class="hljs-params">(String text)</span> &#123;<br>    <span class="hljs-type">char</span>[] chars = text.toCharArray();<br>    <span class="hljs-comment">// 由于需要对占位的函数进行结果替换，需要新字符串，预先扩展一部分空间，避免循环中不必要的扩容操作。空间换时间</span><br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(text.length() + (text.length() / <span class="hljs-number">2</span>));<br>    <span class="hljs-type">int</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chars.length; i++) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> chars[i];<br>        <span class="hljs-keyword">if</span> (AT != ch) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 解析自定义函数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &lt; chars.length &amp;&amp; chars[j] != LEFT_BRACKET) &#123;<br>            j++;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">funcName</span> <span class="hljs-operator">=</span> doParse(chars, j, i);<br>        <span class="hljs-comment">// 解析函数参数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> j;<br>        <span class="hljs-keyword">while</span> (j &lt; chars.length &amp;&amp; chars[j] != RIGHT_BRACKET) &#123;<br>            j++;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> doParse(chars, j, l);<br>        IFunction&lt;Object&gt; function = LogParseFunctionFactory.FUNCTION_MAP.get(funcName.trim());<br>        <span class="hljs-keyword">if</span> (function == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 替换空白，使用apache lang包的replace方法，性能更佳</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">actualParams</span> <span class="hljs-operator">=</span> StringUtils.replace(params, WHITESPACE, EMPTY);<br>        <span class="hljs-comment">// 执行动态函数</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">funcResult</span> <span class="hljs-operator">=</span> function.apply(actualParams.split(COMMA));<br>        <span class="hljs-comment">// 替换动态函数为执行的结果</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">replacement</span> <span class="hljs-operator">=</span> (funcResult == <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot;&quot;</span> : funcResult.toString());<br>        builder.append(text, offset, i).append(replacement);<br>        offset = j + <span class="hljs-number">1</span>;<br>    &#125;<br>    builder.append(text, offset, text.length());<br>    <span class="hljs-keyword">return</span> builder.toString();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">doParse</span><span class="hljs-params">(<span class="hljs-type">char</span>[] chars, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>    <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[x - <span class="hljs-number">1</span> - y];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; (x - <span class="hljs-number">1</span> - y); k++) &#123;<br>        bytes[k] = (<span class="hljs-type">byte</span>) chars[y + <span class="hljs-number">1</span> + k];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-更新前原始数据的获取">4. 更新前原始数据的获取</h3><p>这里要用到的是注解里面的<code>originalDataFunction</code>字段，函数的注册方式同上，只是在调用的地方不太一样，是在操作执行前调用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用示例</span><br><span class="hljs-meta">@PostMapping(value = &quot;/post&quot;)</span><br><span class="hljs-meta">@DataLog(billId = &quot;#&#123;id&#125;&quot;,</span><br><span class="hljs-meta">         shardingId = &quot;#&#123;id&#125;&quot;,</span><br><span class="hljs-meta">         billType = &quot;test&quot;,</span><br><span class="hljs-meta">         originalDataFunction = &quot;originalFunction&quot;)</span><br><span class="hljs-keyword">public</span> ResultVO&lt;String&gt; <span class="hljs-title function_">post</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> TestDTO dto)</span> &#123;<br>    <span class="hljs-keyword">return</span> ResultUtils.success(<span class="hljs-string">&quot;success&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>解析执行逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 注解获取等</span><br>...<br><span class="hljs-type">String</span> <span class="hljs-variable">originalData</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 判断是否指定了自定义函数且单号必须指定</span><br><span class="hljs-keyword">if</span> (StrUtil.isNotBlank(logHandler.originalDataFunction) &amp;&amp; StrUtil.isNotBlank(logHandler.billId)) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">finalBillId</span> <span class="hljs-operator">=</span> ExpressionHandler.templateParse(logHandler.billId, logHandler.method, argsObj);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">shardingId</span> <span class="hljs-operator">=</span> ExpressionHandler.templateParse(logHandler.shardingId, logHandler.method, argsObj);<br>        <span class="hljs-comment">// 自定义函数查询原始数据，也是用的上面的函数注册方法</span><br>        IFunction&lt;Object&gt; function = LogParseFunctionFactory.FUNCTION_MAP.get(logHandler.originalDataFunction);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">originalDataObject</span> <span class="hljs-operator">=</span> Optional.ofNullable(function)<br>            .map(f -&gt; f.apply(finalBillId, shardingId))<br>            .orElse(<span class="hljs-literal">null</span>);<br>        originalData = JsonSerializer.serialize(originalDataObject);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        Log.warn(ex, <span class="hljs-string">&quot;日志内容补充originalData失败&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 业务操作</span><br>    <span class="hljs-keyword">return</span> (result = joinPoint.proceed());<br>&#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>    <span class="hljs-comment">// 异常处理，记录错误信息</span><br>    ...<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 同步解析注解上的其他值，最终再交给线程池异步写入数据库，这里没有把解析处理的逻辑也异步化</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>但是由于原始数据一般都是全量的整条数据，会造成日志表的数据膨胀，且必须在操作前查询，也会影响接口性能，所以需要慎用。</p><h2 id="可能的优化点">可能的优化点</h2><p>上面的SpEL解析代码中使用到了<code>ThreadLocal</code>，目前<strong>解析注解是同步处理</strong>，写数据才进入到<strong>线程池异步写</strong>，虽然实测性能问题不大，但是这里可以扩展优化一下，把解析注解值的过程也搬到线程池中去，这里就涉及到如何在线程池异步的场景下使用<code>ThreadLocal</code>？答案是阿里开源的<a href="https://github.com/alibaba/transmittable-thread-local"><code>TransmittableThreadLocal</code></a>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>SpEL</tag>
      
      <tag>函数式接口</tag>
      
      <tag>ThreadLocal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>敏感词检测算法 - DFA</title>
    <link href="/article/%E6%95%8F%E6%84%9F%E8%AF%8D%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95-DFA/"/>
    <url>/article/%E6%95%8F%E6%84%9F%E8%AF%8D%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95-DFA/</url>
    
    <content type="html"><![CDATA[<p>之前在系统中开发过一个敏感词检测的功能，最开始我很快完成了功能的设计开发：</p><ul><li>敏感词库：存储所有敏感词的数据库表；</li><li>校验：查出所有敏感词集合，在循环中使用<code>String.contains()</code>方法在目标串中进行敏感词查找，找到后抛出异常提示；</li><li>预加载：敏感词集合不用每次都查数据库，可以提前加载缓存到内存，数据量也并不大。</li></ul><p>但是使用<strong>暴力匹配算法</strong>未免简陋了点，于是便上网查找了下，果然还有更优的解决方案。这里我们先分析下<code>String</code>类的<code>contains</code>方法，即<code>indexOf()</code>方法的实现。</p><h2 id="BF算法">BF算法</h2><blockquote><p>BF算法，即暴力(Brute Force)算法，是普通的模式匹配算法，BF算法的思想就是将目标串S的第一个字符与模式串T的第一个字符进行匹配，若相等，则继续比较S的第二个字符和 T的第二个字符；若不相等，则比较S的第二个字符和T的第一个字符，依次比较下去，直到得出最后的匹配结果。BF算法是一种蛮力算法。– 百度百科</p></blockquote><p>直接看<code>indexOf()</code>方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * source：来源串（输入的文本），target：模式串（敏感词）.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(<span class="hljs-type">char</span>[] source, <span class="hljs-type">int</span> sourceOffset, <span class="hljs-type">int</span> sourceCount,</span><br><span class="hljs-params">            <span class="hljs-type">char</span>[] target, <span class="hljs-type">int</span> targetOffset, <span class="hljs-type">int</span> targetCount,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> fromIndex)</span> &#123;<br>        <span class="hljs-keyword">if</span> (fromIndex &gt;= sourceCount) &#123;<br>            <span class="hljs-keyword">return</span> (targetCount == <span class="hljs-number">0</span> ? sourceCount : -<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (fromIndex &lt; <span class="hljs-number">0</span>) &#123;<br>            fromIndex = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (targetCount == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> fromIndex;<br>        &#125;<br><span class="hljs-comment">// 取敏感词的第一个字符</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> target[targetOffset];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> sourceOffset + (sourceCount - targetCount);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> sourceOffset + fromIndex; i &lt;= max; i++) &#123;<br>            <span class="hljs-comment">/* Look for first character. */</span><br>    <span class="hljs-comment">// 从输入文本中找到匹配敏感词第一个字符的字符</span><br>            <span class="hljs-keyword">if</span> (source[i] != first) &#123;<br>                <span class="hljs-keyword">while</span> (++i &lt;= max &amp;&amp; source[i] != first);<br>            &#125;<br><br>            <span class="hljs-comment">/* Found first character, now look at the rest of v2 */</span><br>    <span class="hljs-comment">// 匹配到了第一个字符，继续向后匹配</span><br>            <span class="hljs-keyword">if</span> (i &lt;= max) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> j + targetCount - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> targetOffset + <span class="hljs-number">1</span>; j &lt; end &amp;&amp;<br>    <span class="hljs-comment">// 输入文本中的下一个字符是否与敏感词中的第二个字符相等，是则继续匹配</span><br>    <span class="hljs-comment">// 否则终止匹配，从文本的下一个字符开始重新匹配</span><br>                     source[j] == target[k]; j++, k++);<br>              <br>              <span class="hljs-comment">// j == end 说明上面这个循环走完了，即文本中完整的匹配到了敏感词，返回匹配的第一个字符处的index，代表成功</span><br>                <span class="hljs-keyword">if</span> (j == end) &#123;<br>                    <span class="hljs-comment">/* Found whole string. */</span><br>                    <span class="hljs-keyword">return</span> i - sourceOffset;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>记source的长度为N，target的长度为M，该算法在最坏的情况下，单个敏感词匹配需要的比较次数为M * (N - M + 1)，表示target在source的最后一段才匹配到，即时间复杂度为O(M * N)，而要检测整个敏感词库（词库总数记为S）复杂度就变为<strong>O(S * M * N)</strong>，效率太低。</p><h2 id="DFA">DFA</h2><blockquote><p>具体实现源码主要参考了这篇文章：<a href="https://houbb.github.io/2020/01/07/sensitive-word-dfa">https://houbb.github.io/2020/01/07/sensitive-word-dfa</a></p></blockquote><p>DFA 即 Deterministic Finite Automaton，就是<strong>确定有穷自动机</strong>。百科的描述比较抽象，主要是借助一张图来看：</p><p><img src="/img/DFA.png" alt="DFA"></p><p>大写字母是状态，小写字母是动作，初始状态是S，终止状态是Q。通过状态 + 动作可以实现各种状态的转换，如下表：</p><table><thead><tr><th style="text-align:center">状态\动作</th><th style="text-align:center">a</th><th style="text-align:center">b</th></tr></thead><tbody><tr><td style="text-align:center">S</td><td style="text-align:center">U</td><td style="text-align:center">V</td></tr><tr><td style="text-align:center">U</td><td style="text-align:center">Q</td><td style="text-align:center">V</td></tr><tr><td style="text-align:center">V</td><td style="text-align:center">U</td><td style="text-align:center">Q</td></tr><tr><td style="text-align:center">Q</td><td style="text-align:center">Q</td><td style="text-align:center">Q</td></tr></tbody></table><p>而实现敏感词检测的关键就在于将敏感词构建成一个这样的状态图，通常是利用Trie字典树来实现。如下图：</p><blockquote><p>利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较。</p></blockquote><p><img src="/img/%E6%95%8F%E6%84%9F%E8%AF%8DTrie%E6%A0%91.png" alt="敏感词Trie树"></p><p>将敏感词库中的词构建成一棵棵字典树，每个节点即表示敏感词中的一个字符，那么从输入文本的第一个字符开始在Trie树上查找，即可实现敏感词的检测。Java中的实现我查了下基本都是利用<code>HashMap</code>来做的，构建完成后呈如下结构：</p><p><img src="/img/HashMap%E5%AE%9E%E7%8E%B0Trie%E6%A0%91.png" alt="HashMap实现Trie树"></p><p>这样就把整个敏感词库构建出来了，只需要遍历一次输入的文本，就可以匹配出所有的敏感词，复杂度为<strong>O(N * M)</strong>，效率相对高了许多。当然，这是以空间换来的，不过现在的服务器资源都比较充足，大部分系统敏感词库的大小也不会太大，是可以接受的。</p><h2 id="小结">小结</h2><p>Trie树除了Hash结构的实现，还有其它数据结构的实现，有待研究。</p><blockquote><p>双数组Trie树：<a href="https://www.cnblogs.com/en-heng/p/6265256.html%E3%80%82">https://www.cnblogs.com/en-heng/p/6265256.html。</a></p></blockquote><p>目前只是利用DFA的思想实现了最简单基础的敏感词匹配，如果还涉及到组合敏感词、拼音敏感词等等，那就需要更复杂的算法来实现，最近刚好看到一篇文章，先记录下来。</p><blockquote><p>vivo敏感词匹配系统的设计与实现：<a href="https://mp.weixin.qq.com/s/ZPqwK5wYg09vsGrluRmNZA">https://mp.weixin.qq.com/s/ZPqwK5wYg09vsGrluRmNZA</a></p></blockquote><p>除了实现字符串匹配外，DFA也用于一些其它的场景。还有就是与之相反的NFA - 不确定的有穷自动机，也可以了解学习一下。</p>]]></content>
    
    
    
    <tags>
      
      <tag>DFA</tag>
      
      <tag>状态机</tag>
      
      <tag>敏感词检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>性能优化实践小记</title>
    <link href="/article/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5%E5%B0%8F%E8%AE%B0/"/>
    <url>/article/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1>背景</h1><p>最近项目里面做了一个分享助力排名中奖的活动，对性能有一定的要求，其实也不高，就 100~200 TPS左右。但是几个周赶出来的项目设计和实现问题都很多，追求快速完成功能，到性能测试这一步就卡住了，于是就有了这次性能优化之旅。</p><h1>三个方向</h1><h2 id="一、数据库">一、数据库</h2><p>首先当然是数据库表设计，使用的是MySQL数据库，主要是表索引以及尽量简单的查询。由于本次我们的业务比较简单，主要涉及几个表：</p><ul><li>用户参与记录表：哪些用户参与了我们的活动</li><li>用户分享助力关系表：用户之间互相助力的关系记录</li><li>用户被助力次数表：主要用于最终的用户助力次数排行的统计</li></ul><p>这些表的查询相对简单，基本都是按照用户ID（Long）查询相关数据，所以在表查询这块的优化空间并不大。</p><p>然后就是MySQL集群模式，我们采用的是MySQL 8.0 官方推荐的MGR（MySQL Group Replication）模式，问题不大。</p><h2 id="二、代码设计与中间件">二、代码设计与中间件</h2><p>这块的问题是比较多，也是主要需要记录的。因为初期为了赶工，很多地方的设计都是简单粗暴的实现功能，所以这一块是优化的重点。</p><h3 id="1-引入WebFlux">1. 引入WebFlux</h3><p>助力相关接口采用WebFlux包装，利用其<strong>异步响应式</strong>的设计提高吞吐量，但效果并不明显，因为我们的并发量也不高，仅作为尝试。</p><h3 id="2-利用MQ解耦削峰">2. 利用MQ解耦削峰</h3><p><strong>点击助力</strong>这个接口可以预见是并发最高的接口，里面主要包含几个步骤：</p><ol><li>记录A用户给B用户助力；</li><li>记录B用户的被助力次数；</li><li>更新助力次数排行榜：注意的是，如果是直接利用数据库查询排行榜，就没有这个步骤了。但是我这里使用了Redis实现，所以多了一个步骤。</li></ol><p>前两个操作都是<strong>写库操作</strong>，势必要使用事务保证整个操作的原子性，但遇到的问题是，直接使用Spring的本地事务在测试时TPS一直上不去，猜测可能是跟我们在测试环境进行性能测试，一套数据库集群几十个项目在使用有关系。</p><p>由于这个问题比较难定位，时间又紧迫，所以只能从代码层面去优化，主要是引入了RocketMQ，利用其<strong>可靠消息保证最终一致性的分布式事务</strong>来解耦这几个操作：</p><ol><li><p>接口只做一次写库操作，就是记录A用户给B用户助力。</p></li><li><p>向MQ发送一条<strong>事务消息</strong>，用于记录B用户被助力的次数以及更新助力排行榜。</p></li></ol><p>要注意两个点：</p><ol><li>需要利用RocketMQ的事务消息机制，先发送prepare消息，再写库，再commit or rollback给MQ。这时Spring的本地事务就可以去掉；</li><li>消费消息时需要针对单个用户加分布式锁，因为服务都是多pod/实例部署，同一个用户的多次助力，可能被不同的实例所消费，为保证数据库记录数据的准确性，需要加锁。这个地方并没有性能要求，更多的是要关注数据的准确与否。</li></ol><p>这里主要是利用MQ的异步、解耦、削峰的特性，来实现对高并发下的接口写操作的分离和快速响应。虽然排行榜的更新有一定的延时（毫秒级或者秒级），但是用户感知不大且不是特别关心，因为助力操作本来就是在分享之后的某个不确定时间点发生的，除了系统需要记录精确的时间点以外，用户更关心的是最终的助力数是否正确。</p><h3 id="3-Redis实现排行榜">3. Redis实现排行榜</h3><p>排行榜的查询，最开始是直接利用MySQL的<strong>order by + @变量</strong>的方式实现排名和排名序号的递增。但是这样的实现在数据量稍大后，性能急速下降，SQL也比较复杂，后面对其重新设计，利用Redis的<strong>ZSet</strong>来实现排行榜的功能：</p><ul><li>ZSet的value是用户ID，<strong>（初始设计）score是被助力次数</strong>，次数越多，排名越高；</li><li>利用ZSet的<code>zrangebyscore</code>取前10名即可实现排行榜的查询；</li><li>排行榜的更新在MQ消费后向ZSet <code>add</code>即可，因为此命令既可以添加一个新的value，也可以对已经存在的value进行更新。且每消费一条MQ消息即表示某一个用户有一次助力产生，score 默认+1即可。</li></ul><p>这里出现了一个很有意思的问题，那就是<strong>如果两个人是相同的助力次数，排名怎么算</strong>？如果都在或者都不在中奖区间以内，那么谁前谁后都无所谓。但是一旦区间的边缘出现两个助力次数一样的排名，一个中奖一个没有中奖，那么就要必须有合理的解释。</p><p>按照正常生活中的逻辑来说，应该是先达到某一助力次数的用户排在前面，即<strong>先到先得</strong>。但是按上面的实现，从ZSet里面取排名时，助力次数（score）相同的情况下，是按照先参加活动的用户排在前面，即先进入ZSet的value排在前面，这是我实际观察得到的结果。这个取值逻辑在程序里面肯定没有问题，但却不符合此时的业务逻辑。</p><p>经过上面的分析，可以看出score需要跟时间挂钩，但如果score直接加上时间戳，那么就是后到先得，不符合我们的逻辑。所以我们可以换一种思路：<strong>Java时间精度默认是毫秒，目前生成的时间戳是13位。所以可以用某个14位数字（未来的某一个时间戳）减去当前的时间戳，再以得到的数字作为小数，助力次数作为整数，就成为了最终的score。</strong></p><p>$score = n.(x - y)$ <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="score为一个double数，整数部分为助力次数，小数部分为逆向时间戳。这样助力次数越多，自然score越大，助力次数相同的情况下，小数越大排的越靠前。">[1]</span></a></sup></p><p><strong>x</strong> 为某14位数字，我取的是10 000 000 000 000，代表的是未来的<em>2286-11-21 01:46:40.000</em>这一刻，这个时间点已经大大超出目前绝大部软件系统的生命周期，因此可以认为它是一个常数。<strong>y</strong> 即助力那一刻的时间戳。<strong>n</strong> 是助力次数。</p><p><strong>(x - y)得到的是一个逆向时间戳，在助力数n相同的情况下，助力越早，时间戳越小，逆向时间戳越大，最终的score就越大，排名就越靠前。</strong> 完美实现了我们想要的效果，先到先得。</p><h3 id="4-预加载、压缩、缓存">4. 预加载、压缩、缓存</h3><p>除了助力以外，这次活动还有一个比较麻烦的点在于<strong>分享二维码的生成</strong>。由于我们前端是微信小程序，微信的小程序码接口又只能在服务器端请求且返回的是一个图片Buffer（每个二维码大约110 kb左右），所以去实时生成二维码不但需要多次网络IO，返回的数据量也较大，显然达不到性能要求。</p><blockquote><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html">小程序码 &gt; wxacode.getUnlimited</a></p></blockquote><p>所以针对二维码的优化，主要是从三个方面来进行的：</p><ol><li><p><strong>预加载</strong></p><p>二维码是一次生成，永久可用，可以利用前端页面逻辑的顺序性，当用户在分享二维码页面之前的某个页面时，提前通知后端进行预生成，并存储起来。</p></li><li><p><strong>缓存</strong></p><p>存储时使用到的是Redis和OSS，依据前端的需求有两种方式：</p><ul><li>直接存储Base64格式的数据到Redis，接口返回的也是Base64的字符串。</li><li>将Base64转化为png文件上传到OSS，再把链接存储在Redis，返回给前端这个链接地址。</li></ul></li><li><p><strong>压缩</strong></p><p>主要是针对第一种存储方式，一个二维码图片Buffer大约是110 kb左右，我们测试的用户数据是10w，如果原始数据直接缓存到Redis中，那么将占用：110(kb)×100000÷1024÷1024≈10(gb) 左右的缓存空间，这显然不合理。</p><p>所以便想到了压缩后再进缓存，但必须得保证二维码的清晰程度。经过实际测试，压缩到20kb左右可以兼顾清晰度和空间利用效率，这时只需占用约 1.9gb 缓存空间，这样一个占用相对来说就可以接受了。而且这只是测试预估的最大值，实际生产环境中参与活动的用户数远没有达到这个数量，只有一半左右。</p></li></ol><p>长远来看，在面对更大体量的数据时，压缩也不好使，还是应该预加载 + OSS + Redis最佳。</p><h2 id="三、参数调优">三、参数调优</h2><p>这一块主要是JVM和Web容器的参数调优，我们实际生产环境的单个pod资源限制标准为2C4G。</p><ol><li><p><strong>JVM</strong></p><p>主要是以下几个参数，比较通用简单。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-XX:+UseG1GC 使用G1垃圾收集器</span><br><span class="hljs-deletion">-Xms4000m    初始化JVM内存，可以设置的和最大内存一致，避免每次GC后JVM重新分配内存以及扩容带来的影响</span><br><span class="hljs-deletion">-Xmx4000m    最大JVM可用内存</span><br><span class="hljs-deletion">-XX:MaxGCPauseMillis=100  设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Web容器</strong></p><p>我们项目使用的是Undertow而不是Tomcat，从网上找了一些通用的参数调整。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># undertow配置</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">undertow:</span><br>    <span class="hljs-comment"># 设置IO线程数, 它主要执行非阻塞的任务,它们会负责多个连接, 默认设置每个CPU核心一个线程</span><br>    <span class="hljs-comment"># 不要设置过大，如果过大，启动项目会报错：打开文件数过多</span><br>    <span class="hljs-attr">io-threads:</span> <span class="hljs-number">16</span><br>    <span class="hljs-comment"># 阻塞任务线程池, 当执行类似servlet请求阻塞IO操作, undertow会从这个线程池中取得线程</span><br>    <span class="hljs-comment"># 它的值设置取决于系统线程执行任务的阻塞系数，默认值是IO线程数*8</span><br>    <span class="hljs-attr">worker-threads:</span> <span class="hljs-number">256</span><br>    <span class="hljs-comment"># 以下的配置会影响buffer,这些buffer会用于服务器连接的IO操作,有点类似netty的池化内存管理</span><br>    <span class="hljs-comment"># 每块buffer的空间大小,越小的空间被利用越充分，不要设置太大，以免影响其他应用，合适即可</span><br>    <span class="hljs-attr">buffer-size:</span> <span class="hljs-number">1024</span><br>    <span class="hljs-comment"># 是否分配的直接内存(NIO直接分配的堆外内存)</span><br>    <span class="hljs-attr">direct-buffers:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="结果">结果</h2><p>由于请求链路上还有网关与用户鉴权中心的存在，所以我们也分为了两种情况进行测试，走网关和不走网关，用来定位和排除一些应用服务的问题。当然，最终结果是以真实环境的网络链路为标准的，也就是走网关路由和鉴权。</p><p>按照测试部门的要求，使用的工具是Jmeter，几个核心接口线程组的线程数设置为100，永久循环持续5分钟。测试环境开启两个pod，单个pod资源限制2C4G。但是测试环境的数据库集群是多个项目共用的，所以数据库的读写性能在不同时间段测试时表现波动很大，最终取的是一个比较折中的数据。</p><ul><li>不走网关：写接口的TPS保持在400左右，读接口600 ~ 1000。</li><li>走网关：写接口200左右，读接口300 ~ 400。</li></ul><p>本次性能测试的要求并不高，但是对于个人来说也是挺有意义的一次实践，其中的很多思路还是值得记录下来的。</p><section class="footnotes"><hr><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>score为一个double数，整数部分为助力次数，小数部分为逆向时间戳。这样助力次数越多，自然score越大，助力次数相同的情况下，小数越大排的越靠前。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>性能测试</tag>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo版本升级踩坑记录</title>
    <link href="/article/Dubbo%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <url>/article/Dubbo%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="背景">背景</h2><p>最近我们部门负责基础组件的<a href="https://github.com/yangyang0507"><strong>大佬</strong></a>准备升级下Dubbo（v2.7.3 -&gt; v2.7.8），本以为是一次简单的升级，我们各个服务配合刷新下依赖即可，结果却闹出了一系列的问题：</p><ul><li>RPC中枚举序列化问题：这个我们讨论过，应该要<strong>禁止在RPC调用中直接使用枚举作为字段类型</strong></li><li>Dubbo泛化调用问题：2.7.8版本在泛化调用无参方法时，由于没有对types做非空校验，导致NPE，详情戳☞ <a href="https://github.com/apache/dubbo/issues/6840">#6840</a></li><li>项目启动时找不到provider接口提供者：2.7.8版本创建的provider都会带有Group标识，但是之前的版本没有这个标识，导致provider匹配不上报No Provider错误</li><li><u><strong>与Nacos集成引起系统持续不断的创建大量 nacos.naming 线程，导致系统负载持续增加出现崩溃的迹象：这是本次重点记录分析的问题</strong></u></li></ul><h2 id="问题发现">问题发现</h2><p>升级上线一小段时间之后，运维通过监控工具<code>prometheus</code>发现各个服务实例创建了大量的线程，最少都有500+，最多的单个实例更是达到了4000+，明显太不正常了。持续关注了一段时间后发现线程数一直在增加，并没有减少的迹象，遂开始排查问题。</p><h2 id="问题解决">问题解决</h2><p>首先由运维暂时性的定时重启实例来保证服务的正常。</p><p>然后利用<a href="https://arthas.gitee.io/index.html">Arthas</a>的<code>thread</code>命令：查找最忙的N个线程、阻塞其他线程的线程、指定状态（WAITTING、TIMED_WAITTING等）的线程等等，观察发现有大量的<code>nacos.naming</code>线程。遂去GitHub Nacos的issues搜索有没有相关的问题描述，果然<a href="https://github.com/alibaba/nacos/issues/4491">#4491</a>这个issue跟我们的问题很相似，观察到的线程状态跟他的截图也差不多。</p><p>之后定位到的是Dubbo issue<a href="https://github.com/apache/dubbo/issues/6988">#6988</a>和 <a href="https://github.com/apache/dubbo/issues/6568">#6568</a>，源自2.7.7版本的一个bug。之后按照Dubbo 2.7.9版本的解决方式编译打包了一个新版本来解决这个问题，注意并没有直接升级Dubbo最新版本，是因为怕再出现一些其它问题。</p><h2 id="问题分析">问题分析</h2><p>由于issue上已经把问题代码指出来并进行了修复，那我们现在根据观察到的线程结合源码来反向追踪到问题代码。</p><p>利用<a href="https://arthas.gitee.io/index.html">Arthas</a>的<code>thread</code>命令查找到的线程，发现大部分的都是<code>nacos.naming</code>相关线程，譬如：</p><ul><li><code>nacos.client.naming.updater</code>：<code>HostReactor</code>实例的周期任务线程，用来更新本地缓存的服务实例列表的定时任务。</li><li><code>nacos.client.naming.client.listener</code>：<code>EventDispatcher</code>实例的周期任务线程，定时监听服务实例变更的消息（从<code>HostReactor</code>处得知）并分发<code>NamingEvent</code>事件给订阅者。</li><li><code>nacos.client.naming.push.receiver</code>：<code>PushReceiver</code>实例的周期任务线程，开启UDP端口，接收Naocs服务端主动推送的实例节点变动信息，调用<code>HostReactor</code>的相关方法来更新服务实例列表，再做ack响应。</li></ul><p>查看相关源码发现，这些线程都跟<code>NacosNamingService</code>这个类有关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实现了NamingService接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NacosNamingService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NamingService</span> &#123;<br>    ...<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(Properties properties)</span> &#123;<br>        namespace = InitUtils.initNamespaceForNaming(properties);<br>        initServerAddr(properties);<br>        InitUtils.initWebRootContext();<br>        initCacheDir();<br>        initLogName(properties);<br><br>        eventDispatcher = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventDispatcher</span>();<br>  <span class="hljs-comment">// 代理对象，跟注册中心Server相关的请求都走它</span><br>        serverProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NamingProxy</span>(namespace, endpoint, serverList, properties);<br>  <span class="hljs-comment">// 客户端心跳</span><br>        beatReactor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeatReactor</span>(serverProxy, initClientBeatThreadCount(properties));<br>  <span class="hljs-comment">// 客户端实例刷新</span><br>        hostReactor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HostReactor</span>(eventDispatcher, serverProxy, cacheDir, isLoadCacheAtStart(properties),<br>            initPollingThreadCount(properties));<br>    &#125;<br>    ...<br></code></pre></td></tr></table></figure><p>再继续追溯，发现其实例都是由<code>NamingFactory</code>创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NamingFactory</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> NamingService <span class="hljs-title function_">createNamingService</span><span class="hljs-params">(String serverList)</span> <span class="hljs-keyword">throws</span> NacosException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; driverImplClass = Class.forName(<span class="hljs-string">&quot;com.alibaba.nacos.client.naming.NacosNamingService&quot;</span>);<br>            <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> driverImplClass.getConstructor(String.class);<br>            <span class="hljs-type">NamingService</span> <span class="hljs-variable">vendorImpl</span> <span class="hljs-operator">=</span> (NamingService)constructor.newInstance(serverList);<br>            <span class="hljs-keyword">return</span> vendorImpl;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NacosException</span>(NacosException.CLIENT_INVALID_PARAM, e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 最终是这个方法被调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> NamingService <span class="hljs-title function_">createNamingService</span><span class="hljs-params">(Properties properties)</span> <span class="hljs-keyword">throws</span> NacosException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; driverImplClass = Class.forName(<span class="hljs-string">&quot;com.alibaba.nacos.client.naming.NacosNamingService&quot;</span>);<br>            <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> driverImplClass.getConstructor(Properties.class);<br>            <span class="hljs-type">NamingService</span> <span class="hljs-variable">vendorImpl</span> <span class="hljs-operator">=</span> (NamingService)constructor.newInstance(properties);<br>            <span class="hljs-keyword">return</span> vendorImpl;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NacosException</span>(NacosException.CLIENT_INVALID_PARAM, e);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NacosFactory</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Create naming service</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> properties init param</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Naming</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NacosException Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 此方法被外部所调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> NamingService <span class="hljs-title function_">createNamingService</span><span class="hljs-params">(Properties properties)</span> <span class="hljs-keyword">throws</span> NacosException &#123;<br>        <span class="hljs-keyword">return</span> NamingFactory.createNamingService(properties);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个方法被两个地方调用到，一个是<code>NacosDiscoveryProperties</code>，一个是<code>NacosNamingServiceUtils</code>。但由于此次问题是由于Dubbo升级导致的，所以最后的调用方可以不用关心前者，它是Nacos注册发现相关的调用。</p><p>继续查看<code>NacosNamingServiceUtils</code>的调用链，最后定位到了问题代码<code>NacosRegistryFactory#createRegistryCacheKey</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建NacosRegistry对象的工厂，NacosRegistry就是Dubbo集成Nacos的注册类，通过它从Nacos上拉取、注册、移除服务实例，</span><br><span class="hljs-comment">// 最终是通过NacosNamingService来实现的，所以每一个NacosRegistry对象都会持有一个NamingService的对象。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NacosRegistryFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractRegistryFactory</span> &#123;<br><br>  <span class="hljs-comment">// 这个方法就是产生问题的方法代码</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> String <span class="hljs-title function_">createRegistryCacheKey</span><span class="hljs-params">(URL url)</span> &#123;<br>      <span class="hljs-comment">/** 问题代码中是没有这一段注释代码的，直接返回了 url.toFullString()</span><br><span class="hljs-comment">        String namespace = url.getParameter(CONFIG_NAMESPACE_KEY);</span><br><span class="hljs-comment">        // 重点一：这一个url.toServiceStringWithoutResolving()方法是没有拼接parameter的</span><br><span class="hljs-comment">        // 也就是说新的url指向的是一个基础protocol+host+port的字符串，相当于移除了多余的参数（传入的URL中是包含其它参数的）。</span><br><span class="hljs-comment">        url = URL.valueOf(url.toServiceStringWithoutResolving());</span><br><span class="hljs-comment">        if (StringUtils.isNotEmpty(namespace)) &#123;</span><br><span class="hljs-comment">            // 如果有namespace则添加为新url的参数</span><br><span class="hljs-comment">            url = url.addParameter(CONFIG_NAMESPACE_KEY, namespace);</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">      */</span><br><br>      <span class="hljs-comment">// 这个方法拼接了URL的完整路径：protocol(+username+password)+host+port+servicekey+其它parameters</span><br>      <span class="hljs-comment">// 上面这段修复代码加上了之后，这个时候parameters其实里面只有namespace一个参数了。</span><br>        <span class="hljs-keyword">return</span> url.toFullString();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Registry <span class="hljs-title function_">createRegistry</span><span class="hljs-params">(URL url)</span> &#123;<br>      <span class="hljs-comment">// 这个地方调用到了创建NamingService实例的方法，可以看出是跟NacosRegistry实例关联的</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NacosRegistry</span>(url, createNamingService(url));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 父类 AbstractRegistryFactory</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractRegistryFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RegistryFactory</span> &#123;<br>  <br>    ...<br>  <br>    <span class="hljs-comment">// 重点二：这个url中包含了其他参数，其中引发bug的就是含有一个timestamp参数，导致缓存未命中，重复大量创建了Registry对象，</span><br>    <span class="hljs-comment">// 进而出现很多的NamingService实例，以及其创建的周期性任务线程。</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Registry <span class="hljs-title function_">getRegistry</span><span class="hljs-params">(URL url)</span> &#123;<br>      <span class="hljs-keyword">if</span> (destroyed.get()) &#123;<br>        LOGGER.warn(<span class="hljs-string">&quot;All registry instances have been destroyed, failed to fetch any instance. &quot;</span> +<br>                    <span class="hljs-string">&quot;Usually, this means no need to try to do unnecessary redundant resource clearance, all registries has been taken care of.&quot;</span>);<br>        <span class="hljs-keyword">return</span> DEFAULT_NOP_REGISTRY;<br>      &#125;<br><br>      url = URLBuilder.from(url)<br>        .setPath(RegistryService.class.getName())<br>        .addParameter(INTERFACE_KEY, RegistryService.class.getName())<br>        .removeParameters(EXPORT_KEY, REFER_KEY)<br>        .build();<br>      <span class="hljs-comment">// 这儿创建一个缓存map的key，避免重复创建 Registry 实例，期望同一个NameSpaceId下的Registry实例只会创建一个（单例）。</span><br>      <span class="hljs-comment">// 但是由于这个方法里面没有将url中的多余参数timestamp移除，导致缓存key未命中重复创建大量的Registry实例。</span><br>      <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> createRegistryCacheKey(url);<br>      <span class="hljs-comment">// Lock the registry access process to ensure a single instance of the registry</span><br>      LOCK.lock();<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> REGISTRIES.get(key);<br>        <span class="hljs-keyword">if</span> (registry != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">return</span> registry;<br>        &#125;<br>        <span class="hljs-comment">//create registry by spi/ioc</span><br>        registry = createRegistry(url);<br>        <span class="hljs-keyword">if</span> (registry == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Can not create registry &quot;</span> + url);<br>        &#125;<br>        REGISTRIES.put(key, registry);<br>        <span class="hljs-keyword">return</span> registry;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// Release the lock</span><br>        LOCK.unlock();<br>      &#125;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>通过Arthas的<code>getstatic</code>命令查看 <code>AbstractRegistryFactory</code>的<code>REGISTRIES</code>缓存map中的key，这是我在测试环境获取到的示例：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">[arthas@1]$ getstatic org.apache.dubbo.registry.support.AbstractRegistryFactory REGISTRIES<br>field: REGISTRIES<br>@HashMap[<br>    @String[nacos:<span class="hljs-regexp">//na</span><span class="hljs-keyword">cos</span>-cs.nacos.svc.cluster.local:<span class="hljs-number">8848</span>/DEFAULT_GROUP/org.apache.dubbo.registry.RegistryService?namespace=test-rpc]:@NacosRegistry[nacos:<span class="hljs-regexp">//na</span><span class="hljs-keyword">cos</span>-cs.nacos.svc.cluster.local:<span class="hljs-number">8848</span>/org.apache.dubbo.registry.RegistryService?application=auth-center&amp;dubbo=<span class="hljs-number">2.0</span>.<span class="hljs-number">2</span>&amp;group=DEFAULT_GROUP&amp;id=org.apache.dubbo.config.RegistryConfig<span class="hljs-comment">#0&amp;interface=org.apache.dubbo.registry.RegistryService&amp;namespace=test-rpc&amp;pid=1&amp;qos.enable=false&amp;release=2.7.9&amp;timestamp=1616754580092]</span><br>]<br></code></pre></td></tr></table></figure><p>正确key的组成：</p><p><code>nacos://nacos-cs.nacos.svc.cluster.local:8848/DEFAULT_GROUP/org.apache.dubbo.registry.RegistryService?namespace=test-rpc</code></p><p>源码分析时也参考了这个issue <a href="https://github.com/apache/dubbo/issues/6568">#6568</a>的debug截图，基本搞清楚了整个问题产生的原因以及解决方式的逻辑。</p><h2 id="小结">小结</h2><p>升级开源基础组件一定要慎重，对于待升级版本的评审还是很重要的，可以预先通过官网、GitHub或者StackOverflow等等调研下相关版本的问题再动手也不迟 ~</p>]]></content>
    
    
    
    <tags>
      
      <tag>Dubbo</tag>
      
      <tag>Nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并行流引起的MySQL死锁</title>
    <link href="/article/Java%E5%B9%B6%E8%A1%8C%E6%B5%81%E5%BC%95%E8%B5%B7%E7%9A%84MySQL%E6%AD%BB%E9%94%81/"/>
    <url>/article/Java%E5%B9%B6%E8%A1%8C%E6%B5%81%E5%BC%95%E8%B5%B7%E7%9A%84MySQL%E6%AD%BB%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>之前（半年前）有同事在代码中使用<strong>并行流</strong>来操作数据库，基于MySQL 5.7版本默认的事务隔离级别<strong>RR（Repeatable Read - 可重复读）</strong>，在测试环境中出现了死锁的问题。</p><h2 id="解决方式">解决方式</h2><p>经过同事排查发现是在并发写的情况下触发MySQL的<strong>间隙锁</strong>再引发的死锁，最后把并行流改为串行解决问题，主要是数据量不大没有必要使用并行。</p><h2 id="问题一、并行流的使用">问题一、并行流的使用</h2><p>具体分析可以看看这里☞<a href="https://luckycaesar.github.io/article/%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E5%B9%B6%E8%A1%8C%E6%B5%81/">什么时候使用并行流</a>，翻译至Doug Lea大神的文章。</p><p>总结来说就是并行流并不一定能提升效率，是和<u>数据量以及流中每个操作的复杂度</u>挂钩的。而且Java底层采用<strong>ForkJoinPool</strong>的方式来实现，并行流的盲目使用反而会带来额外的线程创建的开销，拖慢程序响应速度。</p><h2 id="问题二、MySQL事务隔离级别及读一致性问题分析">问题二、MySQL事务隔离级别及读一致性问题分析</h2><h3 id="事务隔离级别">事务隔离级别</h3><p>MySQL的事务隔离级别主要是为了解决并发事务（基于InnoDB）下的读一致性问题，主要有以下四种：</p><table><thead><tr><th>隔离级别</th><th>读数据一致性</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交读（Read uncommitted）</td><td>最低级别，只能保证不读取物理上损坏的数据</td><td>是</td><td>是</td><td>是</td></tr><tr><td>已提交读（Read committed，RC）</td><td>语句级</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读（Read repeatable，RR）</td><td>事务级</td><td>否</td><td>否</td><td>是</td></tr><tr><td>可序列化（Serilizable）</td><td>最高级别，事务级</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><ul><li>脏读：事务一读取了事务二未提交的数据（MySQL buffer pool）。</li><li>不可重复读：重点是数据是否被修改。事务一读取数据，事务二对数据进行了修改并提交，事务一再次以同样的条件读取，两次读取的数据不一致。</li><li>幻读：主要是新增or删除操作，重点是数据是否存在。事务一针对某一条件的数据进行读取、修改，然后提交，事务二新增or删除了同样条件的数据，导致事务一提交后发现还存在没有修改到的数据or数据已经不存在。</li></ul><p><u>实际上可能很多业务场景中为了保证数据库吞吐量，对于不可重复读和幻读问题有一定的容忍度，再就是RR级别下扫描的记录都要加锁，而RC级别下扫描过但不匹配的记录不会加锁，或者是先加锁再释放，这对扫描大量数据更新的场景影响很大。</u>所以像阿里云的RDS MySQL的默认隔离级别就调整为RC，而不是RR。</p><h3 id="MVVC、行锁、间隙锁">MVVC、行锁、间隙锁</h3><p>在MySQL中，读取实际上分为两种：<strong>快照读（官方定义：一致性非锁定读）和当前读</strong>。</p><ul><li><p>快照读：读取的是数据在某一时刻的快照（如果数据行没有发生改变则直接读取），普通的select…where…。<strong>RC和RR级别下默认的读取方式。</strong></p></li><li><p>当前读：始终读取的是最新的数据，如select … lock in share mode、select … for update、insert、update、delete</p></li></ul><p><strong>MVVC（Multiversion Concurrency Control）多版本并发控制</strong>：是通过了乐观锁理论（类似版本号比较）的方式来避免<strong>快照读中的不可重复读和幻读</strong>问题。但InnoDB中实际的实现并不是简单的版本号控制，而是借助了<strong>undo log</strong>。</p><ol><li><p>修改前的数据会存放于undo log，通过一个滚动指针关联，就是保存了一份之前版本的数据，也是为了事务的回滚操作；</p></li><li><p>每行数据有一个<strong>事务标识符 - TRX_ID</strong>（插入或更新该行的最后一个事务的标识符），通过对比数据行最新的事务ID和当前事务的ID来判断当前事务是直接读取该行数据还是读取undo log中对当前事务可见的版本数据。</p></li></ol><p>由于读取的数据要么是没被修改的，要么是历史版本的，所以在快照读的情况下不会出现不可重复读和幻读问题，但可能读取到过时的数据。</p><p><strong>行锁 + 间隙锁</strong>：组合起来就叫Next-Key Lock，主要是为了解决<strong>RR级别当前读的情况下出现的不可重复读和幻读</strong>问题。</p><ul><li>行锁（记录锁，Record Lock）：排他锁，直接加在索引记录（key）上，事务对数据修改时加行锁，保证可重复读。</li><li>间隙锁（Gap Lock）：共享锁，锁定某个事务扫描到的数据的索引记录的一个间隙（理解为一个范围），即使范围内不存在的数据也会被锁定，这样这个范围内的数据在事务未提交前肯定不会有变动，因为其他事务会被间隙锁阻塞。<strong>只针对非唯一索引</strong>，因为唯一键肯定不会有重复的插入。</li></ul><h2 id="场景复现">场景复现</h2><p>在理解了上述原理的情况下，就可以对问题进行复现（主要是太久了问题代码没有找到…╮(╯▽╰)╭）：</p><ul><li>并行流开启了多个并行的事务，需要执行写操作，在MySQL 5.7默认的<strong>RR</strong>事务隔离级别下，会触发<strong>间隙锁</strong>。</li><li>多个事务同时执行当前读，获取了同一个间隙锁，互相等待，就产生了死锁。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>并行流</tag>
      
      <tag>MySQL</tag>
      
      <tag>死锁</tag>
      
      <tag>间隙锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDD实践小结</title>
    <link href="/article/DDD%E5%AE%9E%E8%B7%B5%E5%B0%8F%E7%BB%93/"/>
    <url>/article/DDD%E5%AE%9E%E8%B7%B5%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="闲话">闲话</h2><p>这几个月公司对系统进行重构，我们的<a href="https://github.com/yangyang0507"><strong>架构师</strong></a>决定尝试下目前比较流行的设计思想 - DDD，领域驱动设计。这种设计理念很早就出现了，但是迄今为止除了大厂外并没有比较普适性的实践落地方案，也是由于许多中小型系统还达不到相当程度的复杂度来让DDD充分发挥其优势，或者由于部分开发人员的基本素质还达不到相关的要求，导致很难推行。</p><p>但就我所了解或者参与的一些项目，其中也使用到了DDD中所推崇的一些设计，譬如说：</p><ul><li><p>充血模型：简单来说，就是让实体对象也可以去处理一些逻辑，而不是简单的承载数据，在Service/Manager里面编写业务逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Long id;<br><br>    <span class="hljs-keyword">private</span> String code;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    ...<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNew</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getId() == <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(Customer targetCustomer)</span> &#123;<br>        ClassUtil.combineObjects(<span class="hljs-built_in">this</span>, targetCustomer);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">calculateImportance</span><span class="hljs-params">(CustomerImportanceStrategyCondition condition)</span> &#123;<br>        <span class="hljs-built_in">this</span>.setImportance(CustomerImportanceStrategyEnum.calculateImportance(condition));<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkDuplicateName</span><span class="hljs-params">(CustomerDuplicateCallable callBack)</span> &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkWhenTransforming</span><span class="hljs-params">(String customerName, String industryCode, CustomerSourceEnum source)</span> &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transferPhones</span><span class="hljs-params">(List&lt;CustomerPhoneReqDTO&gt; phoneList)</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样做的好处是可以让职责划分更明确，依赖边界更清晰，Service层也不再杂糅所有的逻辑，造成后续改动越来越乱的情况。但要使用好充血模型，得明确划分好业务中的各个领域/角色/模块，需要在开发前做好充分的设计。</p></li><li><p>仓储模式：顾名思义，属于跟持久层打交道的一种设计模式。简单说就是采用<strong>依赖倒置</strong>的方式，在业务层抽象仓储接口，定义CRUD方法，然后持久层依赖业务层，实现具体的方法。这样做的好处就是业务逻辑可以不关心持久层的具体实现，持久层任意替换数据存储方式或者持久化框架而不影响业务逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 注意这个包路径，业务领域层</span><br><span class="hljs-keyword">package</span> cn.xx.domain.customer.repository;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CustomerRepository</span> &#123;<br><br>    Customer <span class="hljs-title function_">getById</span><span class="hljs-params">(Long id)</span>;<br><br>    ...<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 持久层</span><br><span class="hljs-keyword">package</span> cn.xx.persistence.repository.impl.customer;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Repository</span><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomerRepositoryImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CustomerRepository</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CustomerFactory customerFactory;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CustomerMapper customerMapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Customer <span class="hljs-title function_">getById</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-keyword">return</span> customerFactory.toCustomerDO(customerMapper.selectById(id));<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="实践">实践</h2><p>整体的实践过程的话，个人感觉就是理想很丰满，现实很骨感，也是由于我们对DDD的理解实践经验不够，其实大部分还是按照传统的一些方式在做。</p><h3 id="战略设计">战略设计</h3><p>这一块的感觉最明显，基本上还是由产品去定义，其它角色主要是参与到业务讨论，或者架构讨论中去。</p><ul><li><p>产品愿景和场景分析：不过多赘述，我们做的是2B的SaaS系统，当然也包含了内部使用的一些模块，都嵌入到整个平台，其实基本上定型了。也没有专门的领域专家、需求分析人员等角色来参与，都是CTO、产品、架构师等。</p></li><li><p>领域建模和微服务拆分：领域建模并不严格和完整，大致上都是按职责功能等传统方式来划分，也有部分按照领域的概念独立出来。最后拆分出来的主要微服务如下：</p><ul><li><p>营销系统：针对客户挖掘和CRM客户关系管理，内部使用</p></li><li><p>客户端系统：对外提供给B端客户的APP或者Web客户端</p></li><li><p>财务系统：内部供财务使用</p></li><li><p>协议系统：统一管理与客户签订的合同协议</p></li><li><p>配置中心：基础数据，如省市区、行业、字典等，基础功能，如导入等</p></li><li><p>用户中心：员工数据和系统权限、资源配置</p></li><li><p>授权中心：登录、认证等</p></li><li><p>流程引擎：统一处理业务系统中所有的流程</p></li><li><p>文件系统</p></li><li><p>消息系统</p></li><li><p>BI服务</p><p>…</p></li></ul></li></ul><p>可以看出来整体的流程并不规范，但是很适合我们这样的小型团队，快速的定下产品基调，做好服务拆分，指派开发人员进行开发。</p><h3 id="战术设计">战术设计</h3><p>主要是单个微服务的分层结构规范，这部分由我们的<a href="https://github.com/yangyang0507"><strong>架构师</strong></a>重新设计。初始的设计是这样的：</p><p><img src="/img/image-20201117144112355.png" alt=""></p><p>从这张图也可以看出一些问题：</p><ul><li>VO、DTO、DO(Data Object or Domain Object)、PO的转换比较繁琐，最多有三层转换，极大的降低开发效率。</li><li>单独的Query层承担一些或复杂或简单的查询，但是下面还依赖了一层persistence，让简单的查询也变得麻烦，没有必要。</li></ul><p>优化后的最终版：</p><p><img src="/img/image-20201117162157114.png" alt=""></p><p>改进之后，可以看出更加合理，实践起来更接地气。</p><p>先定义下各种对象：</p><ul><li>VO：View Object，视图对象，主要是接口返回数据的封装，不同于系统内部的数据流转对象，接口返回的数据结构一定是经过各种转换封装的，易读易理解，不能简单的类似表字段。</li><li>DO（Query）：Data Object，实际上在这一层我们是用的DTO的后缀。</li><li>DTO：Data Transfer Object，数据传输对象，通用的后缀。</li><li>DO（Domain）：Domain Object，领域对象，包含领域属性以及行为（方法逻辑）。</li><li>PO：Persistent Object，持久化对象，映射数据库表的实体。</li></ul><p>再做一下整体结构梳理：</p><ul><li>Bootstrap：顾名思义，启动类和整个项目的基础配置文件就在这一层。</li><li>Interfaces：对外的接口层，包含Web和APP相关的接口和VO。</li><li>RPC：由于我们使用的是Dubbo，所以在这一层里去依赖RPC API并实现。</li><li>Query：query层，或简单或复杂的单纯的查询就走这一层，譬如分页等各种条件查询。</li><li>Application：应用层，对多个领域服务的一个编排、封装，形成完整的业务逻辑，对外提供粗粒度的服务。这一层中还有对事件（消息）的处理，我们消息的消费都是在这一层进行，具体实现可以向下调用领域服务层。</li><li>Domain：领域层，包含了某个领域的逻辑，使用充血模型在DO（Domain Object）中实现各个领域的逻辑，由DomainService统一封装向上提供接口。</li><li>Persistence：持久层，仓储模式，依赖倒置。</li><li>Infrastructure：基础设施层，Config（自定义配置）、Utils、Constant等。</li></ul><p>实际上在落地的过程中，还有一些改动，像PO就单独提出来一层，供Query和Persistence（使用了依赖倒置，实际上是Domain层）去依赖，这样Query层就不用再去创建PO，只需要创建Mapper即可。</p><h2 id="小结">小结</h2><p>总的来说，这次实践的收获还是蛮大的，对DDD的设计思想有了一个实际的落地方案，并在此过程中不断改进优化，使之更适合我们的团队。这让我们对它的理解更加深刻，在探索更合适的产品开发流程和微服务结构的道路上实实在在的迈出了一步。</p><p>细化一点，个人感觉在实际的代码设计和编写过程中，遵循<strong>领域对象和充血模型</strong>的方式去做，可能对于大多数业务场景来说是更好的选择，实际上这两者也是面向对象语言的抽象和封装的体现。</p>]]></content>
    
    
    
    <tags>
      
      <tag>领域驱动</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos不可用？服务不可用？</title>
    <link href="/article/Nacos%E4%B8%8D%E5%8F%AF%E7%94%A8%EF%BC%9F%E6%9C%8D%E5%8A%A1%E4%B8%8D%E5%8F%AF%E7%94%A8%EF%BC%9F/"/>
    <url>/article/Nacos%E4%B8%8D%E5%8F%AF%E7%94%A8%EF%BC%9F%E6%9C%8D%E5%8A%A1%E4%B8%8D%E5%8F%AF%E7%94%A8%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>最近在开发环境中，频频出现服务不可用的问题。还遇到过一次Nacos客户端连接不上服务端，但是管理平台能正常登录的问题。遂决定研究一波，记录下来。</p><h2 id="Nacos不可用">Nacos不可用</h2><h3 id="问题">问题</h3><p>部分容器在启动时一直报错，连接不上Nacos服务端，但是Nacos管理界面能正常登录查看，后来经过排查是<strong>集群的某一个节点挂掉了</strong>导致的。但是这时候问题来了，Nacos作为服务发现和注册中心以及配置中心，集群模式下需要保证CP，并采用Raft算法进行选举，就算挂掉一台节点也不应该出现连接不上的问题。所以到底是为什么呢？这里先来简单看看CAP和Raft。</p><h3 id="CAP">CAP</h3><blockquote><p>可以戳这里☞ <a href="http://www.ruanyifeng.com/blog/2018/07/cap.html">CAP定理</a></p></blockquote><p>CAP定理，其实理解起来很简单，主要是针对分布式系统提出来的三个指标，而这三个指标不可能同时满足。</p><ul><li><strong>P</strong> - Partition tolerance，网络分区容错性，客观存在的，只能接受。</li><li><strong>A</strong> - Availability，可用性，保证服务有响应，可能读取的数据不是最新的。</li><li><strong>C</strong> - Consistency，数据一致性，实例之间的数据保持一致，一台实例更新数据，另一台实例必须同步更新完数据后才能够被访问，保证读取的数据始终是最新的。</li></ul><p>从上面可以看出<strong>A</strong>和<strong>C</strong>之间也是互相矛盾的。所以，要在它们之间寻求平衡，根据不同的场景选取合适的保证。而Nacos作为服务发现与注册中心以及配置中心使用时，必须得保证CP。但是并不是严格的CP，因为在leader节点进行写操作和同步数据时，其它节点是可以提供查询的。而且在Leader节点宕机重新选举时，集群对外无法提供服务。当然，作为一个通用的解决方案，这种情况对于绝大部分系统是可以接受的。</p><h3 id="Raft">Raft</h3><p>作为目前比较流行的分布式一致性协议，它的实现和理解起来的难度相对较简单，像Nacos、Redis等都采用了它，先来简单了解下。</p><p>三种状态（角色）：</p><ul><li>Leader：负责接收所有客户端的请求，本地更新后再同步至其它节点。</li><li>Follower：响应Leader的更新请求，同步日志文件到本地。</li><li>Candidate：选主过程中的一个中间角色，候选者。</li></ul><p>如果Follower检测（心跳机制：Leader周期性的发送心跳）到了Leader节点宕机，会触发选举。</p><ul><li>Follower递增自己的任期（term）并转换为Candidate；</li><li>投票给自己并且给所有其它节点发送投票请求；</li><li>如果在相同任期内，获得大多数的选票，则成为新的Leader，并发送心跳保持自己的角色。选票结果采取先到先得的方式；如果自己的任期小于请求中的任期，则会认为请求对应的节点为Leader，自身转换为Follower；如果自己的任期大于请求中的任期，则拒绝投票，保持Candidate；</li><li>如果一段时间内没有选出Leader，可能是出现了平票，则会在选举超时后重新发起（递增任期、发送投票请求）；</li><li>为了避免出现平票的情况，<strong>选举的超时时间是在一个区间内随机选择的（150ms~300ms）</strong>。也就是说，每个节点选举超时的时间是一个随机值，大大降低了一直平票的可能性。</li></ul><p>然后就是所谓的<strong>日志复制</strong>，即数据同步。</p><ul><li>主要是Leader节点同步日志给Follower节点；</li><li>如果出现日志数据不一致的情况，Leader会强制覆盖Follower的日志数据；</li><li>Leader会维护每次同步日志的一个索引，每次同步时Follower会验证这个索引是否和自己本地的日志索引一致，不一致则Leader会在下一次推送日志时缩小这个索引，直到验证通过。</li></ul><h3 id="解决">解决</h3><p>Nacos集群在如上所述的理论支持下，就算Leader宕机，那么也应该是可以继续访问的。这点从我们能正常登录Nacos管理平台且能从控制台的节点列表看到有一台节点处于<code>DOWN</code>的状态而其它都是<code>UP</code>得以验证。那么问题可能就不是出在服务端了，应该是客户端的问题，虽然把DOWN掉的Nacos节点重启后，客户端的访问就正常了。最后，经过和运维的一番排查，发现是<u><strong>yml配置文件中连接Nacos的地址是集群内部访问域名地址，并不是对外的VIP（Virtual IP Address）地址</strong></u>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br>        <span class="hljs-comment"># 下面这个</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">nacos-hs.nacos.svc.cluster.local:8848</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yml</span><br>        <span class="hljs-attr">shared-configs:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">config-port.yml</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">config-actuator.yml</span><br></code></pre></td></tr></table></figure><p>这里就涉及到Nacos的寻址，采用虚拟IP（VIP）的方式。集群模式下，<strong>客户端连接时要使用这个VIP地址，当某个节点不可用时会自动转发到其它可用节点</strong>。本质上是依靠TCP/IP的ARP协议，详细了解学习可以戳这里☞<a href="https://developer.aliyun.com/article/598792">微服务架构中基于DNS的服务发现</a>。</p><p>这样一来就说的通了，客户端用拿到的IP地址（Java中DNS解析到IP后会缓存下来）一直尝试去连接DOWN掉的Nacos节点，肯定是一直失败，这也造成了一种Nacos集群不可用的假象。后来更新配置文件后，验证也没有问题了。Bingo!</p><h2 id="服务不可用">服务不可用</h2><h3 id="问题-2">问题</h3><p>最近公司项目在搞重构，基本上是推倒重来，新的架构设计，也用上了k8s流水线，很方便我们开发与快速部署。但是问题也随即出现，在dev环境，尤其是在前后端联调（开发会把自己本地的机子注册到Nacos上去）的时候会频繁的出现服务不可用的情况，这是为什么呢？这里先整理下主要用到的开源技术。</p><ul><li>网关：GateWay + Ribbon + Hystrix</li><li>RPC：Dubbo</li><li>服务发现与注册中心：Nacos</li><li>配置中心：Nacos</li><li>其它：SpringCloud Stream + RocketMQ，Redis，MySQL等等</li></ul><p>从报的错误提示”服务不可用“来搜索，发现是网关里面找不到正确的服务实例而报出来的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FallbackController</span> &#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/fallback/common&quot;)</span><br>    <span class="hljs-keyword">public</span> Result&lt;Object&gt; <span class="hljs-title function_">fallbackCommon</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Result.failed(<span class="hljs-string">&quot;服务不可用，请稍后再试！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>会触发这个fallback的提示，是因为对应的路由下的服务实例不可用。所以，对上面所述的情况做下总结：</p><ul><li>服务实例频繁上下线，且实例中有真正的dev容器，也有开发自己的机器；</li><li>采用了Ribbon作为负载均衡器；</li><li>采用Nacos作为服务发现与注册中心。</li></ul><p>这里还是先来简单分析下Nacos和Ribbon的服务实例列表更新机制。</p><h3 id="Nacos">Nacos</h3><p>Nacos上的实例分为两种，持久化实例和临时实例，二者可以同时存在。</p><ul><li>临时实例：默认情况下都是临时实例，在健康检查不通过的情况下，随后的一段时间内会被剔除。适合大部分场景，如弹性扩容和缩容，多余的实例会自动销毁。</li><li>持久化实例：在健康检查不通过的情况下，不会剔除当前实例，只会标记为不健康。适合运维场景，实时查看健康状态，便于如告警、扩容等操作。</li></ul><p>是否临时实例由客户端<code>Instance</code>类中的<code>ephemeral</code>属性（短暂的; 瞬息的）控制，默认为true。接下来是健康检查机制：</p><ul><li>临时实例：客户端会生成定时任务，<strong>每隔5s向服务端发送心跳告知存活。服务端也存在定时检测，超过15s没有收到心跳则认为不健康，超过30s则剔除实例。</strong></li><li>持久化实例：由服务端主动检测。Server端会生成一个<code>HealthCheckTask</code>，再由<code>TcpSuperSenseProcessor</code>处理，这里利用了NIO来实现。（<code>SocketChannel</code>，<code>Selector.open()</code>）</li></ul><p>目前我们的系统默认都是<strong>临时实例，所以实例变更时会存在时延</strong>。</p><h3 id="Ribbon">Ribbon</h3><p>作为SpringCloud中实现客户端负载均衡的利器，Ribbon核心的一些接口如下：</p><ul><li><code>ILoadBalancer</code>，这个接口下的实现<code>BaseLoadBalancer</code>是整个Ribbon实现负载均衡的核心类。</li><li><code>IRule</code>，负载均衡规则选取的核心接口，默认提供了轮询、随机、响应时长权重等等选取合适实例的算法。</li><li><code>IPing</code>，这个接口主要是负责检测Ribbon自己缓存的服务实例是否存活。</li></ul><p>这里面重点要说的是<code>BaseLoadBalancer</code>这个类的核心逻辑，先整理下几个核心属性：</p><ol><li><code>allServerList</code>和<code>upServerList</code>：这两个集合分别存储了从客户端（这个客户端指的是当前Ribbon所在的服务实例）拉取的所有要进行负载均衡的服务实例列表和经过检测后还存活的服务实例列表。</li><li><code>DEFAULT_RULE</code>：负载均衡选取实例的规则，默认的是轮询。</li><li><code>DEFAULT_PING_STRATEGY</code>：默认Ping的策略，初始化<code>BaseLoadBalancer</code>时默认为null，或者为DummyPing（假Ping，永远返回true）。这个地方是一个核心关注点。</li><li>还用到了两把<code>ReadWriteLock</code>：<code>allServerLock</code>和<code>upServerLock</code>，分别用来控制<code>allServerList</code>和<code>upServerList</code>的读写。</li></ol><p>再就是核心逻辑：</p><ol><li>首先，不管使用Nacos还是Eureka作为服务发现注册中心，每台实例本地都会缓存一份依赖的服务实例列表。</li><li><strong>Ribbon会从当前所在实例的本地实例列表中拉取（<u>定时，默认30s</u>，在<code>BaseLoadBalancer</code>的实现类<code>DynamicServerListLoadBalancer</code>中）可用的实例列表</strong>，先存放到<code>allServerList</code>。在每次服务实例列表有变更时，先去更新<code>allServerList</code>，然后依据设置的Ping策略去依次判断可用的服务列表，添加到<code>upServerList</code>中。</li><li>默认的负载均衡选取规则是<code>RoundRobinRule</code>，轮询。在选取目标实例时，会判断<code>upServerList</code>是否为空，不为空则依次从<code>allServerList</code>中选取可用的实例作为目标实例。<strong>注意，这个时候由于默认的设置，所以拿到的服务永远是可用的，即<code>isAlive</code>总为true。</strong></li></ol><p>可以看出，<strong>Ribbon在获取最新实例时也是存在时延的，且默认情况下没有开启定时Ping的任务</strong>。</p><h3 id="解决-2">解决</h3><p>所以，问题就很明显了。结合上面的分析，采用定时的方式进行更新，那么必定有延时，当然在实际生产环境中，基本上不可能如此频繁的变更实例，所以一定的延时是完全没有问题的。而在我们的dev环境，由于容器频繁的重新部署或者开发机器上下线，导致经常出现服务不可用的情况，这也很正常。</p><p>当然我们可以改进一下，比如<strong>缩小Ribbon/Nacos的定时拉取/剔除实例的时间间隔，开启Ribbon中定时Ping及时感知服务下线</strong>。但其实我们更应该从另一些方面去减少这类问题的发生，如开发联调规范化、增加多联调环境等等。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Nacos</tag>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RedLock，红锁？</title>
    <link href="/article/RedLock%EF%BC%8C%E7%BA%A2%E9%94%81%EF%BC%9F/"/>
    <url>/article/RedLock%EF%BC%8C%E7%BA%A2%E9%94%81%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>翻译至Redis官网，<a href="https://redis.io/topics/distlock">原文链接</a></p><p>RedLock，即Distributed locks with Redis，Redis提供的分布式锁。</p></blockquote><h2 id="Distributed-locks-with-Redis">Distributed locks with Redis</h2><p>在很多场景下，不同的进程需要以互斥的方式去访问共享资源，这时候分布式锁是非常有用的原语。</p><p>目前有很多的库和博客文章描述了如何利用Redis去实现一个分布式锁管理器（DLM - Distributed Lock Manager），但是每个库都采用了不同的实现方式，与稍微复杂一点的设计相比，这些方式都显得比较简单而且可靠性低。</p><p>这篇文章试图提供一种更规范的算法来实现Redis分布式锁。我们将这种算法命名为RedLock，相较于普通的单Redis实例实现的DLM，我们相信这种方式更加的安全可靠。我们希望社区能够去分析它并提供反馈，然后将其用作实现更复杂或者非传统设计（的分布式锁）的一个起点。</p><h2 id="各个语言的实现库">各个语言的实现库</h2><p>(略).</p><h2 id="安全性和活性的保证">安全性和活性的保证</h2><blockquote><p>活性，并发下线程能及时执行的能力。</p></blockquote><p>我们将只从三个要素来建模我们的设计，因为从我们的角度来看，这三个要素是有效使用分布式锁所需要的最基本的保证。</p><ul><li>安全性：互斥。在给定的任何时刻，仅有一个客户端能够持有锁。</li><li>活性A：无死锁。（其他客户端）最终总是能够获取到锁，即使当前锁定资源的客户端崩溃或者分区。</li><li>活性B：容错。只要大部分（一般定义为超过一半）Redis节点存活，客户端就可以获取和释放锁。</li></ul><h2 id="为何基于故障转移的实现方式还不够">为何基于故障转移的实现方式还不够</h2><p>为了理解我们到底想要改进的是什么，让我们先分析一下大多数基于Redis的分布式锁的库的当前状态。</p><p>使用Redis锁定一个资源的最简单方式就是在一台实例上创建一个key。这个key通常是利用Redis的<code>expire</code>命令来限制它的存活时长，所以最终会被释放掉（符合上面列出来的第2个要素）。当客户端需要释放资源时，也可以主动删除这个key。</p><p>从表面上看一切都很好，但其实存在一个问题：在我们架构中会存在单点故障。如果Redis master节点宕机了怎么办？那好，我们再加一个slave节点，然后在master节点不可用时使用它替代。不幸的是，这种方式并不可取。这样一来，我们无法实现互斥的这一安全性保证，因为Redis的复制（同步）是异步的。</p><p>该模型存在很明显的竞态条件：</p><ol><li>客户端A获取了master节点的锁（key）。</li><li>master节点在key传输给slave节点之前崩溃了。</li><li>slave节点升级成为master。</li><li>客户端B获取了客户端A当前正在锁定的同一资源的锁（B获取了新的master节点的锁）。<strong>违反了安全性！</strong></li></ol><p>有时候在特殊情况下，譬如在故障期间，多个客户端同时持有锁是完全没有问题的。在这种情况下，你可以使用基于复制算法的解决方案。否则，我们还是建议使用本文所描述的方案。</p><h2 id="单Redis实例下的正确实现方式">单Redis实例下的正确实现方式</h2><p>在尝试克服上述单Redis实例设置的局限之前，我们先来看下在这个比较简单的场景中如何正确的进行设置。因为在时刻都有可能存在竞态条件的应用程序中，这实际上是一个可行的解决方案。而且锁定到单个Redis实例是本文所描述的分布式算法的基础。</p><p>为了获取锁，会采用如下的方式</p><p><code>SET resource_name my_random_value NX PX 30000</code></p><p>这条命令只会在key不存在的情况下（<code>NX</code>选项）把它设置进去，过期时间是30000毫秒（<code>PX</code>选项）。key设置了一个对应的值”my_random_value“。这个值在所有的客户端以及锁定请求中必须是唯一的。</p><p>基本上，使用这个随机值是为了以一种安全的方式释放锁。使用一个脚本告诉Redis：<strong>当且仅当key存在且存储在key上的值恰好是我所期望的值时，才能移除此key</strong>。可以使用下面这个Lua脚本实现：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&quot;get&quot;</span>,KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&quot;del&quot;</span>,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>（上面这个脚本中）很重要的一点是避免了删除另一个客户端创建的锁。譬如，一个客户端可能获取了该锁，然后在某些操作中阻塞（执行）的时间超过了该锁的有效时间（锁将要过期的时间），之后（操作完成之后）该客户端删除了这个锁（直接执行<code>DEL</code>命令），但其实这个锁已经被其它客户端获取了（或者说删除了其它客户端创建的锁，因为key是一样的）。所以仅仅使用<code>DEL</code>命令是不安全的，因为一个客户端可能删除另一个客户端创建的锁。而使用上述脚本，<strong>由于每个锁都持有一个随机字符串的”签名“（代表某个客户端），因此仅当仍然是设置当前锁的客户端尝试将锁删除时，当前锁才会被删除。</strong></p><p>那么这个随机字符串应该是什么样的呢？我会假设它是来自<code>/dev/random</code>下的20个字节。当然在你自己的程序任务中你可以去找一个更简单的方式来保证它的唯一性。（略，这段后面是一些关于随机串的选取方式。）</p><p>key的存活时间，我们把它叫做”lock validity time“（锁的有效期）。它既是锁自动释放的时间，又是当前客户端在另一个客户端再次获取锁之前必须执行的操作所需的时间，而在技术上又不违反互斥保证。该时间从获取锁的那一刻起，仅限于给定的时间窗口。</p><p>至此，我们有了一个比较好的方式去获取和释放锁。这个由单个且始终可用的实例组成的非分布式系统是安全的。接下来让我们把这个概念扩展到没有此类保证（始终可用）的分布式系统中去。</p><h2 id="RedLock算法">RedLock算法</h2><p>在此算法的分布式版本中，假定我们有N个Redis master节点。这些节点都是相互独立的，所以我们不会使用复制或者任何其它隐式的协调系统。我们已经描述了如何在一个单实例中去安全的获取和释放锁。想让然的也会认为此算法会采用这种方法在单个实例中获取和释放锁。在我们的例子里面，N=5，这是很合理的一个数值，然后我们会在不同的计算机或者虚拟机内运行5个Redis master节点，以此来保证它们失败时都是彼此独立的。</p><p>为了保证能获取到锁，客户端会做如下一些操作：</p><ol><li>获取当前的时间戳（毫秒）。</li><li>按顺序在N个实例中依次尝试获取锁，使用的都是同样的key和随机值。在这个步骤中，当在每一个实例中去设置锁的时候，客户端会设定一个小于锁的自动释放时长的超时时间，以便于能正常的获取锁。比如说锁的自动释放时长是10s，那么这个超时时间会设定为5~50ms之间。这样做是为了避免当一个Redis节点挂掉时，客户端仍然在相当长的一段时间内去尝试连接这个节点。如果一台实例不可用，我们应该尽快的去尝试连接下一台实例。</li><li>客户端会通过当前时间戳减去第一步中获取的时间戳，来计算在所有实例中获取锁所消耗的时间。当且仅当客户端能获取大部分实例的锁时（至少3台，<u><strong>大部分 = N/2 + 1</strong></u>），而且获取锁的总消耗时长小于锁的有效时长，分布式锁才被认为真正获取成功。</li><li>当锁获取成功后，它的有效时长会被认定为初始化设置的有效时长减去在第3步中计算出来的获取锁消耗的时长。</li><li>如果客户端由于某些原因（要么没有获取到大部分实例的锁，要么实际有效时间变为负数了）获取锁失败了，那么它会尝试去释放所有实例的锁（哪怕是那些它尝试获取锁失败的实例）。</li></ol><h2 id="这种算法是异步的吗">这种算法是异步的吗</h2><p>（可以认为是同步的，因为时钟漂移一般情况下很小。）该算法是基于这样一种假设，即进程（实例）之间在没有同步时钟时，每个进程中的本地时钟都是以相同的速率流动，相比于锁的自动释放时间，误差要小的多。这种假设与现实世界中的计算机非常相似：每台计算机都有一个本地时钟，我们通常可以依赖不同的计算机来获得一个很小的时钟漂移。</p><p>基于这一点，我们需要更好地指定互斥规则：持有锁的客户端在锁有效时间（<u>步骤3中获得的</u>）减去一些时间（为了补偿进程之间的时钟偏移，只有几毫秒）的时长后终止工作，这是可以保证的（互斥）。</p><p>（注：我的理解是<u>锁的实际有效时长 = 初始化时长（TTL） - 获取（所有实例中的）锁消耗时长 - 时钟漂移</u>，也就是要移除时钟漂移的误差。比如，初始化有效时长10s，获取锁消耗时长2s，不排除时钟漂移误差（假设为1s），那么有效时长为8s。由于存在时钟漂移，最后一台实例实际上相比于第一台实例，是相差了1s之后才开始有效时长计算的，这样就违背了互斥。更严格的话是要计算上时钟漂移误差的。）</p><h2 id="失败后的重试机制">失败后的重试机制</h2><p>当一个客户端无法获取锁时，<u>它应该在一个随机延迟后重试</u>，尝试去同步多个客户端在同一时刻获得同一资源的锁（因为可能导致<a href="https://www.cnblogs.com/yjmyzz/p/redis-split-brain-analysis.html">脑裂</a>，nobody wins）。同样，当客户端在大多数Redis实例中尝试获取锁的速度越快，出现脑裂（以及重试）的情况的窗口就会越小，因此理想情况下，客户端应该使用多路复用的形式尝试同时发送<code>SET</code>命令给N个实例。</p><p>值得强调的是，对于未能获取大多数锁的客户端，<u>尽可能快的释放（那部分）获取的锁是非常重要的</u>，这样就不用等到key（锁）过期之后才能再次获取（但是，如果发生网络分区，并且客户端再也不能和Redis实例进行通信，那么就要付出可用性上面的代价，因为要等到这个key过期之后才能再次获取）。</p><h2 id="锁的释放">锁的释放</h2><p>锁的释放比较简单，只需要释放所有实例上的锁即可。不管客户端能否成功锁定给定的实例。</p><h2 id="安全性讨论">安全性讨论</h2><p>这种算法安全么？我们可以尝试了解下在不同情况下会发生什么。</p><p>首先，我们假设客户端可以获取大多数实例上的锁。所有的实例都会包含一个具有相同过期时间的key。然而，key是在不同时间被设置的，所以它们也会在不同的时间失效。但是如果第一个key是在时间T1（在和第一台服务器连接之前采样的时间）设置的，并且最后一个key是在时间T2（从最后一台服务器得到答复的时间）设置的，我们可以确定的是集合中第一个key最小的有效时长<strong>MIN_VALIDITY = TTL（应用中设置的过期时间）- (T2 - T1) - CLOCK_DRIFT（时钟漂移）</strong>。所有其它的key都会在之后失效，所以我们可以确保至少这次这些key都会被同时设置。</p><p>在设置大多数key（成功or失败）的这段时间内，另一个客户端将无法获取锁，因为已经存在了N/2+1个key，所以N/2+1个 <code>SET NX</code>的操作都会失败。因此如果获取了锁，那么不可能在同一时间去重新获取它（违背了互斥性）。</p><p>然而我们还是要确保同一时间尝试获取锁的多个客户端不能同时成功。</p><p>如果一个客户端使用了一个与锁的最大过期时间（应用中设置的TTL）很接近或者更长一点的时间，来获取了大多数实例上的锁，那么这个锁就会被认为是无效的并且会被释放掉，因此我们只需要考虑客户端用小于有效时长的时间来获取大多数实例上的锁的这种情况。在这种情况下，上面已经说的很清楚了，在MIN_VALIDITY时间段内，没有客户端可以再次获取锁。所以当且仅当锁定大多数实例的时长大于TTL时长，多客户端才可以同时的锁定N/2+1的实例，而这种情况下锁会被视为无效。</p><p>您能否提供正式的安全性的证明，（或者）提出类似的现有算法，或者找出bug？这将不胜感激。</p><h2 id="活性讨论">活性讨论</h2><p>系统的活性主要有以下三个特征：</p><ol><li>锁的自动释放（当key过期时）：最终所有key都能够被再次获取。</li><li>通常情况下，客户端会在获取锁失败或者锁被获取了但是程序终止的情况下移除锁，使得我们不必等待锁过期后才能够再次获取锁。</li><li>当客户端需要重试获取锁时，它会等待一段时间，这段时间会比需要获取大多数锁的时间更长。这让在资源竞争期间出现脑裂的可能性大大降低。</li></ol><p>然而，当出现网络分区时，我们还是要付出相当于TTL时长的可用性代价，因此如果存在连续的分区，我们会无限期的付出这这个代价。每当客户端获取了锁但是在释放锁之前被分割，就会发生这种情况。</p><p>基本上，如果存在无限期的网络分区，那么系统就可能无限期的处于不可用的状态。</p><h2 id="性能，崩溃恢复和fsync">性能，崩溃恢复和fsync</h2><blockquote><p>sync - 不等待实际同步操作成功，直接返回。</p><p>fsync - 等待同步结果成功后才返回。</p></blockquote><p>使用Redis作为一个分布式锁服务，对性能的要求很高，不管是获取/释放锁的延迟，还是每秒能执行的获取/释放操作的次数。为了满足这种需求，与N个Redis服务进行通信的减少延迟的策略必定是多路复用（或者叫穷人的多路复用，把Socket置于非阻塞模式下，发送所有的命令，之后再读取所有的命令，假设客户端和每个实例的RTT（Round-Trip Time：往返时延）都是接近的）。</p><p>但是，如果我们想得到能在崩溃后恢复系统的模型，那么我们还需要考虑持久化的问题。</p><p>从根本上看，这里的问题是，假设我们配置Redis时没有设置持久化这一项，客户端要获取总共5台实例里面其中3台实例的锁，然后其中一台实例在客户端获取锁时重启了，这个时候针对同一资源，我们又有3台实例能够被访问获取到锁，然后另一个客户端成功获取到了锁。这就违反了排它锁的安全性。</p><p>如果我们开启了AOF的方式进行持久化，那么情况就会得到很大的改善。例如，我们可以在升级一个服务的时候发送<code>SHUTDOWN</code>命令然后重启它。因为Redis的过期是在语义上实现的，所以当服务关闭时，实际上时间仍在流逝（我的理解是并不是直接关闭，而是会有一段缓冲时间来持久化内存中的数据，重启后不会丢失），我们所有的要求都可以满足。当然，只要是优雅的停机所有的情况都会很好。那么如果突然断电呢？如果Redis默认配置了每秒都进行<code>fsync</code>同步数据到磁盘中，那么还是有可能出现重启之后key丢失的情况。理论上，我们要想在任何情况下的实例重启中都能保证锁的安全性，我们需要启用 fsync = 一直会处于持久化的设定状态。这反过来会破坏传统上以安全方式实现分布式锁的同级别的CP系统的性能。</p><p>但是事情比乍一看要好得多。基本上，只要实例在崩溃重启后不再参与到任何当前活动的锁当中，算法就能一直保持安全性。所以，当实例重启时一组当前正在活动的锁全部是锁定（其它正常的）实例而非这台正在重新加入系统的实例。</p><p>为了保证这些，我们要做的就是在一台实例崩溃后，至少要（让这台实例）在比我们设置的最大的<strong>TTL时间</strong>更长一点的时间段内保持不可用，这个时间（TTL）就是实例崩溃时存在的所有与锁有关的key变为无效并且自动释放所需的时间。</p><p>使用<em>delayed restarts</em>（延迟重启）基本上能保证安全性，即便没有任何Redis持久化的设置。但要注意的是，这可能会导致可用性下降。比如说大多数的实例都崩溃了，那么系统就会在TTL时间内变得全局不可用（这儿的全局指的是没有一个资源能够在这段时间内被锁定）。</p><h2 id="让算法更可靠：扩展锁">让算法更可靠：扩展锁</h2><p>(略).</p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么时候使用并行流</title>
    <link href="/article/%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E5%B9%B6%E8%A1%8C%E6%B5%81/"/>
    <url>/article/%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E5%B9%B6%E8%A1%8C%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<blockquote><p>翻译至Doug Lea关于并行流的介绍，<a href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">原文链接</a></p></blockquote><p><code>java.util.stream</code>框架支持对集合或者其他源进行<u>数据驱动</u>的操作，其中大多数方法都是对每一个数据元素应用相同的操作。<u>当多个内核可用时</u>，我们可以使用集合的<code>parallelStream()</code>方法，使得“数据驱动”变成“数据并行”。但是，什么时候应该这样做呢？（<em>注：说明不是有多核就可以盲目使用并行流</em>）</p><p>当各个操作是独立的，并且<u>计算量很大</u>或者是作用于<u>可以高效拆分数据结构的大量数据元素</u>，或者以上情况都有时，那么请考虑使用<code>S.parallelStream().operation(F)</code> 来替代<code>S.stream().operation(F)</code>。下面是详细的说明：</p><ul><li><strong>F</strong>，<u>每个元素的函数操作（通常是一个lambda）是独立的</u>：对每个数据元素的计算是<u>不需要依赖或者不会影响</u>其他任何数据元素的。</li><li><strong>S</strong>，<u>数据源集合可以被高效的拆分</u>。除了Collections外，还有一些其它易于并行化的stream数据源，譬如<code>java.util.SplittableRandom</code>（你可以使用<code>stream.parallel()</code>方法使之并行化）。但是大多数基于IO的数据源还是主要为了顺序使用而设计的。</li><li><u>执行顺序型式的总时间需要超过一个最小的阈值</u>。如今在大多数平台上，这个阈值大约是100微秒（的10倍以内），但是可以不用那么精准的去测量它。在实践中，使用 <u><strong>N</strong>（数据元素的个数） 乘以 <strong>Q</strong>（每个数据元素在 <strong>F</strong> 中消耗的时间成本）</u>就可以很好的估算了。反过来，也可以将 <strong>Q</strong> 表示为<u>操作数或者代码的行数</u>，然后检查 <strong>N * Q</strong> 至少为10000（如果还是怕这个数太小，也可以再加一两个0）。所以当 <strong>F</strong> 是一个很简单的函数比如<code>x-&gt;x+1</code>，那么只有当 <strong>N&gt;=10000</strong> 时使用parallel并行执行才会有价值。相反，当 <strong>F</strong> 需要进行大量的计算比如在棋局游戏中找到下一步的最佳走法，那么 <strong>Q</strong> 这个因子就会很大，以至于只要数据源集合可以被完全的拆分，<strong>N</strong> 就变得不那么重要了。</li></ul><p>Stream框架不会（也不能）去强制实施以上这些（<em>标准/理论</em>）。假如每个计算不是独立的，那用并行的方式去运行不但没有任何好处反而会出现很严重的错误。下面是一些其他说明，来自于三个工程问题和一些折中的思想：</p><ul><li>Start-up：<u>启动</u>。由于计算机处理器多年来一直在增加内核，其中大多数还添加了电源控制机制，这可能会导致内核启动速度变慢，有时还会增加JVM、操作系统和管理程序带来的额外开销。因此该阈值就大致相当于足够多的内核开始处理并行子任务所需的时间。一旦它们开始启动，并行计算就会比顺序计算能效更高（当然这取决于不同的处理器和操作系统的实现细节；可以看看这个例子<a href="http://queue.acm.org/detail.cfm?id=1658422">this article by Federova et al</a>）。</li><li>Granularity：<u>粒度</u>。对已经很小粒度的计算再进行细分是不值得的。Stream框架通常将问题进行分解，以便于系统上所有可用的内核都可以去运行处理。如果启动之后，每个内核实际上什么都做不了，那么设置并行计算（实际上大部分都是顺序计算的）的努力就白费了。考虑到目前内核数的实际范围在2~256之间，该阈值也避免了过度分区的影响。</li><li>Splittability：<u>可分拆性</u>。最有效的可拆分的集合包括ArrayLists和HashMaps（ConcurrentHashMaps），以及普通数组（比如形如T[ ]的数组，使用<code>java.util.Arrays</code>的静态方法拆分的数组）。效率最低的是LinkedLists，BlockingQueues和大多数基于IO的资源。其他的则介于两者之间（<u>如果数据结构内部支持随机访问、高效搜索，或者二者皆有，那么数据结构往往是高效可分的</u>）。如果拆分数据比处理数据的时间还长，那就没必要了。当然，如果计算的 <strong>Q</strong> 因子足够的大，即使对于一个<code>LinkedList</code>，使用并行流也可能更具效率，当然这并不常见。除此之外，一些数据源无法被拆分为单个元素，因此在任务划分的精细程度上可能有所限制。</li></ul><p>收集这些影响的详细度量是很困难的（尽管可以谨慎使用比如<a href="http://openjdk.java.net/projects/code-tools/jmh/">JMH</a>这样的工具）。但总体效果显而易见。你可以自己实验去感受下，比如在一台32核的测试机器上运行<code>ArrayList</code>的<code>max()</code>或者<code>sum()</code>这样的小函数，盈亏平衡点非常接近10K大小。更大的数据量可以看到高达20倍的加速。小于10K大小的运行时间并不比10K大小的运行时间少多少，因此通常比顺序运行时间更慢。（<em>注：上面两句对原句理解的不是特别清楚</em>）更糟糕的减速发生在当数据元素个数少于100时，这将激活一堆线程，然而这些线程最终没有任何事情可做，因为计算在它们开始运行之前就已经完成了。另一方面，当每个元素的计算非常耗时时，使用高效且可以完全分解的集合的好处是显而易见的，比如<code>ArrayList</code>。</p><p>换一种说法，在没有足够的计算量来证明它的合理性时使用<code>parallel()</code>可能会花费大约100微秒的时间，而在证明了其合理性时使用它至少会节省这么多时间（对于非常大的计算，可能会节省数小时）。（<em>注：我的理解是合理的使用<code>parallel()</code>会带来更高的效率，反之则会带来不必要的开销。</em>）具体的成本和收益是会随着时间和平台的变化而变化的，当然也会随着环境的变化而不同。例如，在一段顺序循环中去并行运行一个微小的计算会更突出（<em>注：使用并行操作带来的</em>）加速和减速的效果（做这样的微基准测试可能无法预测实际的使用情况）。</p><h2 id="提问与答疑">提问与答疑</h2><ul><li><p><strong>为什么JVM自己不能确定是否使用并行模式？</strong></p><p>JVM可以尝试，但是通常情况下都会给出糟糕的答案。过去30年来，对完全无导向的全自动的多核并行的追求并没有取得统一的成果，因此，Stream框架采用了更安全的方式，仅要求用户做出是或否的决策。这些决策依赖于工程上的折中，并且这些折中不太可能完全消失，这类似于顺序编程中经常会做的判断。例如，在仅包含单个元素的集合中寻找最大的元素而不是直接使用这个元素（不在集合内部）时，可能会遇到上百倍的开销（减速）。有时候JVM可以为您优化这种开销，但这在顺序的情况下并不常见，在并行的情况下更是从不适用。另一方面，我们也希望工具能帮助用户做更好的决策。</p></li><li><p><strong>我对 F, N, Q, S 这些参数的了解甚少，如何去更好的抉择呢？</strong></p><p>这也类似于常见的顺序性编程中出现的问题。比如，S 是一个<code>HashSet</code>，调用集合的方法<code>S.contains(x)</code>通常会很快，但是如果是<code>LinkedList</code>就会变慢了，其它的集合介于二者之间。通常，对于使用了集合的组件的作者来说，<u>最好的处理方法不是直接导出集合，而是基于集合导出操作</u>，这样用户就与这些决策隔绝了，这同样适用于并行操作。比如，一个内置“prices”集合的组件，可能会定义一个使用size大小阈值进行判断的方法，除非对每个元素的计算都非常昂贵。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getMaxPrice</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> priceStream().max(); &#125;<br><br><span class="hljs-keyword">private</span> Stream <span class="hljs-title function_">priceStream</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> (prices.size() &lt; MIN_PAR) ? <br>    prices.stream() : prices.parallelStream();<br>&#125;<br></code></pre></td></tr></table></figure><p>你可以通过各种方式扩展这一思想，以处理有关何时以及如何使用并行性的各种考虑。</p></li><li><p><strong>如果我的函数操作可能会涉及到IO或者同步呢？</strong></p><p>一种极端情况是没有通过独立性标准的函数，包括本质上是顺序的IO，对锁定同步资源的访问以及一个并行子任务执行IO失败对其他子任务会产生副作用。将这些函数并行没有多大意义。还有另一种极端情况是，执行偶发且短暂的IO或者很少阻塞的同步计算（例如大多数形式的日志以及对并发集合的大多数使用，如<code>ConcurrentHashMap</code>），这些（<em>使用并行</em>）都是无害的。介于这两者之间的中间情况最需要去判决。如果每个子任务在等待IO或者访问时都阻塞了一段时间，那么CPU资源可能会闲置，并且程序或者JVM也无法通过任何方式去使用它们。（<em>这样的话</em>）每个人都不开心。在这些情况下，使用并行流通常不是一个很好的选择，但还是有可用的比较好的替代方案，比如<code>async-IO</code>以及<code>CompletableFuture</code>的设计。</p></li><li><p><strong>如果我的数据源是基于IO的呢？</strong></p><p>目前，基于JDK IO的Stream源（例如<code>BufferedReader.lines()</code>）主要用于顺序性的使用，在元素到达时逐个处理。支持缓存IO的高效批处理也是有可能的，但是目前需要定制开发Stream源、Spliterators和/或Collectors，在JDK未来的发行版中可能会支持某些常见的类型（<em>数据源</em>）。</p></li><li><p><strong>如果我的程序运行在一台很繁忙的机器上，并且所有的核心都被占用了怎么办？</strong></p><p>机器通常只有一组固定的核心，当进行并行操作的时候不会变魔术般的多出更多的核心。然而，只要清晰的满足了选择并行执行的条件，那么就没有任何理由去担心（<em>机器繁忙的问题</em>）。你的并行任务执行时会与其它任务竞争CPU时间，所以你会看到加速得并没有那么多。在大多数情况下，这仍然比其他方式更有效。在底层机制的设计上，如果没有其他核心可用，你会发现对比顺序执行，（<em>并行执行速度</em>）只会有很小的减缓，除非系统已经超负荷到花费所有的时间在上下文切换上而不是执行真正的任务上，或者是在假定所有处理都是顺序的情况下进行调整的。如果你使用的是这样一个系统，管理员可能已经禁用了将多线程/多核心作为JVM配置的一部分。而如果你是管理员，那么可以考虑这样做（<em>禁用</em>）。</p></li><li><p><strong>是否所有操作都是以并行模式并行化执行？</strong></p><p>是，至少在某种程度上是这样的，尽管Stream框架在选择如何这样做时会遵循源和方法的约束。通常来说，更少的约束使更多潜在的并行性成为可能。另一方面，也无法保证该框架会提取并应用所有可能的并行机会。在某些情况下，如果你有足够的时间和专业知识，你可以手动实现一个更好的并行解决方案。</p></li><li><p><strong>使用并行化的方式能提升多少效率？</strong></p><p>如果你遵循这些准则，通常来说都是很值得的。但是可预测性并不是现代硬件和系统的强项，所以不可能给出普适性的答案。缓存位置、GC效率、JIT编译、内存争用、数据布局、操作系统定时调度策略以及虚拟机监视器的存在都是可能产生重大影响的因素。这些也在顺序执行的性能中发挥作用，但是通常会在并行设置中被放大：在顺序执行中造成10%的差异的问题会在并行执行中产生10倍的差异。</p><p>Stream框架囊括了一些能帮助你提高执行速度的工具。比如，像<code>IntStream</code>这样的原语使用了一些特殊的手段，在并行执行上比顺序执行更具效率，因为它不仅减少了开销（以及空间占用），还增强了缓存的局部性。并且，使用<code>ConcurrentHashMap</code>而不是<code>HashMap</code>作为并行“collect”操作的目标集合能减少内部的开销（<em>注：这里理解为<code>ConcurrentHashMap</code>是数据源集合，而不是collect到<code>ConcurrentHashMap</code>中</em>）。伴随着大家对框架的使用经验的累积，将会出现更多的技巧和指导。</p></li><li><p><strong>这一切都太可怕了！难道我们不应该制定一个使用JVM参数的策略来禁用并行化操作么？</strong></p><p>我们不想告诉你该怎么做，为程序员引入新的会使事情出错的方法是很可怕的。在编码、设计和决策上的错误肯定时有发生。但是有些人几十年来一直在预言，启用应用程序级别的并行会导致不可预知的重大灾难。（<em>这段感觉不太能明白</em>）</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java8</tag>
      
      <tag>ParallelStream</tag>
      
      <tag>DougLea</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
